# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-27 13:31-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/basic_usage.rst:10
msgid "Basic Usage"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:12
msgid "The ``spack`` command has many *subcommands*.  You'll only need a small subset of them for typical usage."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:15
msgid "Note that Spack colorizes output.  ``less -R`` should be used with Spack to maintain this colorization.  E.g.:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:22
msgid "It is recommended that the following be put in your ``.bashrc`` file:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:30
msgid "Listing available packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:32
msgid "To install software with Spack, you need to know what software is available.  You can see a list of available package names at the :ref:`package-list` webpage, or using the ``spack list`` command."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:40
msgid "``spack list``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:42
msgid "The ``spack list`` command prints out a list of all of the packages Spack can install:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:48
msgid "There are thosands of them, so we've truncated the output above, but you can find a :ref:`full list here <package-list>`. Packages are listed by name in alphabetical order. A pattern to match with no wildcards, ``*`` or ``?``, will be treated as though it started and ended with ``*``, so ``util`` is equivalent to ``*util*``.  All patterns will be treated as case-insensitive. You can also add the ``-d`` to search the description of the package in addition to the name.  Some examples:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:57
msgid "All packages whose names contain \"sql\":"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:61
msgid "All packages whose names or descriptions contain documentation:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:69
msgid "``spack info``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:71
msgid "To get more information on a particular package from `spack list`, use `spack info`.  Just supply the name of a package:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:76
msgid "Most of the information is self-explanatory.  The *safe versions* are versions that Spack knows the checksum for, and it will use the checksum to verify that these versions download without errors or viruses."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:81
msgid ":ref:`Dependencies <sec-specs>` and :ref:`virtual dependencies <sec-virtual-dependencies>` are described in more detail later."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:88
msgid "``spack versions``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:90
msgid "To see *more* available versions of a package, run ``spack versions``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:95
msgid "There are two sections in the output.  *Safe versions* are versions for which Spack has a checksum on file.  It can verify that these versions are downloaded correctly."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:99
msgid "In many cases, Spack can also show you what versions are available out on the web---these are *remote versions*.  Spack gets this information by scraping it directly from package web pages.  Depending on the package and how its releases are organized, Spack may or may not be able to find remote versions."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:107
msgid "Installing and uninstalling"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:113
msgid "``spack install``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:115
msgid "``spack install`` will install any package shown by ``spack list``. For example, To install the latest version of the ``mpileaks`` package, you might type this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:123
msgid "If ``mpileaks`` depends on other packages, Spack will install the dependencies first.  It then fetches the ``mpileaks`` tarball, expands it, verifies that it was downloaded without errors, builds it, and installs it in its own directory under ``$SPACK_ROOT/opt``. You'll see a number of messages from spack, a lot of build output, and a message that the packages is installed:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:150
msgid "The last line, with the ``[+]``, indicates where the package is installed."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:155
msgid "Building a specific version"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:157
msgid "Spack can also build *specific versions* of a package.  To do this, just add ``@`` after the package name, followed by a version:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:164
msgid "Any number of versions of the same package can be installed at once without interfering with each other.  This is good for multi-user sites, as installing a version that one user needs will not disrupt existing installations for other users."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:169
msgid "In addition to different versions, Spack can customize the compiler, compile-time options (variants), compiler flags, and platform (for cross compiles) of an installation.  Spack is unique in that it can also configure the *dependencies* a package is built with.  For example, two configurations of the same version of a package, one built with boost 1.39.0, and the other version built with version 1.43.0, can coexist."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:176
msgid "This can all be done on the command line using the *spec* syntax. Spack calls the descriptor used to refer to a particular package configuration a **spec**.  In the commands above, ``mpileaks`` and ``mpileaks@3.0.4`` are both valid *specs*.  We'll talk more about how you can use them to customize an installation in :ref:`sec-specs`."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:186
msgid "``spack uninstall``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:188
msgid "To uninstall a package, type ``spack uninstall <package>``.  This will ask the user for confirmation before completely removing the directory in which the package was installed."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:196
msgid "If there are still installed packages that depend on the package to be uninstalled, spack will refuse to uninstall it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:199
msgid "To uninstall a package and every package that depends on it, you may give the ``--dependents`` option."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:206
msgid "will display a list of all the packages that depend on ``mpich`` and, upon confirmation, will uninstall them in the right order."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:209
msgid "A command like"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:215
msgid "may be ambiguous if multiple ``mpich`` configurations are installed. For example, if both ``mpich@3.0.2`` and ``mpich@3.1`` are installed, ``mpich`` could refer to either one. Because it cannot determine which one to uninstall, Spack will ask you either to provide a version number to remove the ambiguity or use the ``--all`` option to uninstall all of the matching packages."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:222
msgid "You may force uninstall a package with the ``--force`` option"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:228
msgid "but you risk breaking other installed packages. In general, it is safer to remove dependent packages *before* removing their dependencies or use the ``--dependents`` option."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:237
msgid "Non-Downloadable Tarballs"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:239
msgid "The tarballs for some packages cannot be automatically downloaded by Spack.  This could be for a number of reasons:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:242
msgid "The author requires users to manually accept a license agreement before downloading (``jdk`` and ``galahad``)."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:245
msgid "The software is proprietary and cannot be downloaded on the open Internet."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:248
msgid "To install these packages, one must create a mirror and manually add the tarballs in question to it (see :ref:`mirrors`):"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:251
msgid "Create a directory for the mirror.  You can create this directory anywhere you like, it does not have to be inside ``~/.spack``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:258
msgid "Register the mirror with Spack by creating ``~/.spack/mirrors.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:265
msgid "Put your tarballs in it.  Tarballs should be named ``<package>/<package>-<version>.tar.gz``.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:274
msgid "Install as usual:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:282
msgid "Seeing installed packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:284
msgid "We know that ``spack list`` shows you the names of available packages, but how do you figure out which are already installed?"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:291
msgid "``spack find``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:293
msgid "``spack find`` shows the *specs* of installed packages.  A spec is like a name, but it has a version, compiler, architecture, and build options associated with it.  In spack, you can have many installations of the same package with different specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:298
msgid "Running ``spack find`` with no arguments lists installed packages:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:333
msgid "Packages are divided into groups according to their architecture and compiler.  Within each group, Spack tries to keep the view simple, and only shows the version of installed packages."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:337
msgid "``spack find`` can filter the package list based on the package name, spec, or a number of properties of their installation status.  For example, missing dependencies of a spec can be shown with ``--missing``, packages which were explicitly installed with ``spack install <package>`` can be singled out with ``--explicit`` and those which have been pulled in only as dependencies with ``--implicit``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:344
msgid "In some cases, there may be different configurations of the *same* version of a package installed.  For example, there are two installations of ``libdwarf@20130729`` above.  We can look at them in more detail using ``spack find --deps``, and by asking only to show ``libdwarf`` packages:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:360
msgid "Now we see that the two instances of ``libdwarf`` depend on *different* versions of ``libelf``: 0.8.12 and 0.8.13.  This view can become complicated for packages with many dependencies.  If you just want to know whether two packages' dependencies differ, you can use ``spack find --long``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:373
msgid "Now the ``libdwarf`` installs have hashes after their names.  These are hashes over all of the dependencies of each package.  If the hashes are the same, then the packages have the same dependency configuration."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:377
msgid "If you want to know the path where each package is installed, you can use ``spack find --paths``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:394
msgid "And, finally, you can restrict your search to a particular package by supplying its name:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:405
msgid "``spack find`` actually does a lot more than this.  You can use *specs* to query for specific configurations and builds of each package. If you want to find only libelf versions greater than version 0.8.12, you could say:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:416
msgid "Finding just the versions of libdwarf built with a particular version of libelf would look like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:426
msgid "We can also search for packages that have a certain attribute. For example, ``spack find libdwarf +debug`` will show only installations of libdwarf with the 'debug' compile-time option enabled."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:430
msgid "The full spec syntax is discussed in detail in :ref:`sec-specs`."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:436
msgid "Specs & dependencies"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:438
msgid "We know that ``spack install``, ``spack uninstall``, and other commands take a package name with an optional version specifier.  In Spack, that descriptor is called a *spec*.  Spack uses specs to refer to a particular build configuration (or configurations) of a package. Specs are more than a package name and a version; you can use them to specify the compiler, compiler version, architecture, compile options, and dependency options for a build.  In this section, we'll go over the full syntax of specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:447
msgid "Here is an example of a much longer spec than we've seen thus far:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:453
msgid "If provided to ``spack install``, this will install the ``mpileaks`` library at some version between ``1.2`` and ``1.4`` (inclusive), built using ``gcc`` at version 4.7.5 for the Blue Gene/Q architecture, with debug options enabled, and without Qt support.  Additionally, it says to link it with the ``callpath`` library (which it depends on), and to build callpath with ``gcc`` 4.7.2.  Most specs will not be as complicated as this one, but this is a good example of what is possible with specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:462
msgid "More formally, a spec consists of the following pieces:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:464
msgid "Package name identifier (``mpileaks`` above)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:465
msgid "``@`` Optional version specifier (``@1.2:1.4``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:466
msgid "``%`` Optional compiler specifier, with an optional compiler version (``gcc`` or ``gcc@4.7.3``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:468
msgid "``+`` or ``-`` or ``~`` Optional variant specifiers (``+debug``, ``-qt``, or ``~qt``) for boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:470
msgid "``name=<value>`` Optional variant specifiers that are not restricted to boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:472
msgid "``name=<value>`` Optional compiler flag specifiers. Valid flag names are ``cflags``, ``cxxflags``, ``fflags``, ``cppflags``, ``ldflags``, and ``ldlibs``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:474
msgid "``target=<value> os=<value>`` Optional architecture specifier (``target=haswell os=CNL10``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:476
msgid "``^`` Dependency specs (``^callpath@1.1``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:478
msgid "There are two things to notice here.  The first is that specs are recursively defined.  That is, each dependency after ``^`` is a spec itself.  The second is that everything is optional *except* for the initial package name identifier.  Users can be as vague or as specific as they want about the details of building packages, and this makes spack good for beginners and experts alike."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:485
msgid "To really understand what's going on above, we need to think about how software is structured.  An executable or a library (these are generally the artifacts produced by building software) depends on other libraries in order to run.  We can represent the relationship between a package and its dependencies as a graph.  Here is the full dependency graph for ``mpileaks``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:502
msgid "Each box above is a package and each arrow represents a dependency on some other package.  For example, we say that the package ``mpileaks`` *depends on* ``callpath`` and ``mpich``.  ``mpileaks`` also depends *indirectly* on ``dyninst``, ``libdwarf``, and ``libelf``, in that these libraries are dependencies of ``callpath``.  To install ``mpileaks``, Spack has to build all of these packages.  Dependency graphs in Spack have to be acyclic, and the *depends on* relationship is directional, so this is a *directed, acyclic graph* or *DAG*."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:511
msgid "The package name identifier in the spec is the root of some dependency DAG, and the DAG itself is implicit.  Spack knows the precise dependencies among packages, but users do not need to know the full DAG structure. Each ``^`` in the full spec refers to some dependency of the root package. Spack will raise an error if you supply a name after ``^`` that the root does not actually depend on (e.g. ``mpileaks ^emacs@23.3``)."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:519
msgid "Spack further simplifies things by only allowing one configuration of each package within any single build.  Above, both ``mpileaks`` and ``callpath`` depend on ``mpich``, but ``mpich`` appears only once in the DAG.  You cannot build an ``mpileaks`` version that depends on one version of ``mpich`` *and* on a ``callpath`` version that depends on some *other* version of ``mpich``.  In general, such a configuration would likely behave unexpectedly at runtime, and Spack enforces this to ensure a consistent runtime environment."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:528
msgid "The point of specs is to abstract this full DAG from Spack users.  If a user does not care about the DAG at all, she can refer to mpileaks by simply writing ``mpileaks``.  If she knows that ``mpileaks`` indirectly uses ``dyninst`` and she wants a particular version of ``dyninst``, then she can refer to ``mpileaks ^dyninst@8.1``.  Spack will fill in the rest when it parses the spec; the user only needs to know package names and minimal details about their relationship."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:536
msgid "When spack prints out specs, it sorts package names alphabetically to normalize the way they are displayed, but users do not need to worry about this when they write specs.  The only restriction on the order of dependencies within a spec is that they appear *after* the root package.  For example, these two specs represent exactly the same configuration:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:548
msgid "You can put all the same modifiers on dependency specs that you would put on the root spec.  That is, you can specify their versions, compilers, variants, and architectures just like any other spec. Specifiers are associated with the nearest package name to their left. For example, above, ``@1.1`` and ``%gcc@4.7.2`` associates with the ``callpath`` package, while ``@1.2:1.4``, ``%gcc@4.7.5``, ``+debug``, ``-qt``, and ``target=haswell os=CNL10`` all associate with the ``mpileaks`` package."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:556
msgid "In the diagram above, ``mpileaks`` depends on ``mpich`` with an unspecified version, but packages can depend on other packages with *constraints* by adding more specifiers.  For example, ``mpileaks`` could depend on ``mpich@1.2:`` if it can only build with version ``1.2`` or higher of ``mpich``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:562
msgid "Below are more details about the specifiers that you can add to specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:566
msgid "Version specifier"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:568
msgid "A version specifier comes somewhere after a package name and starts with ``@``.  It can be a single version, e.g. ``@1.0``, ``@3``, or ``@1.2a7``.  Or, it can be a range of versions, such as ``@1.0:1.5`` (all versions between ``1.0`` and ``1.5``, inclusive).  Version ranges can be open, e.g. ``:3`` means any version up to and including ``3``. This would include ``3.4`` and ``3.4.2``.  ``4.2:`` means any version above and including ``4.2``.  Finally, a version specifier can be a set of arbitrary versions, such as ``@1.0,1.5,1.7`` (``1.0``, ``1.5``, or ``1.7``).  When you supply such a specifier to ``spack install``, it constrains the set of versions that Spack will install."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:579
msgid "If the version spec is not provided, then Spack will choose one according to policies set for the particular spack installation.  If the spec is ambiguous, i.e. it could match multiple versions, Spack will choose a version within the spec's constraints according to policies set for the particular Spack installation."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:585
msgid "Details about how versions are compared and how Spack determines if one version is less than another are discussed in the developer guide."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:590
msgid "Compiler specifier"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:592
msgid "A compiler specifier comes somewhere after a package name and starts with ``%``.  It tells Spack what compiler(s) a particular package should be built with.  After the ``%`` should come the name of some registered Spack compiler.  This might include ``gcc``, or ``intel``, but the specific compilers available depend on the site.  You can run ``spack compilers`` to get a list; more on this below."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:599
msgid "The compiler spec can be followed by an optional *compiler version*. A compiler version specifier looks exactly like a package version specifier.  Version specifiers will associate with the nearest package name or compiler specifier to their left in the spec."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:604
msgid "If the compiler spec is omitted, Spack will choose a default compiler based on site policies."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:612
msgid "Variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:614
msgid "Variants are named options associated with a particular package. They are optional, as each package must provide default values for each variant it makes available. Variants can be specified using a flexible parameter syntax ``name=<value>``. For example, ``spack install libelf debug=True`` will install libelf build with debug flags. The names of particular variants available for a package depend on what was provided by the package author. ``spack info <package>`` will provide information on what build variants are available."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:623
msgid "For compatibility with earlier versions, variants which happen to be boolean in nature can be specified by a syntax that represents turning options on and off. For example, in the previous spec we could have supplied ``libelf +debug`` with the same effect of enabling the debug compile time option for the libelf package."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:629
msgid "Depending on the package a variant may have any default value.  For ``libelf`` here, ``debug`` is ``False`` by default, and we turned it on with ``debug=True`` or ``+debug``.  If a variant is ``True`` by default you can turn it off by either adding ``-name`` or ``~name`` to the spec."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:634
msgid "There are two syntaxes here because, depending on context, ``~`` and ``-`` may mean different things.  In most shells, the following will result in the shell performing home directory substitution:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:643
msgid "If there is a user called ``debug``, the ``~`` will be incorrectly expanded.  In this situation, you would want to write ``libelf -debug``.  However, ``-`` can be ambiguous when included after a package name without spaces:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:653
msgid "Spack allows the ``-`` character to be part of package names, so the above will be interpreted as a request for the ``mpileaks-debug`` package, not a request for ``mpileaks`` built without ``debug`` options.  In this scenario, you should write ``mpileaks~debug`` to avoid ambiguity."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:659
msgid "When spack normalizes specs, it prints them out with no spaces boolean variants using the backwards compatibility syntax and uses only ``~`` for disabled boolean variants.  The ``-`` and spaces on the command line are provided for convenience and legibility."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:666
msgid "Compiler Flags"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:668
msgid "Compiler flags are specified using the same syntax as non-boolean variants, but fulfill a different purpose. While the function of a variant is set by the package, compiler flags are used by the compiler wrappers to inject flags into the compile line of the build. Additionally, compiler flags are inherited by dependencies. ``spack install libdwarf cppflags=\"-g\"`` will install both libdwarf and libelf with the ``-g`` flag injected into their compile line."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:676
msgid "Notice that the value of the compiler flags must be quoted if it contains any spaces. Any of ``cppflags=-O3``, ``cppflags=\"-O3\"``, ``cppflags='-O3'``, and ``cppflags=\"-O3 -fPIC\"`` are acceptable, but ``cppflags=-O3 -fPIC`` is not. Additionally, if the value of the compiler flags is not the last thing on the line, it must be followed by a space. The commmand ``spack install libelf cppflags=\"-O3\"%intel`` will be interpreted as an attempt to set ``cppflags=\"-O3%intel\"``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:684
msgid "The six compiler flags are injected in the order of implicit make commands in GNU Autotools. If all flags are set, the order is ``$cppflags $cflags|$cxxflags $ldflags <command> $ldlibs`` for C and C++ and ``$fflags $cppflags $ldflags <command> $ldlibs`` for Fortran."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:691
msgid "Compiler environment variables and additional RPATHs"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:693
msgid "In the exceptional case a compiler requires setting special environment variables, like an explicit library load path. These can bet set in an extra section in the compiler configuration (the supported environment modification commands are: ``set``, ``unset``, ``append-path``, and ``prepend-path``). The user can also specify additional ``RPATHs`` that the compiler will add to all executables generated by that compiler.  This is useful for forcing certain compilers to RPATH their own runtime libraries, so that executables will run without the need to set ``LD_LIBRARY_PATH``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:729
msgid "The section `environment` is interpreted as an ordered dictionary, which means two things. First, environment modification are applied in the order they are specified in the configuration file. Second, you cannot express environment modifications that require mixing different commands, i.e. you cannot `set` one variable, than `prepend-path` to another one, and than again `set` a third one."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:738
msgid "Architecture specifiers"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:740
msgid "The architecture can be specified by using the reserved words ``target`` and/or ``os`` (``target=x86-64 os=debian7``). You can also use the triplet form of platform, operating system and processor."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:748
msgid "Users on non-Cray systems won't have to worry about specifying the architecture. Spack will autodetect what kind of operating system is on your machine as well as the processor. For more information on how the architecture can be used on Cray machines, see :ref:`cray-support`"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:757
msgid "Virtual dependencies"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:759
msgid "The dependence graph for ``mpileaks`` we saw above wasn't *quite* accurate.  ``mpileaks`` uses MPI, which is an interface that has many different implementations.  Above, we showed ``mpileaks`` and ``callpath`` depending on ``mpich``, which is one *particular* implementation of MPI.  However, we could build either with another implementation, such as ``openmpi`` or ``mvapich``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:766
msgid "Spack represents interfaces like this using *virtual dependencies*. The real dependency DAG for ``mpileaks`` looks like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:780
msgid "Notice that ``mpich`` has now been replaced with ``mpi``. There is no *real* MPI package, but some packages *provide* the MPI interface, and these packages can be substituted in for ``mpi`` when ``mpileaks`` is built."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:785
msgid "You can see what virtual packages a particular package provides by getting info on it:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:790
msgid "Spack is unique in that its virtual packages can be versioned, just like regular packages.  A particular version of a package may provide a particular version of a virtual package, and we can see above that ``mpich`` versions ``1`` and above provide all ``mpi`` interface versions up to ``1``, and ``mpich`` versions ``3`` and above provide ``mpi`` versions up to ``3``.  A package can *depend on* a particular version of a virtual package, e.g. if an application needs MPI-2 functions, it can depend on ``mpi@2:`` to indicate that it needs some implementation that provides MPI-2 functions."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:802
msgid "Constraining virtual packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:804
msgid "When installing a package that depends on a virtual package, you can opt to specify the particular provider you want to use, or you can let Spack pick.  For example, if you just type this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:812
msgid "Then spack will pick a provider for you according to site policies. If you really want a particular version, say ``mpich``, then you could run this instead:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:820
msgid "This forces spack to use some version of ``mpich`` for its implementation.  As always, you can be even more specific and require a particular ``mpich`` version:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:828
msgid "The ``mpileaks`` package in particular only needs MPI-1 commands, so any MPI implementation will do.  If another package depends on ``mpi@2`` and you try to give it an insufficient MPI implementation (e.g., one that provides only ``mpi@:1``), then Spack will raise an error.  Likewise, if you try to plug in some package that doesn't provide MPI, Spack will raise an error."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:837
msgid "Specifying Specs by Hash"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:839
msgid "Complicated specs can become cumbersome to enter on the command line, especially when many of the qualifications are necessary to distinguish between similar installs. To avoid this, when referencing an existing spec, Spack allows you to reference specs by their hash. We previously discussed the spec hash that Spack computes. In place of a spec in any command, substitute ``/<hash>`` where ``<hash>`` is any amount from the beginning of a spec hash."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:847
msgid "For example, lets say that you accidentally installed two different ``mvapich2`` installations. If you want to uninstall one of them but don't know what the difference is, you can run:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:860
msgid "You can then uninstall the latter installation using:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:867
msgid "Or, if you want to build with a specific installation as a dependency, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:875
msgid "If the given spec hash is sufficiently long as to be unique, Spack will replace the reference with the spec to which it refers. Otherwise, it will prompt for a more qualified hash."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:879
msgid "Note that this will not work to reinstall a dependency uninstalled by ``spack uninstall --force``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:886
msgid "``spack providers``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:888
msgid "You can see what packages provide a particular virtual package using ``spack providers``.  If you wanted to see what packages provide ``mpi``, you would just run:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:894
msgid "And if you *only* wanted to see packages that provide MPI-2, you would add a version specifier to the spec:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:899
msgid "Notice that the package versions that provide insufficient MPI versions are now filtered out."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:904
msgid "Extensions & Python support"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:906
msgid "Spack's installation model assumes that each package will live in its own install prefix.  However, certain packages are typically installed *within* the directory hierarchy of other packages.  For example, modules in interpreted languages like `Python <https://www.python.org>`_ are typically installed in the ``$prefix/lib/python-2.7/site-packages`` directory."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:913
msgid "Spack has support for this type of installation as well.  In Spack, a package that can live inside the prefix of another package is called an *extension*.  Suppose you have Python installed like so:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:928
msgid "``spack extensions``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:930
msgid "You can find extensions for your Python installation like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:955
msgid "The extensions are a subset of what's returned by ``spack list``, and they are packages like any other.  They are installed into their own prefixes, and you can see this with ``spack find --paths``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:966
msgid "However, even though this package is installed, you cannot use it directly when you run ``python``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:984
msgid "Using Extensions"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:986
msgid "There are three ways to get ``numpy`` working in Python.  The first is to use :ref:`shell-support`.  You can simply ``use`` or ``load`` the module for the extension, and it will be added to the ``PYTHONPATH`` in your current shell."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:991
msgid "For tcl modules:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:998
msgid "or, for dotkit:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1005
msgid "Now ``import numpy`` will succeed for as long as you keep your current session open."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1010
msgid "Activating Extensions in a View"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1012
msgid "The second way to use extensions is to create a view, which merges the python installation along with the extensions into a single prefix. See :ref:`filesystem-views` for a more in-depth description of views and :ref:`cmd-spack-view` for usage of the ``spack view`` command."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1019
msgid "Activating Extensions Globally"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1021
msgid "As an alternative to creating a merged prefix with Python and its extensions, and prior to support for views, Spack has provided a means to install the extension into the Spack installation prefix for the extendee. This has typically been useful since extendable packages typically search their own installation path for addons by default."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1027
msgid "Global activations are performed with the ``spack activate`` command:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1033
msgid "``spack activate``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1042
msgid "Several things have happened here.  The user requested that ``py-numpy`` be activated in the ``python`` installation it was built with.  Spack knows that ``py-numpy`` depends on ``py-nose`` and ``py-setuptools``, so it activated those packages first.  Finally, once all dependencies were activated in the ``python`` installation, ``py-numpy`` was activated as well."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1049
msgid "If we run ``spack extensions`` again, we now see the three new packages listed as activated:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1077
msgid "Now, when a user runs python, ``numpy`` will be available for import *without* the user having to explicitly loaded.  ``python@2.7.8`` now acts like a system Python installation with ``numpy`` installed inside of it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1082
msgid "Spack accomplishes this by symbolically linking the *entire* prefix of the ``py-numpy`` into the prefix of the ``python`` package.  To the python interpreter, it looks like ``numpy`` is installed in the ``site-packages`` directory."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1087
msgid "The only limitation of global activation is that you can only have a *single* version of an extension activated at a time.  This is because multiple versions of the same extension would conflict if symbolically linked into the same prefix.  Users who want a different version of a package can still get it by using environment modules or views, but they will have to explicitly load their preferred version."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1096
msgid "``spack activate --force``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1098
msgid "If, for some reason, you want to activate a package *without* its dependencies, you can use ``spack activate --force``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1110
msgid "``spack deactivate``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1112
msgid "We've seen how activating an extension can be used to set up a default version of a Python module.  Obviously, you may want to change that at some point.  ``spack deactivate`` is the command for this.  There are several variants:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1117
msgid "``spack deactivate <extension>`` will deactivate a single extension.  If another activated extension depends on this one, Spack will warn you and exit with an error."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1120
msgid "``spack deactivate --force <extension>`` deactivates an extension regardless of packages that depend on it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1122
msgid "``spack deactivate --all <extension>`` deactivates an extension and all of its dependencies.  Use ``--force`` to disregard dependents."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1124
msgid "``spack deactivate --all <extendee>`` deactivates *all* activated extensions of a package.  For example, to deactivate *all* python extensions, use:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1134
msgid "Filesystem requirements"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1136
msgid "By default, Spack needs to be run from a filesystem that supports ``flock`` locking semantics.  Nearly all local filesystems and recent versions of NFS support this, but parallel filesystems or NFS volumes may be configured without ``flock`` support enabled.  You can determine how your filesystems are mounted with ``mount``.  The output for a Lustre filesystem might look like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1149
msgid "Note the ``flock`` option on both Lustre mounts."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1151
msgid "If you do not see this or a similar option for your filesystem, you have a few options. First, you can move your Spack installation to a filesystem that supports locking. Second, you could ask your system administrator to enable ``flock`` for your filesystem."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1156
msgid "If none of those work, you can disable locking in one of two ways:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1158
msgid "Run Spack with the ``-L`` or ``--disable-locks`` option to disable locks on a call-by-call basis."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1160
msgid "Edit :ref:`config.yaml <config-yaml>` and set the ``locks`` option to ``false`` to always disable locking."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1165
msgid "If you disable locking, concurrent instances of Spack will have no way to avoid stepping on each other.  You must ensure that there is only **one** instance of Spack running at a time.  Otherwise, Spack may end up with a corrupted database file, or you may not be able to see all installed packages in commands like ``spack find``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1171
msgid "If you are unfortunate enough to run into this situation, you may be able to fix it by running ``spack reindex``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1174
msgid "This issue typically manifests with the error below:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1198
msgid "A nicer error message is TBD in future versions of Spack."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1203
msgid "Getting Help"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1209
msgid "``spack help``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1211
msgid "If you don't find what you need here, the ``help`` subcommand will print out out a list of *all* of spack's options and subcommands:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1216
msgid "Adding an argument, e.g. ``spack help <subcommand>``, will print out usage information for a particular subcommand:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1221
msgid "Alternately, you can use ``spack --help`` in place of ``spack help``, or ``spack <subcommand> --help`` to get help on a particular subcommand."
msgstr ""

