# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 00:42-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/basic_usage.rst:10
# b7c2737cf42048feacaaa7c498c250d5
msgid "Basic Usage"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:12
# 395f8188d0394020a63ac0f61f2ab790
msgid "The ``spack`` command has many *subcommands*.  You'll only need a small subset of them for typical usage."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:15
# 80a509e76bbc404b895c4d3fda82bae1
msgid "Note that Spack colorizes output.  ``less -R`` should be used with Spack to maintain this colorization.  E.g.:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:22
# 68697f5ffac74e4c84124509db7db03c
msgid "It is recommended that the following be put in your ``.bashrc`` file:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:30
# 40eb76a681d549369ddf128407c5c7ba
msgid "Listing available packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:32
# 80c79f643c1d42969f99c067be46c96f
msgid "To install software with Spack, you need to know what software is available.  You can see a list of available package names at the :ref:`package-list` webpage, or using the ``spack list`` command."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:40
# 47e00a99221d44beb05dfd076dd3b21d
msgid "``spack list``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:42
# 1252bdf4fe7d4619b51fab8106fe9a1f
msgid "The ``spack list`` command prints out a list of all of the packages Spack can install:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:47
# 2159535d063f42419a03430ed557c2a7
msgid "The packages are listed by name in alphabetical order. A pattern to match with no wildcards, ``*`` or ``?``, will be treated as though it started and ended with ``*``, so ``util`` is equivalent to ``*util*``.  All patterns will be treated as case-insensitive. You can also add the ``-d`` to search the description of the package in addition to the name.  Some examples:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:54
# c20a48acefec480abc4a8e4d94ed3ea3
msgid "All packages whose names contain \"sql\":"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:58
# 7c5797cb90014db99f0fbd303411745e
msgid "All packages whose names or descriptions contain documentation:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:66
# 9b47639d26e648a1943016d83dc91122
msgid "``spack info``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:68
# 7ca8ab73057d4185babcbc0de185da6d
msgid "To get more information on a particular package from `spack list`, use `spack info`.  Just supply the name of a package:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:73
# c2900e7f850d431cb8c2388bb77140fb
msgid "Most of the information is self-explanatory.  The *safe versions* are versions that Spack knows the checksum for, and it will use the checksum to verify that these versions download without errors or viruses."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:78
# 55dc9646af6b467c812914e86d4fa31c
msgid ":ref:`Dependencies <sec-specs>` and :ref:`virtual dependencies <sec-virtual-dependencies>` are described in more detail later."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:85
# 65c9689303744ce2bf3eea544109653e
msgid "``spack versions``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:87
# 20fcf91fb3ca48499fca074d70dfa917
msgid "To see *more* available versions of a package, run ``spack versions``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:92
# 6d326988c31548d3bc9d4b06aa350280
msgid "There are two sections in the output.  *Safe versions* are versions for which Spack has a checksum on file.  It can verify that these versions are downloaded correctly."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:96
# cde9412c191f40daa4b62041a860c0ab
msgid "In many cases, Spack can also show you what versions are available out on the web---these are *remote versions*.  Spack gets this information by scraping it directly from package web pages.  Depending on the package and how its releases are organized, Spack may or may not be able to find remote versions."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:104
# 7b31a37653654a6eb598702525b015bd
msgid "Installing and uninstalling"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:110
# 3b7a4ef22cc24dfea1208b7a82c909d0
msgid "``spack install``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:112
# 759609dd3db14fb48c5b7d17802517e2
msgid "``spack install`` will install any package shown by ``spack list``. For example, To install the latest version of the ``mpileaks`` package, you might type this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:120
# 359c29371c13401894ad772e115ec75b
msgid "If ``mpileaks`` depends on other packages, Spack will install the dependencies first.  It then fetches the ``mpileaks`` tarball, expands it, verifies that it was downloaded without errors, builds it, and installs it in its own directory under ``$SPACK_ROOT/opt``. You'll see a number of messages from spack, a lot of build output, and a message that the packages is installed:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:147
# 9fbc4e446c4044aea93c186ed03a6855
msgid "The last line, with the ``[+]``, indicates where the package is installed."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:152
# d81e60b9a9f645cfacd6851b86465fe5
msgid "Building a specific version"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:154
# 72f744e2941e4c58ab396a3f8bb39c95
msgid "Spack can also build *specific versions* of a package.  To do this, just add ``@`` after the package name, followed by a version:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:161
# d91f50bdb17641f999aa7e6ff1f8d206
msgid "Any number of versions of the same package can be installed at once without interfering with each other.  This is good for multi-user sites, as installing a version that one user needs will not disrupt existing installations for other users."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:166
# 04fd1ce82cf84aefb13ea5220548a00c
msgid "In addition to different versions, Spack can customize the compiler, compile-time options (variants), compiler flags, and platform (for cross compiles) of an installation.  Spack is unique in that it can also configure the *dependencies* a package is built with.  For example, two configurations of the same version of a package, one built with boost 1.39.0, and the other version built with version 1.43.0, can coexist."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:173
# 629d04a9c317465d862c3df570682f7e
msgid "This can all be done on the command line using the *spec* syntax. Spack calls the descriptor used to refer to a particular package configuration a **spec**.  In the commands above, ``mpileaks`` and ``mpileaks@3.0.4`` are both valid *specs*.  We'll talk more about how you can use them to customize an installation in :ref:`sec-specs`."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:183
# 95ea5c98e3494ebdbbb037e0ffe5205d
msgid "``spack uninstall``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:185
# f207065594f34a94b28f08c0b390333d
msgid "To uninstall a package, type ``spack uninstall <package>``.  This will ask the user for confirmation before completely removing the directory in which the package was installed."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:193
# 2559c31f380342acbc6719303a68dce4
msgid "If there are still installed packages that depend on the package to be uninstalled, spack will refuse to uninstall it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:196
# b2d0a69c658c449384e42a1c5b3b4492
msgid "To uninstall a package and every package that depends on it, you may give the ``--dependents`` option."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:203
# ba2121ae596b40c4b98e42c1a4188844
msgid "will display a list of all the packages that depend on ``mpich`` and, upon confirmation, will uninstall them in the right order."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:206
# 0975594702184e5e990e6c986fb07026
msgid "A command like"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:212
# ef49b1881b914a4a8d3c7701e0d89de2
msgid "may be ambiguous if multiple ``mpich`` configurations are installed. For example, if both ``mpich@3.0.2`` and ``mpich@3.1`` are installed, ``mpich`` could refer to either one. Because it cannot determine which one to uninstall, Spack will ask you either to provide a version number to remove the ambiguity or use the ``--all`` option to uninstall all of the matching packages."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:219
# 39a9ff1b881a421c9fff976b9f42c178
msgid "You may force uninstall a package with the ``--force`` option"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:225
# 83ac50161a6f430aa043cfacc48cde8f
msgid "but you risk breaking other installed packages. In general, it is safer to remove dependent packages *before* removing their dependencies or use the ``--dependents`` option."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:234
# 8b6d240e1e244e9299084bc0791d270f
msgid "Non-Downloadable Tarballs"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:236
# fd94afd168a444b9b01b41b553926586
msgid "The tarballs for some packages cannot be automatically downloaded by Spack.  This could be for a number of reasons:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:239
# 2faa1529dd4e4f68b33e154e86919b54
msgid "The author requires users to manually accept a license agreement before downloading (``jdk`` and ``galahad``)."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:242
# 3442ef62b6c14c86ba6e97dde55c2840
msgid "The software is proprietary and cannot be downloaded on the open Internet."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:245
# 1c0471c0c3ff47109902b152c330835d
msgid "To install these packages, one must create a mirror and manually add the tarballs in question to it (see :ref:`mirrors`):"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:248
# 27b4cff9de32440295fd2203d96e068a
msgid "Create a directory for the mirror.  You can create this directory anywhere you like, it does not have to be inside ``~/.spack``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:255
# 8f16850bded6408ab08c29aa3c332afb
msgid "Register the mirror with Spack by creating ``~/.spack/mirrors.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:262
# a06c8f3ce488447881d3256b4d36d16c
msgid "Put your tarballs in it.  Tarballs should be named ``<package>/<package>-<version>.tar.gz``.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:271
# 39800ce479ef47fcaabbca9781aef220
msgid "Install as usual:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:279
# 688fcab4fbdc4308a359173e00de75fb
msgid "Seeing installed packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:281
# f70b4a118865463f90863ff7b9df5593
msgid "We know that ``spack list`` shows you the names of available packages, but how do you figure out which are already installed?"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:288
# 72734cce6501483185ad8bcec66186eb
msgid "``spack find``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:290
# f8145954a90948a8b9c18aa308f9e665
msgid "``spack find`` shows the *specs* of installed packages.  A spec is like a name, but it has a version, compiler, architecture, and build options associated with it.  In spack, you can have many installations of the same package with different specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:295
# 5c3ddba205a240cc961b88bce41b9ceb
msgid "Running ``spack find`` with no arguments lists installed packages:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:330
# f4fd19d2c8bd47bf809953d092ae47cd
msgid "Packages are divided into groups according to their architecture and compiler.  Within each group, Spack tries to keep the view simple, and only shows the version of installed packages."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:334
# 9cd3c85c4a9f4fe3994273ec44923cb6
msgid "``spack find`` can filter the package list based on the package name, spec, or a number of properties of their installation status.  For example, missing dependencies of a spec can be shown with ``--missing``, packages which were explicitly installed with ``spack install <package>`` can be singled out with ``--explicit`` and those which have been pulled in only as dependencies with ``--implicit``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:341
# 624ea57923da4c4eb6d9610a3a3033cb
msgid "In some cases, there may be different configurations of the *same* version of a package installed.  For example, there are two installations of ``libdwarf@20130729`` above.  We can look at them in more detail using ``spack find --deps``, and by asking only to show ``libdwarf`` packages:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:357
# 3c3fcb4919af4a26b503ca036d0b01b8
msgid "Now we see that the two instances of ``libdwarf`` depend on *different* versions of ``libelf``: 0.8.12 and 0.8.13.  This view can become complicated for packages with many dependencies.  If you just want to know whether two packages' dependencies differ, you can use ``spack find --long``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:370
# dbe8133a13ed43f08beeb4b984588165
msgid "Now the ``libdwarf`` installs have hashes after their names.  These are hashes over all of the dependencies of each package.  If the hashes are the same, then the packages have the same dependency configuration."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:374
# 154db92c75804fb89a8bfa2a44184bc8
msgid "If you want to know the path where each package is installed, you can use ``spack find --paths``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:391
# cf9175065e1d4da5a6257c947caec829
msgid "And, finally, you can restrict your search to a particular package by supplying its name:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:402
# c89088be55864f87a251729e47cd7b18
msgid "``spack find`` actually does a lot more than this.  You can use *specs* to query for specific configurations and builds of each package. If you want to find only libelf versions greater than version 0.8.12, you could say:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:413
# 66837b6fdddb4200a26fcfe49b2218f8
msgid "Finding just the versions of libdwarf built with a particular version of libelf would look like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:423
# 75821c25401b4653a8e4ac3e3d8538fa
msgid "We can also search for packages that have a certain attribute. For example, ``spack find libdwarf +debug`` will show only installations of libdwarf with the 'debug' compile-time option enabled."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:427
# abaac2b7eae44d32ac257f49640d3736
msgid "The full spec syntax is discussed in detail in :ref:`sec-specs`."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:433
# e33e4bf21bb34be2875d9a25d225f255
msgid "Specs & dependencies"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:435
# f965173efab744129516002c2451feed
msgid "We know that ``spack install``, ``spack uninstall``, and other commands take a package name with an optional version specifier.  In Spack, that descriptor is called a *spec*.  Spack uses specs to refer to a particular build configuration (or configurations) of a package. Specs are more than a package name and a version; you can use them to specify the compiler, compiler version, architecture, compile options, and dependency options for a build.  In this section, we'll go over the full syntax of specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:444
# 819d357e99794faa99c660f6f687bdbe
msgid "Here is an example of a much longer spec than we've seen thus far:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:450
# 2c9c08346a224c178a3e96fb6b679ab7
msgid "If provided to ``spack install``, this will install the ``mpileaks`` library at some version between ``1.2`` and ``1.4`` (inclusive), built using ``gcc`` at version 4.7.5 for the Blue Gene/Q architecture, with debug options enabled, and without Qt support.  Additionally, it says to link it with the ``callpath`` library (which it depends on), and to build callpath with ``gcc`` 4.7.2.  Most specs will not be as complicated as this one, but this is a good example of what is possible with specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:459
# a06d18021a154cbe89905d671e6e8d9d
msgid "More formally, a spec consists of the following pieces:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:461
# 67bfba4177e44653979b8ae6b73739b6
msgid "Package name identifier (``mpileaks`` above)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:462
# c3dd3b88ace64041835d050ebddea09f
msgid "``@`` Optional version specifier (``@1.2:1.4``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:463
# 3710b963d6c64173bd44f85e090e4895
msgid "``%`` Optional compiler specifier, with an optional compiler version (``gcc`` or ``gcc@4.7.3``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:465
# e26878172eb84ac2a5516f1ade651b68
msgid "``+`` or ``-`` or ``~`` Optional variant specifiers (``+debug``, ``-qt``, or ``~qt``) for boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:467
# 600cb1ca8c534249854da2b0bace150f
msgid "``name=<value>`` Optional variant specifiers that are not restricted to boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:469
# 6eb53a460c684cdfa43974f1708b23ea
msgid "``name=<value>`` Optional compiler flag specifiers. Valid flag names are ``cflags``, ``cxxflags``, ``fflags``, ``cppflags``, ``ldflags``, and ``ldlibs``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:471
# d17a2f89a6094ddd81e53330e2c04bdd
msgid "``target=<value> os=<value>`` Optional architecture specifier (``target=haswell os=CNL10``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:473
# d43ace007f324f3c8dd3df2a0c201e9b
msgid "``^`` Dependency specs (``^callpath@1.1``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:475
# 7576c9e679104733b348f3dedd0d9790
msgid "There are two things to notice here.  The first is that specs are recursively defined.  That is, each dependency after ``^`` is a spec itself.  The second is that everything is optional *except* for the initial package name identifier.  Users can be as vague or as specific as they want about the details of building packages, and this makes spack good for beginners and experts alike."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:482
# adfb6705e0c44d9fa3c616e6c3da3d8f
msgid "To really understand what's going on above, we need to think about how software is structured.  An executable or a library (these are generally the artifacts produced by building software) depends on other libraries in order to run.  We can represent the relationship between a package and its dependencies as a graph.  Here is the full dependency graph for ``mpileaks``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:499
# b44dce4256da454988a8c98e7a6f7d7d
msgid "Each box above is a package and each arrow represents a dependency on some other package.  For example, we say that the package ``mpileaks`` *depends on* ``callpath`` and ``mpich``.  ``mpileaks`` also depends *indirectly* on ``dyninst``, ``libdwarf``, and ``libelf``, in that these libraries are dependencies of ``callpath``.  To install ``mpileaks``, Spack has to build all of these packages.  Dependency graphs in Spack have to be acyclic, and the *depends on* relationship is directional, so this is a *directed, acyclic graph* or *DAG*."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:508
# 3e34bcb33b43456d9e66d69094b3db58
msgid "The package name identifier in the spec is the root of some dependency DAG, and the DAG itself is implicit.  Spack knows the precise dependencies among packages, but users do not need to know the full DAG structure. Each ``^`` in the full spec refers to some dependency of the root package. Spack will raise an error if you supply a name after ``^`` that the root does not actually depend on (e.g. ``mpileaks ^emacs@23.3``)."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:516
# 6cf83ffd55c34048899e22467edfc6ca
msgid "Spack further simplifies things by only allowing one configuration of each package within any single build.  Above, both ``mpileaks`` and ``callpath`` depend on ``mpich``, but ``mpich`` appears only once in the DAG.  You cannot build an ``mpileaks`` version that depends on one version of ``mpich`` *and* on a ``callpath`` version that depends on some *other* version of ``mpich``.  In general, such a configuration would likely behave unexpectedly at runtime, and Spack enforces this to ensure a consistent runtime environment."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:525
# b8d1b726d6c44c109f6af461de0c416a
msgid "The point of specs is to abstract this full DAG from Spack users.  If a user does not care about the DAG at all, she can refer to mpileaks by simply writing ``mpileaks``.  If she knows that ``mpileaks`` indirectly uses ``dyninst`` and she wants a particular version of ``dyninst``, then she can refer to ``mpileaks ^dyninst@8.1``.  Spack will fill in the rest when it parses the spec; the user only needs to know package names and minimal details about their relationship."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:533
# 542a6add3bb24f669fbec2c29a487ac3
msgid "When spack prints out specs, it sorts package names alphabetically to normalize the way they are displayed, but users do not need to worry about this when they write specs.  The only restriction on the order of dependencies within a spec is that they appear *after* the root package.  For example, these two specs represent exactly the same configuration:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:545
# 3ad010ee5c7a42a5b3de470fb2a13653
msgid "You can put all the same modifiers on dependency specs that you would put on the root spec.  That is, you can specify their versions, compilers, variants, and architectures just like any other spec. Specifiers are associated with the nearest package name to their left. For example, above, ``@1.1`` and ``%gcc@4.7.2`` associates with the ``callpath`` package, while ``@1.2:1.4``, ``%gcc@4.7.5``, ``+debug``, ``-qt``, and ``target=haswell os=CNL10`` all associate with the ``mpileaks`` package."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:553
# a33132a6c759438f88ab8f23d78854f8
msgid "In the diagram above, ``mpileaks`` depends on ``mpich`` with an unspecified version, but packages can depend on other packages with *constraints* by adding more specifiers.  For example, ``mpileaks`` could depend on ``mpich@1.2:`` if it can only build with version ``1.2`` or higher of ``mpich``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:559
# 0a2b52dde64848e8bd21ab6b02f86b74
msgid "Below are more details about the specifiers that you can add to specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:563
# f20d9e0566984b4f87ccedaa44bca637
msgid "Version specifier"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:565
# 403a817e1a27492e8c84a769545a328b
msgid "A version specifier comes somewhere after a package name and starts with ``@``.  It can be a single version, e.g. ``@1.0``, ``@3``, or ``@1.2a7``.  Or, it can be a range of versions, such as ``@1.0:1.5`` (all versions between ``1.0`` and ``1.5``, inclusive).  Version ranges can be open, e.g. ``:3`` means any version up to and including ``3``. This would include ``3.4`` and ``3.4.2``.  ``4.2:`` means any version above and including ``4.2``.  Finally, a version specifier can be a set of arbitrary versions, such as ``@1.0,1.5,1.7`` (``1.0``, ``1.5``, or ``1.7``).  When you supply such a specifier to ``spack install``, it constrains the set of versions that Spack will install."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:576
# 7874ff4029c24e0b9569a18768ea281a
msgid "If the version spec is not provided, then Spack will choose one according to policies set for the particular spack installation.  If the spec is ambiguous, i.e. it could match multiple versions, Spack will choose a version within the spec's constraints according to policies set for the particular Spack installation."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:582
# 9c0fca4fe1e842f2a7d3a88ccecf5c34
msgid "Details about how versions are compared and how Spack determines if one version is less than another are discussed in the developer guide."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:587
# a57a78b796004e54abead3cae03c7423
msgid "Compiler specifier"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:589
# 0fbf0cb20d3445ffb554597c2a8f1383
msgid "A compiler specifier comes somewhere after a package name and starts with ``%``.  It tells Spack what compiler(s) a particular package should be built with.  After the ``%`` should come the name of some registered Spack compiler.  This might include ``gcc``, or ``intel``, but the specific compilers available depend on the site.  You can run ``spack compilers`` to get a list; more on this below."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:596
# fb12093f0414421c981b6e9661f0d5e5
msgid "The compiler spec can be followed by an optional *compiler version*. A compiler version specifier looks exactly like a package version specifier.  Version specifiers will associate with the nearest package name or compiler specifier to their left in the spec."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:601
# e334a03046ba493092e9e2bb0eeb7d03
msgid "If the compiler spec is omitted, Spack will choose a default compiler based on site policies."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:609
# 7ab9922e6d0640098fd85b3dd51e843a
msgid "Variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:611
# b44d52f3668d4f58997cf7a6f8d32a62
msgid "Variants are named options associated with a particular package. They are optional, as each package must provide default values for each variant it makes available. Variants can be specified using a flexible parameter syntax ``name=<value>``. For example, ``spack install libelf debug=True`` will install libelf build with debug flags. The names of particular variants available for a package depend on what was provided by the package author. ``spack info <package>`` will provide information on what build variants are available."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:620
# a7f6560602a04ed3b256127f61fce049
msgid "For compatibility with earlier versions, variants which happen to be boolean in nature can be specified by a syntax that represents turning options on and off. For example, in the previous spec we could have supplied ``libelf +debug`` with the same effect of enabling the debug compile time option for the libelf package."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:626
# 417b50b8fb114e4583ac8c378c954466
msgid "Depending on the package a variant may have any default value.  For ``libelf`` here, ``debug`` is ``False`` by default, and we turned it on with ``debug=True`` or ``+debug``.  If a variant is ``True`` by default you can turn it off by either adding ``-name`` or ``~name`` to the spec."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:631
# e1a45bb0ec754547bfe660d60fd84bbe
msgid "There are two syntaxes here because, depending on context, ``~`` and ``-`` may mean different things.  In most shells, the following will result in the shell performing home directory substitution:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:640
# d02c6f8033f34df4a2c8e1a6e88bfaa6
msgid "If there is a user called ``debug``, the ``~`` will be incorrectly expanded.  In this situation, you would want to write ``libelf -debug``.  However, ``-`` can be ambiguous when included after a package name without spaces:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:650
# 4f684954c2974c9199f817c6b2e256d0
msgid "Spack allows the ``-`` character to be part of package names, so the above will be interpreted as a request for the ``mpileaks-debug`` package, not a request for ``mpileaks`` built without ``debug`` options.  In this scenario, you should write ``mpileaks~debug`` to avoid ambiguity."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:656
# ea06d8d602b145f3a627326020de3be6
msgid "When spack normalizes specs, it prints them out with no spaces boolean variants using the backwards compatibility syntax and uses only ``~`` for disabled boolean variants.  The ``-`` and spaces on the command line are provided for convenience and legibility."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:663
# 3ffc9aac272243308407f6d8d99e73b2
msgid "Compiler Flags"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:665
# e16cb406856e442d9f3a585eec8fb147
msgid "Compiler flags are specified using the same syntax as non-boolean variants, but fulfill a different purpose. While the function of a variant is set by the package, compiler flags are used by the compiler wrappers to inject flags into the compile line of the build. Additionally, compiler flags are inherited by dependencies. ``spack install libdwarf cppflags=\"-g\"`` will install both libdwarf and libelf with the ``-g`` flag injected into their compile line."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:673
# b53e050088944bcd87043bbfddfa8182
msgid "Notice that the value of the compiler flags must be quoted if it contains any spaces. Any of ``cppflags=-O3``, ``cppflags=\"-O3\"``, ``cppflags='-O3'``, and ``cppflags=\"-O3 -fPIC\"`` are acceptable, but ``cppflags=-O3 -fPIC`` is not. Additionally, if the value of the compiler flags is not the last thing on the line, it must be followed by a space. The commmand ``spack install libelf cppflags=\"-O3\"%intel`` will be interpreted as an attempt to set ``cppflags=\"-O3%intel\"``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:681
# 0048564a40cf4881abb9dc6a7eba82b4
msgid "The six compiler flags are injected in the order of implicit make commands in GNU Autotools. If all flags are set, the order is ``$cppflags $cflags|$cxxflags $ldflags <command> $ldlibs`` for C and C++ and ``$fflags $cppflags $ldflags <command> $ldlibs`` for Fortran."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:688
# e1a3ffd58082483d9ec326232cd47ac1
msgid "Compiler environment variables and additional RPATHs"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:690
# 75cbe83aeb1b4598afd422339c4a4c00
msgid "In the exceptional case a compiler requires setting special environment variables, like an explicit library load path. These can bet set in an extra section in the compiler configuration (the supported environment modification commands are: ``set``, ``unset``, ``append-path``, and ``prepend-path``). The user can also specify additional ``RPATHs`` that the compiler will add to all executables generated by that compiler.  This is useful for forcing certain compilers to RPATH their own runtime libraries, so that executables will run without the need to set ``LD_LIBRARY_PATH``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:726
# c7f3ccc4b29449809a2a055564515146
msgid "The section `environment` is interpreted as an ordered dictionary, which means two things. First, environment modification are applied in the order they are specified in the configuration file. Second, you cannot express environment modifications that require mixing different commands, i.e. you cannot `set` one variable, than `prepend-path` to another one, and than again `set` a third one."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:735
# 44ca82ef19fa470db5c408236b845d5f
msgid "Architecture specifiers"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:737
# 1ef13a26883f4293aabd993c8fa6b807
msgid "The architecture can be specified by using the reserved words ``target`` and/or ``os`` (``target=x86-64 os=debian7``). You can also use the triplet form of platform, operating system and processor."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:745
# a2dcd753b9b7438197eeebc638ea3fc2
msgid "Users on non-Cray systems won't have to worry about specifying the architecture. Spack will autodetect what kind of operating system is on your machine as well as the processor. For more information on how the architecture can be used on Cray machines, see :ref:`cray-support`"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:754
# b31f956545cc4a01b21513394117bb04
msgid "Virtual dependencies"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:756
# ba4346768df24eddbf5ae191d0b65616
msgid "The dependence graph for ``mpileaks`` we saw above wasn't *quite* accurate.  ``mpileaks`` uses MPI, which is an interface that has many different implementations.  Above, we showed ``mpileaks`` and ``callpath`` depending on ``mpich``, which is one *particular* implementation of MPI.  However, we could build either with another implementation, such as ``openmpi`` or ``mvapich``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:763
# 47ffd7f3c9b14919ac4939e1959b5bdb
msgid "Spack represents interfaces like this using *virtual dependencies*. The real dependency DAG for ``mpileaks`` looks like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:777
# db4c1765de9645058de9bf1d0fe50c3f
msgid "Notice that ``mpich`` has now been replaced with ``mpi``. There is no *real* MPI package, but some packages *provide* the MPI interface, and these packages can be substituted in for ``mpi`` when ``mpileaks`` is built."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:782
# d70582324d3345d79975e23f13053cda
msgid "You can see what virtual packages a particular package provides by getting info on it:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:787
# 05bcd60431334421b363b30d6c48f05a
msgid "Spack is unique in that its virtual packages can be versioned, just like regular packages.  A particular version of a package may provide a particular version of a virtual package, and we can see above that ``mpich`` versions ``1`` and above provide all ``mpi`` interface versions up to ``1``, and ``mpich`` versions ``3`` and above provide ``mpi`` versions up to ``3``.  A package can *depend on* a particular version of a virtual package, e.g. if an application needs MPI-2 functions, it can depend on ``mpi@2:`` to indicate that it needs some implementation that provides MPI-2 functions."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:799
# 628753486bc441018380b6e3deb18397
msgid "Constraining virtual packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:801
# 5755e9d7a0da416483d63c36b874bcb2
msgid "When installing a package that depends on a virtual package, you can opt to specify the particular provider you want to use, or you can let Spack pick.  For example, if you just type this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:809
# 8277df9711054172b12e2e14c59df9e8
msgid "Then spack will pick a provider for you according to site policies. If you really want a particular version, say ``mpich``, then you could run this instead:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:817
# 1f4efcae559f41ae94834d03e268f5fa
msgid "This forces spack to use some version of ``mpich`` for its implementation.  As always, you can be even more specific and require a particular ``mpich`` version:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:825
# d67fee3451544c758cb4a19ed95a57ad
msgid "The ``mpileaks`` package in particular only needs MPI-1 commands, so any MPI implementation will do.  If another package depends on ``mpi@2`` and you try to give it an insufficient MPI implementation (e.g., one that provides only ``mpi@:1``), then Spack will raise an error.  Likewise, if you try to plug in some package that doesn't provide MPI, Spack will raise an error."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:834
# a62e9b8460c54a2bad87c5d509f0e6bf
msgid "Specifying Specs by Hash"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:836
# 98062aa46f49403fba1b69559f7265bc
msgid "Complicated specs can become cumbersome to enter on the command line, especially when many of the qualifications are necessary to distinguish between similar installs. To avoid this, when referencing an existing spec, Spack allows you to reference specs by their hash. We previously discussed the spec hash that Spack computes. In place of a spec in any command, substitute ``/<hash>`` where ``<hash>`` is any amount from the beginning of a spec hash."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:844
# 631939be6ba244f6b3372ac27bdf6aee
msgid "For example, lets say that you accidentally installed two different ``mvapich2`` installations. If you want to uninstall one of them but don't know what the difference is, you can run:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:857
# 3c21c9c4fe084f408c0fc7140b81f66c
msgid "You can then uninstall the latter installation using:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:864
# 5aaaf0cf9c1f45c6ad9ccf30eb83f147
msgid "Or, if you want to build with a specific installation as a dependency, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:872
# 5ed9b713d94e4a378f749b648865d85a
msgid "If the given spec hash is sufficiently long as to be unique, Spack will replace the reference with the spec to which it refers. Otherwise, it will prompt for a more qualified hash."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:876
# 4abce4c837f244b8bb4208eaf6caee2e
msgid "Note that this will not work to reinstall a dependency uninstalled by ``spack uninstall --force``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:883
# 8476469fff564c8fa7141e841aafbc1f
msgid "``spack providers``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:885
# 2621c5ffa9b74d4abc2ec75e6ac21260
msgid "You can see what packages provide a particular virtual package using ``spack providers``.  If you wanted to see what packages provide ``mpi``, you would just run:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:891
# 8cdd79f19e59411886fde21cd5d22ccb
msgid "And if you *only* wanted to see packages that provide MPI-2, you would add a version specifier to the spec:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:896
# 9a7e340f77a7433aa5c6c2c24aa29d6d
msgid "Notice that the package versions that provide insufficient MPI versions are now filtered out."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:901
# 0ab677f20d50409fb3e8c0a2ddc00066
msgid "Extensions & Python support"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:903
# c135d002039c4f53b9e0106fd731c19a
msgid "Spack's installation model assumes that each package will live in its own install prefix.  However, certain packages are typically installed *within* the directory hierarchy of other packages.  For example, modules in interpreted languages like `Python <https://www.python.org>`_ are typically installed in the ``$prefix/lib/python-2.7/site-packages`` directory."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:910
# 1d1e6263c5394294a3311bfb7bfa1231
msgid "Spack has support for this type of installation as well.  In Spack, a package that can live inside the prefix of another package is called an *extension*.  Suppose you have Python installed like so:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:925
# 336260e8b90446d4b1bef9bdd64bf0dd
msgid "``spack extensions``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:927
# ee4108f22ac849b8bee312aaee18b9f4
msgid "You can find extensions for your Python installation like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:952
# d6416c24f0544097ad0ded5988a17832
msgid "The extensions are a subset of what's returned by ``spack list``, and they are packages like any other.  They are installed into their own prefixes, and you can see this with ``spack find --paths``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:963
# 639ce6c329de4fff9c86e70b39531129
msgid "However, even though this package is installed, you cannot use it directly when you run ``python``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:981
# 1ce7146c9242466ba6905271cd0eeaed
msgid "Using Extensions"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:983
# fd94add67b5844f2a44c04f5622a2158
msgid "There are three ways to get ``numpy`` working in Python.  The first is to use :ref:`shell-support`.  You can simply ``use`` or ``load`` the module for the extension, and it will be added to the ``PYTHONPATH`` in your current shell."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:988
# f84025a58df84dd4834c0934c22d7d56
msgid "For tcl modules:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:995
# 7fed831201474cf69457ec9b03278797
msgid "or, for dotkit:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1002
# 7a9e180b3a614c8b8459c2a55391ef36
msgid "Now ``import numpy`` will succeed for as long as you keep your current session open."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1007
# 2ac4d8f1c5ce44bdae6c662ab304e2fe
msgid "Activating Extensions in a View"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1009
# 7bb5b8e60fd24f449be0ebcd336fa32c
msgid "The second way to use extensions is to create a view, which merges the python installation along with the extensions into a single prefix. See :ref:`filesystem-views` for a more in-depth description of views and :ref:`cmd-spack-view` for usage of the ``spack view`` command."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1016
# 3ded0375ddc247f7aab8070f6df9a8ae
msgid "Activating Extensions Globally"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1018
# db22b7c28b4249b3a8bc18ea868d515e
msgid "As an alternative to creating a merged prefix with Python and its extensions, and prior to support for views, Spack has provided a means to install the extension into the Spack installation prefix for the extendee. This has typically been useful since extendable packages typically search their own installation path for addons by default."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1024
# 86acfc27cbae48ae9bc0cc324ee99025
msgid "Global activations are performed with the ``spack activate`` command:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1030
# eddfce8e6be64c0fb98cafe35a3f30bd
msgid "``spack activate``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1039
# 3e8b9a6b20134a20bf7ac2b87598d7ea
msgid "Several things have happened here.  The user requested that ``py-numpy`` be activated in the ``python`` installation it was built with.  Spack knows that ``py-numpy`` depends on ``py-nose`` and ``py-setuptools``, so it activated those packages first.  Finally, once all dependencies were activated in the ``python`` installation, ``py-numpy`` was activated as well."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1046
# 9425b4e7a3e2403ebdde232b1e42090f
msgid "If we run ``spack extensions`` again, we now see the three new packages listed as activated:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1074
# a77448a74eaf4894935f218388ba3948
msgid "Now, when a user runs python, ``numpy`` will be available for import *without* the user having to explicitly loaded.  ``python@2.7.8`` now acts like a system Python installation with ``numpy`` installed inside of it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1079
# 48a5e779ea894fbdbc17f79d0bcc3c18
msgid "Spack accomplishes this by symbolically linking the *entire* prefix of the ``py-numpy`` into the prefix of the ``python`` package.  To the python interpreter, it looks like ``numpy`` is installed in the ``site-packages`` directory."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1084
# 7e918bc174b24440a608edfc27320c26
msgid "The only limitation of global activation is that you can only have a *single* version of an extension activated at a time.  This is because multiple versions of the same extension would conflict if symbolically linked into the same prefix.  Users who want a different version of a package can still get it by using environment modules or views, but they will have to explicitly load their preferred version."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1093
# e8eb2a190d0447dda22ba497f1f51cbd
msgid "``spack activate --force``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1095
# 4ac20883ad6841958a15c7bb9fb5fd95
msgid "If, for some reason, you want to activate a package *without* its dependencies, you can use ``spack activate --force``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1107
# aeaec9044fa2430fa738dbe4b5d29c0b
msgid "``spack deactivate``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1109
# 3587df56a67a41dda04409fa8eb5f278
msgid "We've seen how activating an extension can be used to set up a default version of a Python module.  Obviously, you may want to change that at some point.  ``spack deactivate`` is the command for this.  There are several variants:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1114
# e3745a4262644177b5fc1ab447ab7c37
msgid "``spack deactivate <extension>`` will deactivate a single extension.  If another activated extension depends on this one, Spack will warn you and exit with an error."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1117
# 7ac581fa0587461b86e92d14dd5fc3e1
msgid "``spack deactivate --force <extension>`` deactivates an extension regardless of packages that depend on it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1119
# c84203941b534b2d926894d5d0c82475
msgid "``spack deactivate --all <extension>`` deactivates an extension and all of its dependencies.  Use ``--force`` to disregard dependents."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1121
# b9ba84f127734756be58915a5aca4c89
msgid "``spack deactivate --all <extendee>`` deactivates *all* activated extensions of a package.  For example, to deactivate *all* python extensions, use:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1131
# 1693c23386994892ac8cf04155adbc12
msgid "Filesystem requirements"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1133
# 576eccc8c664451db2bf4f65288bb556
msgid "By default, Spack needs to be run from a filesystem that supports ``flock`` locking semantics.  Nearly all local filesystems and recent versions of NFS support this, but parallel filesystems or NFS volumes may be configured without ``flock`` support enabled.  You can determine how your filesystems are mounted with ``mount``.  The output for a Lustre filesystem might look like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1146
# 3ab822b6905749a8bb278b7c0ce146b0
msgid "Note the ``flock`` option on both Lustre mounts."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1148
# 1fbeeada96ef414885dd67d8cef0676b
msgid "If you do not see this or a similar option for your filesystem, you have a few options. First, you can move your Spack installation to a filesystem that supports locking. Second, you could ask your system administrator to enable ``flock`` for your filesystem."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1153
# b552d9801efe4c77b4ebf938d15b2f43
msgid "If none of those work, you can disable locking in one of two ways:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1155
# 48c7849ef3fe4bb1be39462f401595f7
msgid "Run Spack with the ``-L`` or ``--disable-locks`` option to disable locks on a call-by-call basis."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1157
# 2fd95ebbe506432ca4afb769bde79be2
msgid "Edit :ref:`config.yaml <config-yaml>` and set the ``locks`` option to ``false`` to always disable locking."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1162
# 4689472c1384497092cd67bceb624095
msgid "If you disable locking, concurrent instances of Spack will have no way to avoid stepping on each other.  You must ensure that there is only **one** instance of Spack running at a time.  Otherwise, Spack may end up with a corrupted database file, or you may not be able to see all installed packages in commands like ``spack find``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1168
# ba70a6baf04941e5ac7e161bc2452976
msgid "If you are unfortunate enough to run into this situation, you may be able to fix it by running ``spack reindex``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1171
# ffa17f6be9e84bfcafc3ec8731dce219
msgid "This issue typically manifests with the error below:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1195
# 17ff122581ba442c82e7623599de7482
msgid "A nicer error message is TBD in future versions of Spack."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1200
# 73ff4e1592bf45f09990363b0e2abf57
msgid "Getting Help"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1206
# 964091ad9c9c4f3585d8d9d3b70a43e6
msgid "``spack help``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1208
# 4ef4b36e74174629a64451f0bd4e7e46
msgid "If you don't find what you need here, the ``help`` subcommand will print out out a list of *all* of spack's options and subcommands:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1213
# 9503c773a88a4994866b5d5d0a7f221f
msgid "Adding an argument, e.g. ``spack help <subcommand>``, will print out usage information for a particular subcommand:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1218
# 2e954843ee4c407dbafdb7b85e2c04f4
msgid "Alternately, you can use ``spack --help`` in place of ``spack help``, or ``spack <subcommand> --help`` to get help on a particular subcommand."
msgstr ""

