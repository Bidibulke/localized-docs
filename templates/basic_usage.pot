# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 08:25-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/basic_usage.rst:10
# 71cce3791edd4b4c955b2ea777e0b02f
msgid "Basic Usage"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:12
# eae07fa312cd4884ad007bfe5230215e
msgid "The ``spack`` command has many *subcommands*.  You'll only need a small subset of them for typical usage."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:15
# 415a29a1c43b401999164d6475327aa1
msgid "Note that Spack colorizes output.  ``less -R`` should be used with Spack to maintain this colorization.  E.g.:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:22
# c560ef5684fe42789adad9712c78d282
msgid "It is recommended that the following be put in your ``.bashrc`` file:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:30
# de7683dec9e7441a9f05f357b065d1c3
msgid "Listing available packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:32
# d03f76c223b24400a17dd990a13e61d4
msgid "To install software with Spack, you need to know what software is available.  You can see a list of available package names at the :ref:`package-list` webpage, or using the ``spack list`` command."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:40
# c78cdcc5e45944698269892d4f149e4f
msgid "``spack list``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:42
# 23930a18cb644028bf3acbf0ed37afde
msgid "The ``spack list`` command prints out a list of all of the packages Spack can install:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:47
# 4f010e83f6224110829ae9bf98c14444
msgid "The packages are listed by name in alphabetical order. A pattern to match with no wildcards, ``*`` or ``?``, will be treated as though it started and ended with ``*``, so ``util`` is equivalent to ``*util*``.  All patterns will be treated as case-insensitive. You can also add the ``-d`` to search the description of the package in addition to the name.  Some examples:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:54
# 859389995c4942d8b62c8e0c155a64a3
msgid "All packages whose names contain \"sql\":"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:58
# b1d0782d8d4648e6a9d8d497d63a8b7f
msgid "All packages whose names or descriptions contain documentation:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:66
# 90d59f712bbe4c99b8153115590198f4
msgid "``spack info``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:68
# e8982ebe7b9a47e79b782f5ae3375e0e
msgid "To get more information on a particular package from `spack list`, use `spack info`.  Just supply the name of a package:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:73
# 12b961dcc62d432e9c31b200bc12d002
msgid "Most of the information is self-explanatory.  The *safe versions* are versions that Spack knows the checksum for, and it will use the checksum to verify that these versions download without errors or viruses."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:78
# a0705969040c45ddb671054d59198873
msgid ":ref:`Dependencies <sec-specs>` and :ref:`virtual dependencies <sec-virtual-dependencies>` are described in more detail later."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:85
# aa23ca084caa4c2b8d611845be97ca65
msgid "``spack versions``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:87
# 5a31c1b4fbb6473f8841df50b5232b1a
msgid "To see *more* available versions of a package, run ``spack versions``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:92
# f3fa83ae42794dcaa0640e6f661ed68e
msgid "There are two sections in the output.  *Safe versions* are versions for which Spack has a checksum on file.  It can verify that these versions are downloaded correctly."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:96
# 7224e264c8064b18bbe88c22ea0dc812
msgid "In many cases, Spack can also show you what versions are available out on the web---these are *remote versions*.  Spack gets this information by scraping it directly from package web pages.  Depending on the package and how its releases are organized, Spack may or may not be able to find remote versions."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:104
# 9d6aca657eef4496a4532912c9ddd37b
msgid "Installing and uninstalling"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:110
# bb34ae2ef867472397400de802092c47
msgid "``spack install``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:112
# 2f39d18a4d9f4265aeec29dcbf641874
msgid "``spack install`` will install any package shown by ``spack list``. For example, To install the latest version of the ``mpileaks`` package, you might type this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:120
# 6f9e065b45f0401085c6806298630021
msgid "If ``mpileaks`` depends on other packages, Spack will install the dependencies first.  It then fetches the ``mpileaks`` tarball, expands it, verifies that it was downloaded without errors, builds it, and installs it in its own directory under ``$SPACK_ROOT/opt``. You'll see a number of messages from spack, a lot of build output, and a message that the packages is installed:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:147
# c41739f0d2474deaa4fb75fb3972e198
msgid "The last line, with the ``[+]``, indicates where the package is installed."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:152
# b8a39a58b7b649998916d94df51b9d19
msgid "Building a specific version"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:154
# f51eab25830d46beb995afad82bdd8ec
msgid "Spack can also build *specific versions* of a package.  To do this, just add ``@`` after the package name, followed by a version:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:161
# 312580b58ad845d7851cc7f138d6293e
msgid "Any number of versions of the same package can be installed at once without interfering with each other.  This is good for multi-user sites, as installing a version that one user needs will not disrupt existing installations for other users."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:166
# 8ebd1267a61041c4a2ae22b0e777dc52
msgid "In addition to different versions, Spack can customize the compiler, compile-time options (variants), compiler flags, and platform (for cross compiles) of an installation.  Spack is unique in that it can also configure the *dependencies* a package is built with.  For example, two configurations of the same version of a package, one built with boost 1.39.0, and the other version built with version 1.43.0, can coexist."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:173
# 145c865f90b84e898d3f05ffead5832f
msgid "This can all be done on the command line using the *spec* syntax. Spack calls the descriptor used to refer to a particular package configuration a **spec**.  In the commands above, ``mpileaks`` and ``mpileaks@3.0.4`` are both valid *specs*.  We'll talk more about how you can use them to customize an installation in :ref:`sec-specs`."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:183
# ca8430130ea44e429725bc510906501e
msgid "``spack uninstall``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:185
# 5f19e356a6994d118bf03ee8725bc69f
msgid "To uninstall a package, type ``spack uninstall <package>``.  This will ask the user for confirmation before completely removing the directory in which the package was installed."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:193
# 1ed103f073384e1787d6151ec7ef3dec
msgid "If there are still installed packages that depend on the package to be uninstalled, spack will refuse to uninstall it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:196
# 0cacaa6d6deb49528069e472ac28a718
msgid "To uninstall a package and every package that depends on it, you may give the ``--dependents`` option."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:203
# 912e7f7a40fd4e0582796d0e52c97403
msgid "will display a list of all the packages that depend on ``mpich`` and, upon confirmation, will uninstall them in the right order."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:206
# c88227e71d58435aa51f46bb3779a1c0
msgid "A command like"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:212
# 5a168bbb83c64fc89d9dbcd2ed34f53b
msgid "may be ambiguous if multiple ``mpich`` configurations are installed. For example, if both ``mpich@3.0.2`` and ``mpich@3.1`` are installed, ``mpich`` could refer to either one. Because it cannot determine which one to uninstall, Spack will ask you either to provide a version number to remove the ambiguity or use the ``--all`` option to uninstall all of the matching packages."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:219
# 5d8fb1e664d54f5cba4b83bb97f6dbc4
msgid "You may force uninstall a package with the ``--force`` option"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:225
# 9f862e24cc1244afa87b1b6bd62fe215
msgid "but you risk breaking other installed packages. In general, it is safer to remove dependent packages *before* removing their dependencies or use the ``--dependents`` option."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:234
# 0ea0c8fd6da04230be3f94235d3ad55d
msgid "Non-Downloadable Tarballs"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:236
# efdb80c0541a40b18451a98f439426de
msgid "The tarballs for some packages cannot be automatically downloaded by Spack.  This could be for a number of reasons:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:239
# 65c0498e13b34ce7a322b9fb0bb69cf5
msgid "The author requires users to manually accept a license agreement before downloading (``jdk`` and ``galahad``)."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:242
# bd1c9347539f4cc099f9eb08c7df74df
msgid "The software is proprietary and cannot be downloaded on the open Internet."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:245
# 93e0e76758504d2fb295c0c757c2d132
msgid "To install these packages, one must create a mirror and manually add the tarballs in question to it (see :ref:`mirrors`):"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:248
# 8bd4c8e8976e4d3ca80fcdd9a5d09df1
msgid "Create a directory for the mirror.  You can create this directory anywhere you like, it does not have to be inside ``~/.spack``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:255
# 4d340fe4c6084b0bad7e11caf950ebf6
msgid "Register the mirror with Spack by creating ``~/.spack/mirrors.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:262
# 32f50d4e14404584b53eaf361199c5e6
msgid "Put your tarballs in it.  Tarballs should be named ``<package>/<package>-<version>.tar.gz``.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:271
# f6b9a73dd8864ec0a5dc77733467e225
msgid "Install as usual:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:279
# cc032b3122874bdda028efcd0c5fdf60
msgid "Seeing installed packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:281
# 86ad6a06e48c489d92f5ab2dfbe7ca0c
msgid "We know that ``spack list`` shows you the names of available packages, but how do you figure out which are already installed?"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:288
# 91448c4006e34ea7aaf4a43889e40bda
msgid "``spack find``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:290
# a9efe37db13b43b997df2f9ff27ca349
msgid "``spack find`` shows the *specs* of installed packages.  A spec is like a name, but it has a version, compiler, architecture, and build options associated with it.  In spack, you can have many installations of the same package with different specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:295
# 7b7115afbe16412abfbc8abdf03aeb2d
msgid "Running ``spack find`` with no arguments lists installed packages:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:330
# 207382d210ec43febefd550a7e796931
msgid "Packages are divided into groups according to their architecture and compiler.  Within each group, Spack tries to keep the view simple, and only shows the version of installed packages."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:334
# c3b15cbc9cd6451d92acd89d857693f3
msgid "``spack find`` can filter the package list based on the package name, spec, or a number of properties of their installation status.  For example, missing dependencies of a spec can be shown with ``--missing``, packages which were explicitly installed with ``spack install <package>`` can be singled out with ``--explicit`` and those which have been pulled in only as dependencies with ``--implicit``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:341
# b1f82d6aebee4044b2bf93b52449d875
msgid "In some cases, there may be different configurations of the *same* version of a package installed.  For example, there are two installations of ``libdwarf@20130729`` above.  We can look at them in more detail using ``spack find --deps``, and by asking only to show ``libdwarf`` packages:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:357
# e0fa9997f12a468eaa16eb0edea50296
msgid "Now we see that the two instances of ``libdwarf`` depend on *different* versions of ``libelf``: 0.8.12 and 0.8.13.  This view can become complicated for packages with many dependencies.  If you just want to know whether two packages' dependencies differ, you can use ``spack find --long``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:370
# 636d3e41c6b840018c34a6f3d3c0f1ac
msgid "Now the ``libdwarf`` installs have hashes after their names.  These are hashes over all of the dependencies of each package.  If the hashes are the same, then the packages have the same dependency configuration."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:374
# 1fedfe37b8aa416ba2fa92652160f038
msgid "If you want to know the path where each package is installed, you can use ``spack find --paths``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:391
# 29544459b5134ee6a020b57b3bf86ff7
msgid "And, finally, you can restrict your search to a particular package by supplying its name:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:402
# 39a436f8dbbd451ba67a8a720b6ddbdd
msgid "``spack find`` actually does a lot more than this.  You can use *specs* to query for specific configurations and builds of each package. If you want to find only libelf versions greater than version 0.8.12, you could say:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:413
# 9ebf566357b34c4391c28bc3026d16b2
msgid "Finding just the versions of libdwarf built with a particular version of libelf would look like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:423
# 8471cc14df354fc3b92e6e8be0a45486
msgid "We can also search for packages that have a certain attribute. For example, ``spack find libdwarf +debug`` will show only installations of libdwarf with the 'debug' compile-time option enabled."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:427
# 5b6f47f8017040b892273b9f0d6f3164
msgid "The full spec syntax is discussed in detail in :ref:`sec-specs`."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:433
# 430f1c6394c645d2a0885a83ca70296f
msgid "Specs & dependencies"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:435
# adf776573ff54a2ca6d66f27111d6d6d
msgid "We know that ``spack install``, ``spack uninstall``, and other commands take a package name with an optional version specifier.  In Spack, that descriptor is called a *spec*.  Spack uses specs to refer to a particular build configuration (or configurations) of a package. Specs are more than a package name and a version; you can use them to specify the compiler, compiler version, architecture, compile options, and dependency options for a build.  In this section, we'll go over the full syntax of specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:444
# fe10141324ef447a94e615d38c1bfab5
msgid "Here is an example of a much longer spec than we've seen thus far:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:450
# d8209bb35eed4832a962dbcee2f0678a
msgid "If provided to ``spack install``, this will install the ``mpileaks`` library at some version between ``1.2`` and ``1.4`` (inclusive), built using ``gcc`` at version 4.7.5 for the Blue Gene/Q architecture, with debug options enabled, and without Qt support.  Additionally, it says to link it with the ``callpath`` library (which it depends on), and to build callpath with ``gcc`` 4.7.2.  Most specs will not be as complicated as this one, but this is a good example of what is possible with specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:459
# 829481ad63f24be6a2418db7b2ac7ac2
msgid "More formally, a spec consists of the following pieces:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:461
# b965cee0cd1a46c38311940025e05775
msgid "Package name identifier (``mpileaks`` above)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:462
# d9cd1b3edb8141428bc7f980750665b3
msgid "``@`` Optional version specifier (``@1.2:1.4``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:463
# 8baafd14c6db4856a22d7458319d45c0
msgid "``%`` Optional compiler specifier, with an optional compiler version (``gcc`` or ``gcc@4.7.3``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:465
# 819c240d64af478e8dba660dbdab4bc1
msgid "``+`` or ``-`` or ``~`` Optional variant specifiers (``+debug``, ``-qt``, or ``~qt``) for boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:467
# 87084728817d44ba86bc676f712a8f17
msgid "``name=<value>`` Optional variant specifiers that are not restricted to boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:469
# 50a6aa2e26fc463aa76be6b782c840e8
msgid "``name=<value>`` Optional compiler flag specifiers. Valid flag names are ``cflags``, ``cxxflags``, ``fflags``, ``cppflags``, ``ldflags``, and ``ldlibs``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:471
# 29d33ea2552144dabd9f4d47fac8060c
msgid "``target=<value> os=<value>`` Optional architecture specifier (``target=haswell os=CNL10``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:473
# 0a136cd3adfe461da40e68822b8622b5
msgid "``^`` Dependency specs (``^callpath@1.1``)"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:475
# b9ee5141862d4459ae7b2297d389bba1
msgid "There are two things to notice here.  The first is that specs are recursively defined.  That is, each dependency after ``^`` is a spec itself.  The second is that everything is optional *except* for the initial package name identifier.  Users can be as vague or as specific as they want about the details of building packages, and this makes spack good for beginners and experts alike."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:482
# b11c95eacb114c3d9116ea9f50ea11b6
msgid "To really understand what's going on above, we need to think about how software is structured.  An executable or a library (these are generally the artifacts produced by building software) depends on other libraries in order to run.  We can represent the relationship between a package and its dependencies as a graph.  Here is the full dependency graph for ``mpileaks``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:499
# 5144508fc6fd471b80cd274656cd8ce5
msgid "Each box above is a package and each arrow represents a dependency on some other package.  For example, we say that the package ``mpileaks`` *depends on* ``callpath`` and ``mpich``.  ``mpileaks`` also depends *indirectly* on ``dyninst``, ``libdwarf``, and ``libelf``, in that these libraries are dependencies of ``callpath``.  To install ``mpileaks``, Spack has to build all of these packages.  Dependency graphs in Spack have to be acyclic, and the *depends on* relationship is directional, so this is a *directed, acyclic graph* or *DAG*."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:508
# a6f0b011a3094297aa09dce16a3e61a0
msgid "The package name identifier in the spec is the root of some dependency DAG, and the DAG itself is implicit.  Spack knows the precise dependencies among packages, but users do not need to know the full DAG structure. Each ``^`` in the full spec refers to some dependency of the root package. Spack will raise an error if you supply a name after ``^`` that the root does not actually depend on (e.g. ``mpileaks ^emacs@23.3``)."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:516
# 7168e001e67040f3841a624fd06d1ca7
msgid "Spack further simplifies things by only allowing one configuration of each package within any single build.  Above, both ``mpileaks`` and ``callpath`` depend on ``mpich``, but ``mpich`` appears only once in the DAG.  You cannot build an ``mpileaks`` version that depends on one version of ``mpich`` *and* on a ``callpath`` version that depends on some *other* version of ``mpich``.  In general, such a configuration would likely behave unexpectedly at runtime, and Spack enforces this to ensure a consistent runtime environment."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:525
# 1f9c5670c2ff43e2aa00734c05c84dc6
msgid "The point of specs is to abstract this full DAG from Spack users.  If a user does not care about the DAG at all, she can refer to mpileaks by simply writing ``mpileaks``.  If she knows that ``mpileaks`` indirectly uses ``dyninst`` and she wants a particular version of ``dyninst``, then she can refer to ``mpileaks ^dyninst@8.1``.  Spack will fill in the rest when it parses the spec; the user only needs to know package names and minimal details about their relationship."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:533
# b714f481c34d4ff8b34d6a47221d6679
msgid "When spack prints out specs, it sorts package names alphabetically to normalize the way they are displayed, but users do not need to worry about this when they write specs.  The only restriction on the order of dependencies within a spec is that they appear *after* the root package.  For example, these two specs represent exactly the same configuration:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:545
# 08e8c5bec435456aa4aea16957d1c9e2
msgid "You can put all the same modifiers on dependency specs that you would put on the root spec.  That is, you can specify their versions, compilers, variants, and architectures just like any other spec. Specifiers are associated with the nearest package name to their left. For example, above, ``@1.1`` and ``%gcc@4.7.2`` associates with the ``callpath`` package, while ``@1.2:1.4``, ``%gcc@4.7.5``, ``+debug``, ``-qt``, and ``target=haswell os=CNL10`` all associate with the ``mpileaks`` package."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:553
# 7327da1b8a394720b10e58cbf4935884
msgid "In the diagram above, ``mpileaks`` depends on ``mpich`` with an unspecified version, but packages can depend on other packages with *constraints* by adding more specifiers.  For example, ``mpileaks`` could depend on ``mpich@1.2:`` if it can only build with version ``1.2`` or higher of ``mpich``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:559
# 3d1201e09e7e47bdaae635c7d2af58c6
msgid "Below are more details about the specifiers that you can add to specs."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:563
# 76d4887b1c7e481ab7892556861ec174
msgid "Version specifier"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:565
# ddad6526a8cd4c5a9afd6242391e3fa1
msgid "A version specifier comes somewhere after a package name and starts with ``@``.  It can be a single version, e.g. ``@1.0``, ``@3``, or ``@1.2a7``.  Or, it can be a range of versions, such as ``@1.0:1.5`` (all versions between ``1.0`` and ``1.5``, inclusive).  Version ranges can be open, e.g. ``:3`` means any version up to and including ``3``. This would include ``3.4`` and ``3.4.2``.  ``4.2:`` means any version above and including ``4.2``.  Finally, a version specifier can be a set of arbitrary versions, such as ``@1.0,1.5,1.7`` (``1.0``, ``1.5``, or ``1.7``).  When you supply such a specifier to ``spack install``, it constrains the set of versions that Spack will install."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:576
# 44a47118139e4f3b8d8630481c655a48
msgid "If the version spec is not provided, then Spack will choose one according to policies set for the particular spack installation.  If the spec is ambiguous, i.e. it could match multiple versions, Spack will choose a version within the spec's constraints according to policies set for the particular Spack installation."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:582
# 8d8534473dd049c5b33bc4d2b0cc0ff5
msgid "Details about how versions are compared and how Spack determines if one version is less than another are discussed in the developer guide."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:587
# e0162174e32e4a91b5d761a28c70f747
msgid "Compiler specifier"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:589
# 5638f26889d14393840b11ad19cb78d7
msgid "A compiler specifier comes somewhere after a package name and starts with ``%``.  It tells Spack what compiler(s) a particular package should be built with.  After the ``%`` should come the name of some registered Spack compiler.  This might include ``gcc``, or ``intel``, but the specific compilers available depend on the site.  You can run ``spack compilers`` to get a list; more on this below."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:596
# 6b0222e9aa1e4ee29845d8345d30864a
msgid "The compiler spec can be followed by an optional *compiler version*. A compiler version specifier looks exactly like a package version specifier.  Version specifiers will associate with the nearest package name or compiler specifier to their left in the spec."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:601
# 306225d111a94fa9a505980c27003cd6
msgid "If the compiler spec is omitted, Spack will choose a default compiler based on site policies."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:609
# a3fccb6b000d44ba87cad47d01616910
msgid "Variants"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:611
# 3f7f5dca9aa14269af220a5d8806187e
msgid "Variants are named options associated with a particular package. They are optional, as each package must provide default values for each variant it makes available. Variants can be specified using a flexible parameter syntax ``name=<value>``. For example, ``spack install libelf debug=True`` will install libelf build with debug flags. The names of particular variants available for a package depend on what was provided by the package author. ``spack info <package>`` will provide information on what build variants are available."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:620
# f91f4ed3b8af4d208b05e655bedd7654
msgid "For compatibility with earlier versions, variants which happen to be boolean in nature can be specified by a syntax that represents turning options on and off. For example, in the previous spec we could have supplied ``libelf +debug`` with the same effect of enabling the debug compile time option for the libelf package."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:626
# 8a5921cd0c034e9cb8bffada9570cbc3
msgid "Depending on the package a variant may have any default value.  For ``libelf`` here, ``debug`` is ``False`` by default, and we turned it on with ``debug=True`` or ``+debug``.  If a variant is ``True`` by default you can turn it off by either adding ``-name`` or ``~name`` to the spec."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:631
# 763b9ac08ac149faac19d80ac7bfed74
msgid "There are two syntaxes here because, depending on context, ``~`` and ``-`` may mean different things.  In most shells, the following will result in the shell performing home directory substitution:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:640
# fc58c579cdba4dec8ae737a8941c4c4a
msgid "If there is a user called ``debug``, the ``~`` will be incorrectly expanded.  In this situation, you would want to write ``libelf -debug``.  However, ``-`` can be ambiguous when included after a package name without spaces:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:650
# c98fd7f506a349bda530d12c4386d6a4
msgid "Spack allows the ``-`` character to be part of package names, so the above will be interpreted as a request for the ``mpileaks-debug`` package, not a request for ``mpileaks`` built without ``debug`` options.  In this scenario, you should write ``mpileaks~debug`` to avoid ambiguity."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:656
# 631b0b981d1c4ad696ae282f6d48d182
msgid "When spack normalizes specs, it prints them out with no spaces boolean variants using the backwards compatibility syntax and uses only ``~`` for disabled boolean variants.  The ``-`` and spaces on the command line are provided for convenience and legibility."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:663
# aa6b7d5f4f4446019c44a081221eebce
msgid "Compiler Flags"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:665
# 9129842bbeb841fd9c871a983e9d131a
msgid "Compiler flags are specified using the same syntax as non-boolean variants, but fulfill a different purpose. While the function of a variant is set by the package, compiler flags are used by the compiler wrappers to inject flags into the compile line of the build. Additionally, compiler flags are inherited by dependencies. ``spack install libdwarf cppflags=\"-g\"`` will install both libdwarf and libelf with the ``-g`` flag injected into their compile line."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:673
# cea6091a5d264cc0a812362490097cc0
msgid "Notice that the value of the compiler flags must be quoted if it contains any spaces. Any of ``cppflags=-O3``, ``cppflags=\"-O3\"``, ``cppflags='-O3'``, and ``cppflags=\"-O3 -fPIC\"`` are acceptable, but ``cppflags=-O3 -fPIC`` is not. Additionally, if the value of the compiler flags is not the last thing on the line, it must be followed by a space. The commmand ``spack install libelf cppflags=\"-O3\"%intel`` will be interpreted as an attempt to set ``cppflags=\"-O3%intel\"``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:681
# 781ef64262d645ef8dc0f2c4f58c350c
msgid "The six compiler flags are injected in the order of implicit make commands in GNU Autotools. If all flags are set, the order is ``$cppflags $cflags|$cxxflags $ldflags <command> $ldlibs`` for C and C++ and ``$fflags $cppflags $ldflags <command> $ldlibs`` for Fortran."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:688
# 578609c812474d9db5a960262f02512f
msgid "Compiler environment variables and additional RPATHs"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:690
# 2204e3c6fcbc4d4b8089f270e03756fc
msgid "In the exceptional case a compiler requires setting special environment variables, like an explicit library load path. These can bet set in an extra section in the compiler configuration (the supported environment modification commands are: ``set``, ``unset``, ``append-path``, and ``prepend-path``). The user can also specify additional ``RPATHs`` that the compiler will add to all executables generated by that compiler.  This is useful for forcing certain compilers to RPATH their own runtime libraries, so that executables will run without the need to set ``LD_LIBRARY_PATH``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:726
# 1305a9483d8244eb8a4c91181e25d6ff
msgid "The section `environment` is interpreted as an ordered dictionary, which means two things. First, environment modification are applied in the order they are specified in the configuration file. Second, you cannot express environment modifications that require mixing different commands, i.e. you cannot `set` one variable, than `prepend-path` to another one, and than again `set` a third one."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:735
# 65f9a1bf2c8d47cab9a06b392187ccfb
msgid "Architecture specifiers"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:737
# 45408d19cb444ce397842b07c3d2b3a4
msgid "The architecture can be specified by using the reserved words ``target`` and/or ``os`` (``target=x86-64 os=debian7``). You can also use the triplet form of platform, operating system and processor."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:745
# 81e3f6e5e6f24bff9078284a56826d3f
msgid "Users on non-Cray systems won't have to worry about specifying the architecture. Spack will autodetect what kind of operating system is on your machine as well as the processor. For more information on how the architecture can be used on Cray machines, see :ref:`cray-support`"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:754
# 924f554ddeee4bd3b5d5e80e0a977921
msgid "Virtual dependencies"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:756
# fdd0d9442b9447caa0aacf1579a75515
msgid "The dependence graph for ``mpileaks`` we saw above wasn't *quite* accurate.  ``mpileaks`` uses MPI, which is an interface that has many different implementations.  Above, we showed ``mpileaks`` and ``callpath`` depending on ``mpich``, which is one *particular* implementation of MPI.  However, we could build either with another implementation, such as ``openmpi`` or ``mvapich``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:763
# ea8deab0bceb4c6fa2eba64cae00d534
msgid "Spack represents interfaces like this using *virtual dependencies*. The real dependency DAG for ``mpileaks`` looks like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:777
# 68b0097fee6d4d028a8f8dba2fc943b8
msgid "Notice that ``mpich`` has now been replaced with ``mpi``. There is no *real* MPI package, but some packages *provide* the MPI interface, and these packages can be substituted in for ``mpi`` when ``mpileaks`` is built."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:782
# 822d4b21ff43437b92f754c8a21fe3d3
msgid "You can see what virtual packages a particular package provides by getting info on it:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:787
# c7f810bd0bd341f19bcedf42a56939cb
msgid "Spack is unique in that its virtual packages can be versioned, just like regular packages.  A particular version of a package may provide a particular version of a virtual package, and we can see above that ``mpich`` versions ``1`` and above provide all ``mpi`` interface versions up to ``1``, and ``mpich`` versions ``3`` and above provide ``mpi`` versions up to ``3``.  A package can *depend on* a particular version of a virtual package, e.g. if an application needs MPI-2 functions, it can depend on ``mpi@2:`` to indicate that it needs some implementation that provides MPI-2 functions."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:799
# ad5116a43e5947c6b72dee7f2bfb6119
msgid "Constraining virtual packages"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:801
# 24dc05a17b7c49189838310c415e3b4c
msgid "When installing a package that depends on a virtual package, you can opt to specify the particular provider you want to use, or you can let Spack pick.  For example, if you just type this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:809
# 6bd1f11de51b4e95a330350c4a4e906f
msgid "Then spack will pick a provider for you according to site policies. If you really want a particular version, say ``mpich``, then you could run this instead:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:817
# 18565c6f567a4832b18627c0bb1ae405
msgid "This forces spack to use some version of ``mpich`` for its implementation.  As always, you can be even more specific and require a particular ``mpich`` version:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:825
# 4ce77b79189e4af99509d928122642e0
msgid "The ``mpileaks`` package in particular only needs MPI-1 commands, so any MPI implementation will do.  If another package depends on ``mpi@2`` and you try to give it an insufficient MPI implementation (e.g., one that provides only ``mpi@:1``), then Spack will raise an error.  Likewise, if you try to plug in some package that doesn't provide MPI, Spack will raise an error."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:834
# 021e7def23184c2b992846cd81d507fb
msgid "Specifying Specs by Hash"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:836
# af9158a478ca4d84aa7c0f060567f493
msgid "Complicated specs can become cumbersome to enter on the command line, especially when many of the qualifications are necessary to distinguish between similar installs. To avoid this, when referencing an existing spec, Spack allows you to reference specs by their hash. We previously discussed the spec hash that Spack computes. In place of a spec in any command, substitute ``/<hash>`` where ``<hash>`` is any amount from the beginning of a spec hash."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:844
# ef4395ff6f7f435e8bc69b50ca530411
msgid "For example, lets say that you accidentally installed two different ``mvapich2`` installations. If you want to uninstall one of them but don't know what the difference is, you can run:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:857
# 1876e738f9ca483c825a52edb952bde8
msgid "You can then uninstall the latter installation using:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:864
# 2ca91571d58e42c1b05ceb8f06b2b624
msgid "Or, if you want to build with a specific installation as a dependency, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:872
# 21b910b91b264ea3a382905873fd97d6
msgid "If the given spec hash is sufficiently long as to be unique, Spack will replace the reference with the spec to which it refers. Otherwise, it will prompt for a more qualified hash."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:876
# c900d110f5494b5aa0218c31af81c84c
msgid "Note that this will not work to reinstall a dependency uninstalled by ``spack uninstall --force``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:883
# ae27006a2c10447cb3e49528b55e6542
msgid "``spack providers``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:885
# 7459780828164de98741261bb144f58c
msgid "You can see what packages provide a particular virtual package using ``spack providers``.  If you wanted to see what packages provide ``mpi``, you would just run:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:891
# 2c910bb9d8cf4211adda95aca2803f27
msgid "And if you *only* wanted to see packages that provide MPI-2, you would add a version specifier to the spec:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:896
# acdf81b5688643b7bc24ce45622a913c
msgid "Notice that the package versions that provide insufficient MPI versions are now filtered out."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:901
# 17449d6ede47428f8b75a19650f9f410
msgid "Extensions & Python support"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:903
# 9a7b5d7daa2e4daf916bcd46e4cee44e
msgid "Spack's installation model assumes that each package will live in its own install prefix.  However, certain packages are typically installed *within* the directory hierarchy of other packages.  For example, modules in interpreted languages like `Python <https://www.python.org>`_ are typically installed in the ``$prefix/lib/python-2.7/site-packages`` directory."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:910
# 9a16c96a1f884453894cfe94dbd00936
msgid "Spack has support for this type of installation as well.  In Spack, a package that can live inside the prefix of another package is called an *extension*.  Suppose you have Python installed like so:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:925
# 91c955f318d1449e9802bcc5bfea1a3e
msgid "``spack extensions``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:927
# 2debd76e558e4583a779b096ae93b9d9
msgid "You can find extensions for your Python installation like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:952
# 7078be192a0b4bdd8b10fac3ea2112e0
msgid "The extensions are a subset of what's returned by ``spack list``, and they are packages like any other.  They are installed into their own prefixes, and you can see this with ``spack find --paths``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:963
# 5073c0423ca948f08c24fa6e5c2003a8
msgid "However, even though this package is installed, you cannot use it directly when you run ``python``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:981
# 780405ad21cb4e638c2d227194c94383
msgid "Using Extensions"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:983
# f0394e0077224c9f859fb92958922b18
msgid "There are three ways to get ``numpy`` working in Python.  The first is to use :ref:`shell-support`.  You can simply ``use`` or ``load`` the module for the extension, and it will be added to the ``PYTHONPATH`` in your current shell."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:988
# a849e5a61d0d4af1898df60c294ac7d2
msgid "For tcl modules:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:995
# a4b7fcaef6c1479ba589645c33ff497e
msgid "or, for dotkit:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1002
# 1ac78bb4bb5f4aada37d76bc81c0d620
msgid "Now ``import numpy`` will succeed for as long as you keep your current session open."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1007
# 0c323c0d10e14374a6d155ead6991acf
msgid "Activating Extensions in a View"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1009
# 05690df89cc74fe1bbdfecc3c1d1cdaa
msgid "The second way to use extensions is to create a view, which merges the python installation along with the extensions into a single prefix. See :ref:`filesystem-views` for a more in-depth description of views and :ref:`cmd-spack-view` for usage of the ``spack view`` command."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1016
# 717c840c152147948ff0ec3c37b65919
msgid "Activating Extensions Globally"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1018
# 13f24e990fcc4b2e9504c5a85ce790aa
msgid "As an alternative to creating a merged prefix with Python and its extensions, and prior to support for views, Spack has provided a means to install the extension into the Spack installation prefix for the extendee. This has typically been useful since extendable packages typically search their own installation path for addons by default."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1024
# 92b674d07168405896e30cc402d8de4f
msgid "Global activations are performed with the ``spack activate`` command:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1030
# c81ea55e77c24ce19160c424c125d9ec
msgid "``spack activate``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1039
# 339fbe0450014eae993b74f96ae56d77
msgid "Several things have happened here.  The user requested that ``py-numpy`` be activated in the ``python`` installation it was built with.  Spack knows that ``py-numpy`` depends on ``py-nose`` and ``py-setuptools``, so it activated those packages first.  Finally, once all dependencies were activated in the ``python`` installation, ``py-numpy`` was activated as well."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1046
# e5bbabff12b9490095b2a4f1a0a9635b
msgid "If we run ``spack extensions`` again, we now see the three new packages listed as activated:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1074
# 5ca9d94651c24652810b34048b1e4346
msgid "Now, when a user runs python, ``numpy`` will be available for import *without* the user having to explicitly loaded.  ``python@2.7.8`` now acts like a system Python installation with ``numpy`` installed inside of it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1079
# e59d2f375f5b41f2b486e053f0f39cfd
msgid "Spack accomplishes this by symbolically linking the *entire* prefix of the ``py-numpy`` into the prefix of the ``python`` package.  To the python interpreter, it looks like ``numpy`` is installed in the ``site-packages`` directory."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1084
# 5aba686b6b204ab9b4d8f3f07c1e1cd4
msgid "The only limitation of global activation is that you can only have a *single* version of an extension activated at a time.  This is because multiple versions of the same extension would conflict if symbolically linked into the same prefix.  Users who want a different version of a package can still get it by using environment modules or views, but they will have to explicitly load their preferred version."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1093
# b005a05503f843bdac4b403e7dc361a2
msgid "``spack activate --force``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1095
# dfb0ec26017b4c0cb5f066a05a8eed84
msgid "If, for some reason, you want to activate a package *without* its dependencies, you can use ``spack activate --force``:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1107
# 1cba95161a4c4f87a5d7b33986a46ba7
msgid "``spack deactivate``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1109
# d6028d701cae4a3ebc09eb77f449b364
msgid "We've seen how activating an extension can be used to set up a default version of a Python module.  Obviously, you may want to change that at some point.  ``spack deactivate`` is the command for this.  There are several variants:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1114
# 15725fe243f3413eb0407b4ccaa6d47f
msgid "``spack deactivate <extension>`` will deactivate a single extension.  If another activated extension depends on this one, Spack will warn you and exit with an error."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1117
# a4fdff1999fe412c81741730686a457b
msgid "``spack deactivate --force <extension>`` deactivates an extension regardless of packages that depend on it."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1119
# f15684e7371d4db6b497137793ed5334
msgid "``spack deactivate --all <extension>`` deactivates an extension and all of its dependencies.  Use ``--force`` to disregard dependents."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1121
# e1af5a091769459b9ca8bab848708e1d
msgid "``spack deactivate --all <extendee>`` deactivates *all* activated extensions of a package.  For example, to deactivate *all* python extensions, use:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1131
# bbdbf099908d4b27b51387d285a970a6
msgid "Filesystem requirements"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1133
# 92c1aa1d10414f0199b21da5d5a259ee
msgid "By default, Spack needs to be run from a filesystem that supports ``flock`` locking semantics.  Nearly all local filesystems and recent versions of NFS support this, but parallel filesystems or NFS volumes may be configured without ``flock`` support enabled.  You can determine how your filesystems are mounted with ``mount``.  The output for a Lustre filesystem might look like this:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1146
# 8761ba2547ac4195a448246750437201
msgid "Note the ``flock`` option on both Lustre mounts."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1148
# f352388d410f4a0686298bd3ed0ecbcd
msgid "If you do not see this or a similar option for your filesystem, you have a few options. First, you can move your Spack installation to a filesystem that supports locking. Second, you could ask your system administrator to enable ``flock`` for your filesystem."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1153
# 453e751401b7473c8fb458f498fdb3ff
msgid "If none of those work, you can disable locking in one of two ways:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1155
# 3a50e8ce790a42dba9575f7eb5f6eb58
msgid "Run Spack with the ``-L`` or ``--disable-locks`` option to disable locks on a call-by-call basis."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1157
# aa45be19e8854681884090fa09f7030a
msgid "Edit :ref:`config.yaml <config-yaml>` and set the ``locks`` option to ``false`` to always disable locking."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1162
# 421486797632431eb1816021a554bdde
msgid "If you disable locking, concurrent instances of Spack will have no way to avoid stepping on each other.  You must ensure that there is only **one** instance of Spack running at a time.  Otherwise, Spack may end up with a corrupted database file, or you may not be able to see all installed packages in commands like ``spack find``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1168
# dbe3e0bcb7664ad498937bc44db4982c
msgid "If you are unfortunate enough to run into this situation, you may be able to fix it by running ``spack reindex``."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1171
# 4ee6bc22ce66421d85cbfc2b79094e9e
msgid "This issue typically manifests with the error below:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1195
# 4a2cebf56ac14bfbad96caa41d6a65d0
msgid "A nicer error message is TBD in future versions of Spack."
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1200
# 577a1c019bac4327b588fe9b91bb01eb
msgid "Getting Help"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1206
# 7003d239799b4a15b69322bb55e87e8c
msgid "``spack help``"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1208
# 37548d77c01d46d6a365ec829e4789dc
msgid "If you don't find what you need here, the ``help`` subcommand will print out out a list of *all* of spack's options and subcommands:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1213
# 6188da40f4694892bbbb5cdca5dba62a
msgid "Adding an argument, e.g. ``spack help <subcommand>``, will print out usage information for a particular subcommand:"
msgstr ""

#: ../spack/lib/spack/docs/basic_usage.rst:1218
# d5618e99228348c5815d811200594948
msgid "Alternately, you can use ``spack --help`` in place of ``spack help``, or ``spack <subcommand> --help`` to get help on a particular subcommand."
msgstr ""

