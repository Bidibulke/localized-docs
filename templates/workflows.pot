# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 08:25-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/workflows.rst:8
# 6c5552581c1647aba9cf2d3c8309f743
msgid "Workflows"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:10
# 0385adceee494b8892c06e909ac8f13d
msgid "The process of using Spack involves building packages, running binaries from those packages, and developing software that depends on those packages.  For example, one might use Spack to build the ``netcdf`` package, use ``spack load`` to run the ``ncdump`` binary, and finally, write a small C program to read/write a particular NetCDF file."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:16
# 36dd390924154111aa4a216b6ae4be0a
msgid "Spack supports a variety of workflows to suit a variety of situations and user preferences, there is no single way to do all these things. This chapter demonstrates different workflows that have been developed, pointing out the pros and cons of them."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:23
# d466fa68ff3a48c7a2a30fba0f61e1ee
msgid "Definitions"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:25
# beb79b9429d140d6a4f5a4deca9879fd
msgid "First some basic definitions."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:29
# cab3fbec5d3348ecadcd5cbf6146c995
msgid "Package, Concrete Spec, Installed Package"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:31
# 9c809203505b426ea5698b5f9bc09228
msgid "In Spack, a package is an abstract recipe to build one piece of software. Spack packages may be used to build, in principle, any version of that software with any set of variants.  Examples of packages include ``curl`` and ``zlib``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:36
# 1c0befb6b2524ea1907c1a8ff6c2c8ac
msgid "A package may be *instantiated* to produce a concrete spec; one possible realization of a particular package, out of combinatorially many other realizations.  For example, here is a concrete spec instantiated from ``curl``:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:43
# 70d9faac12094d68a56e3ab0c03056cd
msgid "Spack's core concretization algorithm generates concrete specs by instantiating packages from its repo, based on a set of \"hints\", including user input and the ``packages.yaml`` file.  This algorithm may be accessed at any time with the ``spack spec`` command."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:48
# f5b89e4a005140c59853ad4eb4410071
msgid "Every time Spack installs a package, that installation corresponds to a concrete spec.  Only a vanishingly small fraction of possible concrete specs will be installed at any one Spack site."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:54
# bd1985f67f644ad5b93891764e158af0
msgid "Consistent Sets"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:56
# 4fecaa482eac4e2aaefe9021a1b5bef3
msgid "A set of Spack specs is said to be *consistent* if each package is only instantiated one way within it --- that is, if two specs in the set have the same package, then they must also have the same version, variant, compiler, etc.  For example, the following set is consistent:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:68
# 62b053ee7be447269b84c982fb3ab6f9
msgid "The following set is not consistent:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:77
# 973283a7e0b840dcbfd7ec6e9c4008be
msgid "The compatibility of a set of installed packages determines what may be done with it.  It is always possible to ``spack load`` any set of installed packages, whether or not they are consistent, and run their binaries from the command line.  However, a set of installed packages can only be linked together in one binary if it is consistent."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:83
# a8074a527ab446adb37f4ed150411c2f
msgid "If the user produces a series of ``spack spec`` or ``spack load`` commands, in general there is no guarantee of consistency between them.  Spack's concretization procedure guarantees that the results of any *single* ``spack spec`` call will be consistent.  Therefore, the best way to ensure a consistent set of specs is to create a Spack package with dependencies, and then instantiate that package.  We will use this technique below."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:93
# 68fb15a6901a4d258f4425c3bff7ac0e
msgid "Building Packages"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:95
# 83779ad3767d4f1ea1be57f9f7bcda4f
msgid "Suppose you are tasked with installing a set of software packages on a system in order to support one application -- both a core application program, plus software to prepare input and analyze output.  The required software might be summed up as a series of ``spack install`` commands placed in a script.  If needed, this script can always be run again in the future.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:112
# 01fca3b4f2244c5e82ce3d5d077d001c
msgid "In most cases, this script will not correctly install software according to your specific needs: choices need to be made for variants, versions and virtual dependency choices may be needed.  It *is* possible to specify these choices by extending specs on the command line; however, the same choices must be specified repeatedly. For example, if you wish to use ``openmpi`` to satisfy the ``mpi`` dependency, then ``^openmpi`` will have to appear on *every* ``spack install`` line that uses MPI.  It can get repetitive fast."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:121
# 7fd9e93554094e06a78d52bb63f9e1da
msgid "Customizing Spack installation options is easier to do in the ``~/.spack/packages.yaml`` file.  In this file, you can specify preferred versions and variants to use for packages.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:148
# a758fb1de5d94b73ba59ad3a635d860b
msgid "This approach will work as long as you are building packages for just one application."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:153
# 62cc6bb9cd6a48f2b3f08f0a2c47525c
msgid "Multiple Applications"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:155
# 3cea01b04a1a498ca7f2d3662d8c2b42
msgid "Suppose instead you're building multiple inconsistent applications. For example, users want package A to be built with ``openmpi`` and package B with ``mpich`` --- but still share many other lower-level dependencies.  In this case, a single ``packages.yaml`` file will not work.  Plans are to implement *per-project* ``packages.yaml`` files. In the meantime, one could write shell scripts to switch ``packages.yaml`` between multiple versions as needed, using symlinks."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:165
# e19ea0914dd34e3badd2e6d7b07e83d1
msgid "Combinatorial Sets of Installs"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:167
# 85b54ac24b9b4daa86f96f360042db3f
msgid "Suppose that you are now tasked with systematically building many incompatible versions of packages.  For example, you need to build ``petsc`` 9 times for 3 different MPI implementations on 3 different compilers, in order to support user needs.  In this case, you will need to either create 9 different ``packages.yaml`` files; or more likely, create 9 different ``spack install`` command lines with the correct options in the spec.  Here is a real-life example of this kind of usage:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:215
# 7a0cb7f048914165b4b72ccbb9ca77d2
msgid "Running Binaries from Packages"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:217
# 559cf6fc56c54ef08b75ff7d3c5c336c
msgid "Once Spack packages have been built, the next step is to use them.  As with building packages, there are many ways to use them, depending on the use case."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:223
# 9d56964c91634f7fae629e2a2e03142d
msgid "Find and Run"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:225
# 1227f3a976e2409d95d9ce4fd1ed790a
msgid "The simplest way to run a Spack binary is to find it and run it! In many cases, nothing more is needed because Spack builds binaries with RPATHs.  Spack installation directories may be found with ``spack location --install-dir`` commands.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:235
# e71880db7d8a4c45a81156324844ac25
msgid "This gives the root of the Spack package; relevant binaries may be found within it.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:243
# f39bc598f7ba46f0a853d4b2815f2724
msgid "Standard UNIX tools can find binaries as well.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:250
# b5ced3a38f944c1386b7c1da257e8fdc
msgid "These methods are suitable, for example, for setting up build processes or GUIs that need to know the location of particular tools. However, other more powerful methods are generally preferred for user environments."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:258
# c8154b163f644a29b0a1aa0ff4dfb075
msgid "Spack-Generated Modules"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:260
# 74c3b4d832634ffba68dc25de43900d3
msgid "Suppose that Spack has been used to install a set of command-line programs, which users now wish to use.  One can in principle put a number of ``spack load`` commands into ``.bashrc``, for example, to load a set of Spack-generated modules:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:273
# c8d601d5b05e487fbed14b3303296f0d
msgid "Although simple load scripts like this are useful in many cases, they have some drawbacks:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:276
# ad9479ce1a0740b88d823df3c1818629
msgid "The set of modules loaded by them will in general not be consistent.  They are a decent way to load commands to be called from command shells.  See below for better ways to assemble a consistent set of packages for building application programs."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:281
# ca37782b59374b97a2c46d9bf207e24d
msgid "The ``spack spec`` and ``spack install`` commands use a sophisticated concretization algorithm that chooses the \"best\" among several options, taking into account ``packages.yaml`` file. The ``spack load`` and ``spack module tcl loads`` commands, on the other hand, are not very smart: if the user-supplied spec matches more than one installed package, then ``spack module tcl loads`` will fail. This may change in the future.  For now, the workaround is to be more specific on any ``spack module tcl loads`` lines that fail."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:293
# fd498a5ef4b74e28a1cdad1cad4fd55b
msgid "Generated Load Scripts"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:295
# 498593de0d354733ac40ca62750c2c02
msgid "Another problem with using `spack load` is, it is slow; a typical user environment could take several seconds to load, and would not be appropriate to put into ``.bashrc`` directly.  It is preferable to use a series of ``spack module tcl loads`` commands to pre-compute which modules to load.  These can be put in a script that is run whenever installed Spack packages change.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:318
# 643e4347dd2545eaa35a71e51f221ce9
msgid "The output of this file is written in ``~/env/spackenv``:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:347
# 15b6d84fa4bc4a9e850822fc4089792e
msgid "Users may now put ``source ~/env/spackenv`` into ``.bashrc``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:351
# 8d3afc7fa33e48e7ab69d8cfc2f0aedc
msgid "Some module systems put a prefix on the names of modules created by Spack.  For example, that prefix is ``linux-SuSE11-x86_64/`` in the above case.  If a prefix is not needed, you may omit the ``--prefix`` flag from ``spack module tcl loads``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:359
# 8e10c9242a1a4840bde3b8c414a0c09e
msgid "Transitive Dependencies"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:361
# d2df44dc9da54cbf897326b17395d5c5
msgid "In the script above, each ``spack module tcl loads`` command generates a *single* ``module load`` line.  Transitive dependencies do not usually need to be loaded, only modules the user needs in ``$PATH``.  This is because Spack builds binaries with RPATH.  Spack's RPATH policy has some nice features:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:367
# 72accf04de45459f9e1b2e192ec20d76
msgid "Modules for multiple inconsistent applications may be loaded simultaneously.  In the above example (Multiple Applications), package A and package B can coexist together in the user's $PATH, even though they use different MPIs."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:372
# 61ade3db128d40a38540a3933cb45483
msgid "RPATH eliminates a whole class of strange errors that can happen in non-RPATH binaries when the wrong ``LD_LIBRARY_PATH`` is loaded."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:376
# c75cfa14eeef486cb193a677e50b4454
msgid "Recursive module systems such as LMod are not necessary."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:378
# 65afa11a7cbc47408089e3ad475a7576
msgid "Modules are not needed at all to execute binaries.  If a path to a binary is known, it may be executed.  For example, the path for a Spack-built compiler can be given to an IDE without requiring the IDE to load that compiler's module."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:383
# 63f38541854840358f16681c6cece2b0
msgid "Unfortunately, Spack's RPATH support does not work in all case.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:385
# c581f26502b64a7db5f6ab08529f27b7
msgid "Software comes in many forms --- not just compiled ELF binaries, but also as interpreted code in Python, R, JVM bytecode, etc. Those systems almost universally use an environment variable analogous to ``LD_LIBRARY_PATH`` to dynamically load libraries."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:390
# fd5035dca42a46b3b93825b1320989b9
msgid "Although Spack generally builds binaries with RPATH, it does not currently do so for compiled Python extensions (for example, ``py-numpy``).  Any libraries that these extensions depend on (``blas`` in this case, for example) must be specified in the ``LD_LIBRARY_PATH``.`"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:396
# 4bde5b2ddbdd4427a95a89de5173966e
msgid "In some cases, Spack-generated binaries end up without a functional RPATH for no discernible reason."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:399
# 11e3bad7bd534bcc9a6159c52d170721
msgid "In cases where RPATH support doesn't make things \"just work,\" it can be necessary to load a module's dependencies as well as the module itself.  This is done by adding the ``--dependencies`` flag to the ``spack module tcl loads`` command.  For example, the following line, added to the script above, would be used to load SciPy, along with Numpy, core Python, BLAS/LAPACK and anything else needed:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:412
# dd114b4046a340a084381933c848ac0a
msgid "Dummy Packages"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:414
# 2b0dac78cf7f497594f1527ff2d8ac91
msgid "As an alternative to a series of ``module load`` commands, one might consider dummy packages as a way to create a *consistent* set of packages that may be loaded as one unit.  The idea here is pretty simple:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:419
# 2b6833d3ab794a7b88afbd2c8c5a0819
msgid "Create a package (say, ``mydummy``) with no URL and no ``install()`` method, just dependencies."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:422
# d8adb9f6019245e9891e84cd7e7756cc
msgid "Run ``spack install mydummy`` to install."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:424
# e1c7bf93d31f46efb5344b8e2c1344d1
msgid "An advantage of this method is the set of packages produced will be consistent.  This means that you can reliably build software against it.  A disadvantage is the set of packages will be consistent; this means you cannot load up two applications this way if they are not consistent with each other."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:434
# b5a55b35185c499cb771e790ede080bc
msgid "Filesystem Views"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:436
# 7c691299e268403cb0a8fc47d65d5fdf
msgid "Filesystem views offer an alternative to environment modules, another way to assemble packages in a useful way and load them into a user's environment."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:440
# 50aa76b375d747c09ef346e1cb3417c1
msgid "A single-prefix filesystem view is a single directory tree that is the union of the directory hierarchies of a number of installed packages; it is similar to the directory hiearchy that might exist under ``/usr/local``.  The files of the view's installed packages are brought into the view by symbolic or hard links, referencing the original Spack installation."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:447
# 57ba6a0f4407498d9fbd563450ca6ec9
msgid "A combinatorial filesystem view can contain more software than a single-prefix view. Combinatorial filesystem views are created by defining a projection for each spec or set of specs. The syntax for this will be discussed in the section for the ``spack view`` command under `adding_projections_to_views`_."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:453
# e71bc4430d884439af3407902801c311
msgid "The projection for a spec or set of specs specifies the naming scheme for the directory structure under the root of the view into which the package will be linked. For example, the spec ``zlib@1.2.8%gcc@4.4.7`` could be projected to ``MYVIEW/zlib-1.2.8-gcc``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:458
# aa136d7871a941db8f697a1ad3bcb3cb
msgid "When software is built and installed, absolute paths are frequently \"baked into\" the software, making it non-relocatable.  This happens not just in RPATHs, but also in shebangs, configuration files, and assorted other locations."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:463
# 7181097ec97f4a6686ce35154a92a39d
msgid "Therefore, programs run out of a Spack view will typically still look in the original Spack-installed location for shared libraries and other resources.  This behavior is not easily changed; in general, there is no way to know where absolute paths might be written into an installed package, and how to relocate it.  Therefore, the original Spack tree must be kept in place for a filesystem view to work, even if the view is built with hardlinks."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:477
# e6715256cba0477d9db7646950ab0b6e
msgid "``spack view``"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:479
# 53f71c64de2b4bada00ca984135ba0a9
msgid "A filesystem view is created, and packages are linked in, by the ``spack view`` command's ``symlink`` and ``hardlink`` sub-commands.  The ``spack view remove`` command can be used to unlink some or all of the filesystem view."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:484
# 48f23bca79284ac19315053de2478a72
msgid "The following example creates a filesystem view based on an installed ``cmake`` package and then removes from the view the files in the ``cmake`` package while retaining its dependencies."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:512
# 9c734d7ebaf84174b0cc8192ff688689
msgid "If the set of packages being included in a view is inconsistent, then it is possible that two packages will provide the same file.  Any conflicts of this type are handled on a first-come-first-served basis, and a warning is printed."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:519
# 889442ff571b40eab98e6e725461af4d
msgid "When packages are removed from a view, empty directories are purged."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:526
# b707088ac39a4df6b882a99c2c12383c
msgid "Controlling View Projections"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:528
# 7476557cdd9d45778cdc68672b2180ba
msgid "The default projection into a view is to link every package into the root of the view. This can be changed by adding a ``projections.yaml`` configuration file to the view. The projection configuration file for a view located at ``/my/view`` is stored in ``/my/view/.spack/projections.yaml``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:534
# fb3f2e8a5052477f865279c318771aba
msgid "When creating a view, the projection configuration file can also be specified from the command line using the ``--projection-file`` option to the ``spack view`` command."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:538
# 63ed2c7f191d43cb9b6543263fb97660
msgid "The projections configuration file is a mapping of partial specs to spec format strings, as shown in the example below."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:548
# 5cf1f967e10c46f088d5e763338bd023
msgid "The entries in the projections configuration file must all be either specs or the keyword ``all``. For each spec, the projection used will be the first non-``all`` entry that the spec satisfies, or ``all`` if there is an entry for ``all`` and no other entry is satisfied by the spec. Where the keyword ``all`` appears in the file does not matter. Given the example above, any spec satisfying ``zlib@1.2.8`` will be linked into ``/my/view/zlib-1.2.8/``, any spec satisfying ``hdf5@1.8.10+mpi %gcc@4.9.3 ^mvapich2@2.2`` will be linked into ``/my/view/hdf5-1.8.10/mvapich2-2.2-gcc-4.9.3``, and any spec satisfying ``hdf5@1.8.10~mpi %gcc@4.9.3`` will be linked into ``/my/view/hdf5-1.8.10/gcc-4.9.3``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:560
# d13abdc1c840405bb47ebe66609aa8bc
msgid "If the keyword ``all`` does not appear in the projections configuration file, any spec that does not satisfy any entry in the file will be linked into the root of the view as in a single-prefix view. Any entries that appear below the keyword ``all`` in the projections configuration file will not be used, as all specs will use the projection under ``all`` before reaching those entries."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:569
# bb63b7f2545b4dc3a88ed9d8d1d10a2f
msgid "Fine-Grain Control"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:571
# c33085bdda55479f803619184b88b349
msgid "The ``--exclude`` and ``--dependencies`` option flags allow for fine-grained control over which packages and dependencies do or not get included in a view.  For example, suppose you are developing the ``appsy`` package.  You wish to build against a view of all ``appsy`` dependencies, but not ``appsy`` itself:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:581
# f8257a5afbdc4866aba095b5b5d2ce87
msgid "Alternately, you wish to create a view whose purpose is to provide binary executables to end users.  You only need to include applications they might want, and not those applications' dependencies.  In this case, you might use:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:593
# d5dd7193cd3c40dfb45a3f7d6d7cffd3
msgid "Hybrid Filesystem Views"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:595
# 717574f6e5074f598bed8c0d66b96d0f
msgid "Although filesystem views are usually created by Spack, users are free to add to them by other means.  For example, imagine a filesystem view, created by Spack, that looks something like:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:604
# f0a063395c71467cb3bde8b257c282a4
msgid "Now, the user may add to this view by non-Spack means; for example, by running a classic install script.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:615
# 5ab976dbf7fe4fcca374b5e5dd0ac806
msgid "The result is a hybrid view:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:624
# 7e321eeaf1a94fa8b284e6ef7a625459
msgid "In this case, real files coexist, interleaved with the \"view\" symlinks.  At any time one can delete ``/path/to/MYVIEW`` or use ``spack view`` to manage it surgically.  None of this will affect the real Spack install area."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:631
# 227a43af64de423f931c9edf52911a6a
msgid "Global Activations"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:633
# 041fa6f51c3345c08d91fa12c0903c21
msgid ":ref:`cmd-spack-activate` may be used as an alternative to loading Python (and similar systems) packages directly or creating a view. If extensions are globally activated, then ``spack load python`` will also load all the extensions activated for the given ``python``. This reduces the need for users to load a large number of modules."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:639
# d96f17c08357450299f63f2f505031bf
msgid "However, Spack global activations have two potential drawbacks:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:641
# be6b2a61cc914b2fa5c84cc9846b6a9a
msgid "Activated packages that involve compiled C extensions may still need their dependencies to be loaded manually.  For example, ``spack load openblas`` might be required to make ``py-numpy`` work."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:646
# b2d66dc460f84973af180e1173aa7fba
msgid "Global activations \"break\" a core feature of Spack, which is that multiple versions of a package can co-exist side-by-side.  For example, suppose you wish to run a Python package in two different environments but the same basic Python --- one with ``py-numpy@1.7`` and one with ``py-numpy@1.8``.  Spack extensions will not support this potential debugging use case."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:655
# 314ae63d4c8c4f8aaa352cf385929fa1
msgid "Discussion: Running Binaries"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:657
# 7273771ab0c3400a851efbbfa78c942c
msgid "Modules, extension packages and filesystem views are all ways to assemble sets of Spack packages into a useful environment.  They are all semantically similar, in that conflicting installed packages cannot simultaneously be loaded, activated or included in a view."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:662
# 1f5c151b061e4dcb90fb5395ffd533e0
msgid "With all of these approaches, there is no guarantee that the environment created will be consistent.  It is possible, for example, to simultaneously load application A that uses OpenMPI and application B that uses MPICH.  Both applications will run just fine in this inconsistent environment because they rely on RPATHs, not the environment, to find their dependencies."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:669
# 7c1a44aa185d4bff83951a7ff3e828ad
msgid "In general, environments set up using modules vs. views will work similarly.  Both can be used to set up ephemeral or long-lived testing/development environments.  Operational differences between the two approaches can make one or the other preferable in certain environments:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:675
# ad5abf42b99c4e9cac29feb4449acff9
msgid "Filesystem views do not require environment module infrastructure. Although Spack can install ``environment-modules``, users might be hostile to its use.  Filesystem views offer a good solution for sysadmins serving users who just \"want all the stuff I need in one place\" and don't want to hear about Spack."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:681
# db323dc842624f98a6d3f45df4fe25f4
msgid "Although modern build systems will find dependencies wherever they might be, some applications with hand-built make files expect their dependencies to be in one place.  One common problem is makefiles that assume that ``netcdf`` and ``netcdf-fortran`` are installed in the same tree.  Or, one might use an IDE that requires tedious configuration of dependency paths; and it's easier to automate that administration in a view-building script than in the IDE itself. For all these cases, a view will be preferable to other ways to assemble an environment."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:691
# 90c1cec8bf7f47e4a48301a53049c7df
msgid "On systems with I-node quotas, modules might be preferable to views and extension packages."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:694
# 6fc069a6d383401a854fe81cf4784e87
msgid "Views and activated extensions maintain state that is semantically equivalent to the information in a ``spack module tcl loads`` script. Administrators might find things easier to maintain without the added \"heavyweight\" state of a view."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:701
# 65b0b4d9edf74bd9b1b11814f407ffb4
msgid "Developing Software with Spack"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:703
# 20fa289da31841cbac85666934855d59
msgid "For any project, one needs to assemble an environment of that application's dependencies.  You might consider loading a series of modules or creating a filesystem view.  This approach, while obvious, has some serious drawbacks:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:708
# 68f53766665a4e46810ddc9a67cf5e81
msgid "There is no guarantee that an environment created this way will be consistent.  Your application could end up with dependency A expecting one version of MPI, and dependency B expecting another. The linker will not be happy..."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:713
# cdea45d56cf74d669ea314644eb50889
msgid "Suppose you need to debug a package deep within your software DAG. If you build that package with a manual environment, then it becomes difficult to have Spack auto-build things that depend on it.  That could be a serious problem, depending on how deep the package in question is in your dependency DAG."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:719
# 799ef42b77ca4c498c0ee87b731b263e
msgid "At its core, Spack is a sophisticated concretization algorithm that matches up packages with appropriate dependencies and creates a *consistent* environment for the package it's building.  Writing a list of ``spack load`` commands for your dependencies is at least as hard as writing the same list of ``depends_on()`` declarations in a Spack package.  But it makes no use of Spack concretization and is more error-prone."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:727
# c9ff8a9811ed4611838acd386bb6baed
msgid "Spack provides an automated, systematic way not just to find a packages's dependencies --- but also to build other packages on top.  Any Spack package can become a dependency for another Spack package, offering a powerful vision of software re-use.  If you build your package A outside of Spack, then your ability to use it as a building block for other packages in an automated way is diminished: other packages depending on package A will not be able to use Spack to fulfill that dependency."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:736
# 64b203aeebc74eb780787168cd746260
msgid "If you are reading this manual, you probably love Spack.  You're probably going to write a Spack package for your software so prospective users can install it with the least amount of pain. Why should you go to additional work to find dependencies in your development environment?  Shouldn't Spack be able to help you build your software based on the package you've already written?"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:743
# fca1b3f1e45d4f829314c8a07074796a
msgid "In this section, we show how Spack can be used in the software development process to greatest effect, and how development packages can be seamlessly integrated into the Spack ecosystem.  We will show how this process works by example, assuming the software you are creating is called ``mylib``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:751
# 67b4aea41d8e4fcea4795bd5896b579c
msgid "Write the CMake Build"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:753
# 5104b749b23a43b0b345072173672021
msgid "For now, the techniques in this section only work for CMake-based projects, although they could be easily extended to other build systems in the future.  We will therefore assume you are using CMake to build your project."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:758
# e6c975f6e0f245c1a53e6de3a7bfc32e
msgid "The ``CMakeLists.txt`` file should be written as normal.  A few caveats:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:760
# 6143cc58b3504c7086e1d01861360ccc
msgid "Your project should produce binaries with RPATHs.  This will ensure that they work the same whether built manually or automatically by Spack.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:792
# 5898d8e82ac24ae883a8ae19a53fcce9
msgid "Spack provides a CMake variable called ``SPACK_TRANSITIVE_INCLUDE_PATH``, which contains the ``include/`` directory for all of your project's transitive dependencies.  It can be useful if your project ``#include``s files from package B, which ``#include`` files from package C, but your project only lists project B as a dependency.  This works in traditional single-tree build environments, in which B and C's include files live in the same place.  In order to make it work with Spack as well, you must add the following to ``CMakeLists.txt``.  It will have no effect when building without Spack:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:811
# a83f23b2ee34467dbc2f76fc1050bcf3
msgid "Note that this feature is controversial and could break with future versions of GNU ld.  The best practice is to make sure anything you ``#include`` is listed as a dependency in your CMakeLists.txt (and Spack package)."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:820
# 2cf75247aa234a1490eab19640d29df7
msgid "Write the Spack Package"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:822
# 984e67b372ee4e62a725915b3326bd3e
msgid "The Spack package also needs to be written, in tandem with setting up the build (for example, CMake).  The most important part of this task is declaring dependencies.  Here is an example of the Spack package for the ``mylib`` package (ellipses for brevity):"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:861
# 3c1db14d93544d629e50633e8490b477
msgid "This is a standard Spack package that can be used to install ``mylib`` in a production environment.  The list of dependencies in the Spack package will generally be a repeat of the list of CMake dependencies.  This package also has some features that allow it to be used for development:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:867
# 95bc3860f6b6483eb3e2ecc553385190
msgid "It subclasses ``CMakePackage`` instead of ``Package``.  This eliminates the need to write an ``install()`` method, which is defined in the superclass.  Instead, one just needs to write the ``configure_args()`` method.  That method should return the arguments needed for the ``cmake`` command (beyond the standard CMake arguments, which Spack will include already).  These arguments are typically used to turn features on/off in the build."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:875
# a079b08447d14df18425454ba1612c3a
msgid "It specifies a non-checksummed version ``develop``.  Running ``spack install mylib@develop`` the ``@develop`` version will install the latest version off the develop branch.  This method of download is useful for the developer of a project while it is in active development; however, it should only be used by developers who control and trust the repository in question!"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:882
# c353bb44ec6545cebc351a1b291b97a7
msgid "The ``url``, ``url_for_version()`` and ``homepage`` attributes are not used in development.  Don't worry if you don't have any, or if they are behind a firewall."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:888
# f5480dde31a445adaa7b5be015d38954
msgid "Build with Spack"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:890
# f930d2d7229647fb9c78027fe0169e7b
msgid "Now that you have a Spack package, you can use Spack to find its dependencies automatically.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:898
# dd2bfc5edd7f45c2aa53cf1c96938661
msgid "The result will be a file ``spconfig.py`` in the top-level ``mylib/`` directory.  It is a short script that calls CMake with the dependencies and options determined by Spack --- similar to what happens in ``spack install``, but now written out in script form. From a developer's point of view, you can think of ``spconfig.py`` as a stand-in for the ``cmake`` command."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:907
# 6429a2163c8446f4affeee9f4f147cbc
msgid "You can invent any \"version\" you like for the ``spack setup`` command."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:912
# 11a4530e39a842e28fc6fe27fd93f9d8
msgid "Although ``spack setup`` does not build your package, it does create and install a module file, and mark in the database that your package has been installed.  This can lead to errors, of course, if you don't subsequently install your package. Also... you will need to ``spack uninstall`` before you run ``spack setup`` again."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:920
# 97f3a802ea2e4e4e92809c2d1768066b
msgid "You can now build your project as usual with CMake:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:929
# 295b9f71e623491faae011ad48b1a2e5
msgid "Once your ``make install`` command is complete, your package will be installed, just as if you'd run ``spack install``.  Except you can now edit, re-build and re-install as often as needed, without checking into Git or downloading tarballs."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:936
# a8ad4eed0a694a02957192a5a22e2f31
msgid "The build you get this way will be *almost* the same as the build from ``spack install``.  The only difference is, you will not be using Spack's compiler wrappers.  This difference has not caused problems in our experience, as long as your project sets RPATHs as shown above.  You DO use RPATHs, right?"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:944
# c2969d7ac8ac43a7a117dad91c0af491
msgid "Build Other Software"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:946
# 51be97e148f14dc5a5c9b90cfa1ba1e2
msgid "Now that you've built ``mylib`` with Spack, you might want to build another package that depends on it --- for example, ``myapp``.  This is accomplished easily enough:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:954
# f95cb75221794af58f931f0e7b705650
msgid "Note that auto-built software has now been installed *on top of* manually-built software, without breaking Spack's \"web.\"  This property is useful if you need to debug a package deep in the dependency hierarchy of your application.  It is a *big* advantage of using ``spack setup`` to build your package's environment."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:960
# 725ea7f5c8da4aba8bad934833d05bef
msgid "If you feel your software is stable, you might wish to install it with ``spack install`` and skip the source directory.  You can just use, for example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:972
# 2cd25867059940289b85d791d3656851
msgid "Release Your Software"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:974
# 0863b28fc12e4e61b5d564d8e77de911
msgid "You are now ready to release your software as a tarball with a numbered version, and a Spack package that can build it.  If you're hosted on GitHub, this process will be a bit easier."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:978
# ecec038cb1dd4a6da5b3de1ba1b3ec4f
msgid "Put tag(s) on the version(s) in your GitHub repo you want to be release versions.  For example, a tag ``v0.1.0`` for version 0.1.0."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:981
# eb9c426468d34a5c99bea755a935dc2d
msgid "Set the ``url`` in your ``package.py`` to download a tarball for the appropriate version.  GitHub will give you a tarball for any commit in the repo, if you tickle it the right way.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:989
# 18f9695a82a24900b4d6817b1c770618
msgid "Use Spack to determine your version's hash, and cut'n'paste it into your ``package.py``:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1005
# 542ac9c32301425182162e11d6e2e64f
msgid "You should now be able to install released version 0.1.2 of your package with:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1011
# b4cdd4f764584bb697d0c5af187b9e71
msgid "There is no need to remove the `develop` version from your package. Spack concretization will always prefer numbered version to non-numeric versions.  Users will only get it if they ask for it."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1017
# b9d45829d59d4231bbdb8ade1b9cc710
msgid "Distribute Your Software"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1019
# f8e1ab1633f94142a7fbe9555cecf7e0
msgid "Once you've released your software, other people will want to build it; and you will need to tell them how.  In the past, that has meant a few paragraphs of prose explaining which dependencies to install.  But now you use Spack, and those instructions are written in executable Python code.  But your software has many dependencies, and you know Spack is the best way to install it:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1026
# 6a8dc1cd33d64c2f9f188a8abbc542fb
msgid "First, you will want to fork Spack's ``develop`` branch.  Your aim is to provide a stable version of Spack that you KNOW will install your software.  If you make changes to Spack in the process, you will want to submit pull requests to Spack core."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1031
# d89fa15bcb3a43f49337a192a45ea103
msgid "Add your software's ``package.py`` to that fork.  You should submit a pull request for this as well, unless you don't want the public to know about your software."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1035
# 40bdf4496eb646a09acbdb14e64aae2c
msgid "Prepare instructions that read approximately as follows:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1037
# 71d16501a74c4cbdb1b32d67edbfdf0d
msgid "Download Spack from your forked repo."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1039
# 7fef102d23e2495e83b32f6be6efb37a
msgid "Install Spack; see :ref:`getting_started`."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1041
# 782507320b9541978b08436e35eb4d1c
msgid "Set up an appropriate ``packages.yaml`` file.  You should tell your users to include in this file whatever versions/variants are needed to make your software work correctly (assuming those are not already in your ``packages.yaml``)."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1046
# 722e18758b664d3fbdcf1049608487da
msgid "Run ``spack install mylib``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1048
# 1209147affbf45f8893868d3494e66cc
msgid "Run this script to generate the ``module load`` commands or filesystem view needed to use this software."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1051
# 1bfabed38227482fb40b0b3959d24631
msgid "Be aware that your users might encounter unexpected bootstrapping issues on their machines, especially if they are running on older systems.  The :ref:`getting_started` section should cover this, but there could always be issues."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1058
# 12aa7d07cd934845af2fdca1d922f63c
msgid "Other Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1060
# 3dea5efd3bed4e2b803558d8a1d131cc
msgid "``spack setup`` currently only supports CMake-based builds, in packages that subclass ``CMakePackage``.  The intent is that this mechanism should support a wider range of build systems; for example, GNU Autotools.  Someone well-versed in Autotools is needed to develop this patch and test it out."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1066
# 7ab2a4bcf50349299d1991a771e6b99d
msgid "Python Distutils is another popular build system that should get ``spack setup`` support.  For non-compiled languages like Python, ``spack diy`` may be used.  Even better is to put the source directory directly in the user's ``PYTHONPATH``.  Then, edits in source files are immediately available to run without any install process at all!"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1074
# 354b645b9e464f3493a2d635e32bf45e
msgid "Conclusion"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1076
# dd7ce6a7766e41cba6d12efe8fb30e3e
msgid "The ``spack setup`` development workflow provides better automation, flexibility and safety than workflows relying on environment modules or filesystem views.  However, it has some drawbacks:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1080
# a789df67018c4871848227f46e4dabd9
msgid "It currently works only with projects that use the CMake build system.  Support for other build systems is not hard to build, but will require a small amount of effort for each build system to be supported.  It might not work well with some IDEs."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1085
# ab6640815f3b4aff9a2f8e4df4d7c235
msgid "It only works with packages that sub-class ``StagedPackage``. Currently, most Spack packages do not.  Converting them is not hard; but must be done on a package-by-package basis."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1089
# ae812dfc504141eaa7183314d354eb4c
msgid "It requires that users are comfortable with Spack, as they integrate Spack explicitly in their workflow.  Not all users are willing to do this."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1095
# 171dd52146614916b31e920c8c825db1
msgid "Using Spack on Travis-CI"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1097
# 9d4e106c12134a28ad2442702601f8d0
msgid "Spack can be deployed as a provider for userland software in `Travis-CI <https://http://travis-ci.org>`_."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1100
# 4a8916f2ce674af78ad38b6919661691
msgid "A starting-point for a ``.travis.yml`` file can look as follows. It uses `caching <https://docs.travis-ci.com/user/caching/>`_ for already built environments, so make sure to clean the Travis cache if you run into problems."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1105
# 701c4276c78a4399b205e8c5cb245b0e
msgid "The main points that are implemented below:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1107
# d9997b35994f4eec9a6be311367bf19f
msgid "Travis is detected as having up to 34 cores available, but only 2 are actually allocated for the user. We limit the parallelism of the spack builds in the config. (The Travis yaml parser is a bit buggy on the echo command.)"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1112
# ace286bca60e47be963c384e2058e49f
msgid "Builds over 10 minutes need to be prefixed with ``travis_wait``. Alternatively, generate output once with ``spack install -v``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1115
# f962dfbeb7b74961949952aa56754ce4
msgid "Travis builds are non-interactive. This prevents using bash aliases and functions for modules. We fix that by sourcing ``/etc/profile`` first (or running everything in a subshell with ``bash -l -c '...'``)."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1175
# 98b18ec146ad4ac0834f4f523eb9f11b
msgid "Using Spack to Create Docker Images"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1177
# 041a15c7213f49bd81f369edea84adef
msgid "Spack can be the ideal tool to set up images for Docker (and Singularity)."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1179
# 01c48b24ff384b2d9dbab1bcac604cc7
msgid "An example ``Dockerfile`` is given below, downloading the latest spack version."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1182
# c1c72427288b4d15914f411c02200aae
msgid "The following functionality is prepared:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1184
# 420687f4db834896aa0672d643429124
msgid "Base image: the example starts from a minimal ubuntu."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1186
# 9d381e4d9bce4e8d9337a825a6dc4483
msgid "Installing as root: docker images are usually set up as root. Since some autotools scripts might complain about this being unsafe, we set ``FORCE_UNSAFE_CONFIGURE=1`` to avoid configure errors."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1190
# d2f77aba25404f3293847e1883b7598b
msgid "Pre-install the spack dependencies, including modules from the packages. This avoids needing to build those from scratch via ``spack bootstrap``. Package installs are followed by a clean-up of the system package index, to avoid outdated information and it saves space."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1195
# 81f835fdb92446f4a713570ff285b00d
msgid "Install spack in ``/usr/local``. Add ``setup-env.sh`` to profile scripts, so commands in *login* shells can use the whole spack functionality, including modules."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1199
# 962c1a6f7ae94e96a97ab4556703065d
msgid "Install an example package (``tar``). As with system package managers above, ``spack install`` commands should be concatenated with a ``&& spack clean -a`` in order to keep image sizes small."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1203
# 8dd75f54833948ddbe9d85a7e19c608b
msgid "Add a startup hook to an *interactive login shell* so spack modules will be usable."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1206
# ddfc53e57d184473a5e7f41a8c1ec83d
msgid "In order to build and run the image, execute:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1267
# 42739bc18b2f4346bab3cea7237486c0
msgid "Best Practices"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1271
# 3b5d9a7600ce4fb882b0521ace0a075b
msgid "MPI"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1272
# e2a6bd1913b24690811cb42c7a6c5940
msgid "Due to the dependency on Fortran for OpenMPI, which is the spack default implementation, consider adding ``gfortran`` to the ``apt-get install`` list."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1275
# 966f630f188741c7bd2b6083f21069b1
msgid "Recent versions of OpenMPI will require you to pass ``--allow-run-as-root`` to your ``mpirun`` calls if started as root user inside Docker."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1278
# d5c6b4557ee14351abc9039f0dbcd5c8
msgid "For execution on HPC clusters, it can be helpful to import the docker image into Singularity in order to start a program with an *external* MPI. Otherwise, also add ``openssh-server`` to the ``apt-get install`` list."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1284
# 22bd36e60bcf4f39b8a163f5d113fde1
msgid "CUDA"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1285
# dabeb8764fe04e87883fa1dd7712ee3f
msgid "Starting from CUDA 9.0, Nvidia provides minimal CUDA images based on Ubuntu. Please see `their instructions <https://hub.docker.com/r/nvidia/cuda/>`_. Avoid double-installing CUDA by adding, e.g."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1298
# 6e5b4070d63542128ddb093f2e47a334
msgid "to your ``packages.yaml``. Then ``COPY`` in that file into the image as in the example above."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1301
# 387aeea87ae44b229385fa1787b7745c
msgid "Users will either need ``nvidia-docker`` or e.g. Singularity to *execute* device kernels."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1306
# d0fe37b0dba54b63b676edb39e02141e
msgid "Singularity"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1307
# 49af0fb510474047b337f8f359396a65
msgid "Importing and running the image created above into `Singularity <http://singularity.lbl.gov/>`_ works like a charm. Just use the `docker bootstraping mechanism <http://singularity.lbl.gov/quickstart#bootstrap-recipes>`_:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1321
# c8380628ab8b4e638e2473a701a2f87b
msgid "Docker for Development"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1323
# 1e23cc0dc0ad4e6b964f9c6ed8827e2c
msgid "For examples of how we use docker in development, see :ref:`docker_for_developers`."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1328
# d5acfc9d637b4008973262169deff171
msgid "Docker on Windows and OSX"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1330
# a7d9a67387a94b6482a7bbeaa16700c5
msgid "On Mac OS and Windows, docker runs on a hypervisor that is not allocated much memory by default, and some spack packages may fail to build due to lack of memory. To work around this issue, consider configuring your docker installation to use more of your host memory. In some cases, you can also ease the memory pressure on parallel builds by limiting the parallelism in your config.yaml."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1343
# 3b4a350749574e85881229cc6533dacd
msgid "Upstream Bug Fixes"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1345
# 7961022cdd284a36afe633999c858411
msgid "It is not uncommon to discover a bug in an upstream project while trying to build with Spack.  Typically, the bug is in a package that serves a dependency to something else.  This section describes procedure to work around and ultimately resolve these bugs, while not delaying the Spack user's main goal."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1353
# bb33632e2e6d4e3190cf39596972c4e3
msgid "Buggy New Version"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1355
# 28f8ecff92cf49a18a30f0b5031dcf7b
msgid "Sometimes, the old version of a package works fine, but a new version is buggy.  For example, it was once found that `Adios did not build with hdf5@1.10 <https://github.com/spack/spack/issues/1683>`_.  If the old version of ``hdf5`` will work with ``adios``, the suggested procedure is:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1361
# 79b3401da3114b0dad7f50ffe455343a
msgid "Revert ``adios`` to the old version of ``hdf5``.  Put in its ``adios/package.py``:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1370
# 41d5441710814b98b644b06ae83c6e66
msgid "Determine whether the problem is with ``hdf5`` or ``adios``, and report the problem to the appropriate upstream project.  In this case, the problem was with ``adios``."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1374
# e4ce560f0ff54d29a88134377e88b908
msgid "Once a new version of ``adios`` comes out with the bugfix, modify ``adios/package.py`` to reflect it:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1386
# a81a2ec3acd848f592e9d1b531afe52c
msgid "No Version Works"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1388
# 1a44fcb4cae742b39c6f765bcba76cb3
msgid "Sometimes, *no* existing versions of a dependency work for a build. This typically happens when developing a new project: only then does the developer notice that existing versions of a dependency are all buggy, or the non-buggy versions are all missing a critical feature."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1393
# d083a97c1fae4bb6839e76ddea2abe30
msgid "In the long run, the upstream project will hopefully fix the bug and release a new version.  But that could take a while, even if a bugfix has already been pushed to the project's repository.  In the meantime, the Spack user needs things to work."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1398
# 3f4cefd076c54261a799f6f9c428031c
msgid "The solution is to create an unofficial Spack release of the project, as soon as the bug is fixed in *some* repository.  A study of the `Git history <https://github.com/citibeth/spack/commits/efischer/develop/var/spack/repos/builtin/packages/py-proj/package.py>`_ of ``py-proj/package.py`` is instructive here:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1403
# fe870e1eb1a949d89608a97f71e49a39
msgid "On `April 1 <https://github.com/citibeth/spack/commit/44a1d6a96706affe6ef0a11c3a780b91d21d105a>`_, an initial bugfix was identified for the PyProj project and a pull request submitted to PyProj.  Because the upstream authors had not yet fixed the bug, the ``py-proj`` Spack package downloads from a forked repository, set up by the package's author. A non-numeric version number is used to make it easy to upgrade the package without recomputing checksums; however, this is an untrusted download method and should not be distributed.  The package author has now become, temporarily, a maintainer of the upstream project:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1422
# b46b1909389b4b96a54d77bd3f921455
msgid "By May 14, the upstream project had accepted a pull request with the required bugfix.  At this point, the forked repository was deleted.  However, the upstream project still had not released a new version with a bugfix.  Therefore, a Spack-only release was created by specifying the desired hash in the main project repository.  The version number ``@1.9.5.1.1`` was chosen for this \"release\" because it's a descendent of the officially released version ``@1.9.5.1``.  This is a trusted download method, and can be released to the Spack community:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1441
# f1902549cce746dca2a5e54b4d880d92
msgid "It would have been simpler to use Spack's Git download method, which is also a trusted download in this case:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1454
# 86f0408819b84d27aea23be984cd2134
msgid "In this case, the upstream project fixed the bug in its repository in a relatively timely manner.  If that had not been the case, the numbered version in this step could have been released from the forked repository."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1460
# 3d87f97e24c74fdb8b72cd69104a9bce
msgid "The author of the Spack package has now become an unofficial release engineer for the upstream project.  Depending on the situation, it may be advisable to put ``preferred=True`` on the latest *officially released* version."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1465
# 4febce0830db42b788a151978e6ac02f
msgid "As of August 31, the upstream project still had not made a new release with the bugfix.  In the meantime, Spack-built ``py-proj`` provides the bugfix needed by packages depending on it.  As long as this works, there is no particular need for the upstream project to make a new official release."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1471
# ad36df4518014f4aa21153b981adadae
msgid "If the upstream project releases a new official version with the bugfix, then the unofficial ``version()`` line should be removed from the Spack package."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1477
# 18c8ed473b6b44c2b81eead6a4bf5654
msgid "Patches"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1479
# b0120bb10548420fb135208603a35e5b
msgid "Spack's source patching mechanism provides another way to fix bugs in upstream projects.  This has advantages and disadvantages compared to the procedures above."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1482
# 8ebac954e9e14b62918fbb61f7ee0b34
msgid "Advantages:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1484
# 20f9e9590cef489b953c7914bf946d37
msgid "It can fix bugs in existing released versions, and (probably) future releases as well."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1487
# 380ceba32c5c4bebbcadd2610bf00f3e
msgid "It is lightweight, does not require a new fork to be set up."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1489
# 12ba82312d044c6285e235be4dde5458
msgid "Disadvantages:"
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1491
# 3a19c59316cb4b259768d5ec587c2b7c
msgid "It is harder to develop and debug a patch, vs. a branch in a repository.  The user loses the automation provided by version control systems."
msgstr ""

#: ../spack/lib/spack/docs/workflows.rst:1495
# 571eddae603e44dd9fe1758dd0fe7e5c
msgid "Although patches of a few lines work OK, large patch files can be hard to create and maintain."
msgstr ""

