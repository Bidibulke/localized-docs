# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 00:42-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/tutorial_modules.rst:10
# 694c2bedc8db4204b2f067cb02fcf475
msgid "Module Files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:12
# 567a1a82980441be9acf2fe176fb67e8
msgid "In this tutorial, we'll introduce a few concepts that are fundamental to the generation of module files with Spack, and we'll guide you through the customization of both module files content and their layout on disk. In the end you should have a clear understanding of:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:17
# 53c9506fdb7b496a89a3f6e11317ae94
msgid "What are module files and how they work"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:18
# dadfa9fb4ae14b74a7e4b9966d78444c
msgid "How Spack generates them"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:19
# ef163506840f43988a4db697226036f1
msgid "Which commands are available to ease their maintenance"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:20
# 582c9343408d48209c970c8385f7f403
msgid "How it is possible to customize them in all aspects"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:26
# 56bff18f526c4b60b56ff14bfd36dd06
msgid "Modules at a glance"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:28
# ac38391747ff48788dcb90fe3f46be33
msgid "Let's start by summarizing what module files are and how you can use them to modify your environment. The idea is to give enough information so that people without any previous exposure to them will be able to follow the tutorial later on. We'll also give a high-level view of how module files are generated in Spack. If you are already familiar with these topics you can quickly skim through this section or move directly to :ref:`module_file_tutorial_prerequisites`."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:39
# 6ca47d3c30534132bb1a56f852aa54ca
msgid "What are module files?"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:41
# 0ade89d2ce6642c0b8958cc3d9f7f9e9
msgid "Module files are an easy way to modify your environment in a controlled manner during a shell session. In general, they contain the information needed to run an application or use a library, and they work in conjunction with a tool that interprets them. Typical module files instruct this tool to modify the environment variables when a module file is loaded:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:69
# a3fc435f6eff43929662de66ebafb9f0
msgid "and to undo the modifications when the same module file is unloaded:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:78
# 9dea2022fcdd4153aabf3adb24bbe8c6
msgid "Different formats exist for module files, and different tools provide various levels of support for them. Spack can natively generate:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:81
# 46d5e3839fd644a0b7326b5e13913369
msgid "Non-hierarchical module files written in TCL"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:82
# 5cfe6d58b60a4904840977151c97b60e
msgid "Hierarchical module files written in Lua"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:84
# 56ab5b7af7704eb7a48002b53ef9cc1f
msgid "and can build `environment-modules <http://modules.sourceforge.net/>`_ and `lmod <http://lmod.readthedocs.io/en/latest>`_ as support tools. Which of the formats or tools best suits one's needs depends on each particular use-case. For the sake of illustration, we'll be working on both formats using ``lmod``."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:97
# 31e1036282274d79a48ded8154ef1cba
msgid "Environment modules"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:92
# 698ca95128494c69bc266cf88ce5595f
msgid "This is the original tool that provided modules support. Its first version was coded in C in the early '90s and was later substituted by a version completely coded in TCL - the one Spack is distributing. More details on its features are given in the `homepage of the project <http://modules.sourceforge.net/>`_ or in its `github page <https://github.com/cea-hpc/modules>`_. The tool is able to interpret the non-hierarchical TCL modulefiles written by Spack."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:106
# 7f94885745d144c4a08fbe83b427ad9a
msgid "Lmod"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:100
# 2e575d38bc7c49ccbfd1e3e631ea8abf
msgid "Lmod is a module system written in Lua, designed to easily handle hierarchies of module files. It's a drop-in replacement of Environment Modules and works with both of the module file formats generated by Spack. Despite being fully compatible with Environment Modules there are many features that are unique to Lmod. These features are either `targeted towards safety <http://lmod.readthedocs.io/en/latest/010_user.html#safety-features>`_ or meant to `extend the module system functionality <http://lmod.readthedocs.io/en/latest/010_user.html#module-hierarchy>`_."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:112
# 427b3508b0b5451b8e922ba5679d2b3e
msgid "How do we generate module files?"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:114
# 353c6f611a1d4d68bc1e527fd45208a3
msgid "Before  we dive into the hands-on sections it's worth spending a couple of words to explain how module files are generated by Spack. The following diagram provides a high-level view of the process:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:121
# 5d193ad1ec6746eab1621dc570427323
msgid "The red dashed line above represents Spack's boundaries, the blue one Spack's dependencies [#f1]_. Module files are generated by combining:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:124
# 8e3cbd0b2ece43558ed63d609e6e337c
msgid "the configuration details in ``config.yaml`` and ``modules.yaml``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:125
# 10e2a0db9cad4b40bea8278525128622
msgid "the information contained in Spack packages (and processed by the module subpackage)"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:126
# d5384645192746549c330f45b444a8db
msgid "a set of template files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:128
# fdb11844a3b54c188b30deb3111fdf15
msgid "with `Jinja2 <http://jinja.pocoo.org/docs/2.9/>`_, an external template engine that stamps out each particular module file. As Spack serves very diverse needs this process has many points of customization, and we'll explore most of them in the next sections."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:133
# 0effc3f4d5c243ee8dcbffc6b7903c70
msgid "Spack vendors its dependencies! This means that Spack comes with a copy of each one of its dependencies, including ``Jinja2``, and is already configured to use them."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:140
# badceb5e5da34632a089108b07f7a294
msgid "Setup for the tutorial"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:142
# cc175b3dbff646829d7e04e111d9ba58
msgid "In order to showcase the capabilities of Spack's module file generation, we need a representative set of software to work with. This set must include different flavors of the same packages installed alongside each other and some :ref:`external packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:147
# 8d468245fb4b4eaa975abb6180bca99d
msgid "The purpose of this setup is not to make our life harder but to demonstrate how Spack can help with similar situations, as they will happen on real HPC clusters. For instance, it's often preferable for Spack to use vendor-provided MPI implementations than to build one itself."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:152
# a042416fe15148f19f4b8616c4795c81
msgid "To keep the set of software we're dealing with manageable, we're going to uninstall everything from earlier in the tutorial."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:161
# c5b6f9d26bb2477780c408e2a0ade415
msgid "Build a module tool"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:163
# ddfb277f3cce406e885f15a492febd2a
msgid "The first thing that we need is the module tool. In this case we choose ``lmod`` as it can work with both hierarchical and non-hierarchical module file layouts."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:171
# 5c230b58ad5a4fbe9f76e2700a8cb8ee
msgid "Once the module tool is installed we need to have it available in the current shell. As the installation directories are definitely not easy to remember, we'll employ the command ``spack location`` to retrieve the ``lmod`` prefix directly from Spack:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:180
# 8a3731855d8a43b5ac4a4d9dd7ee25f0
msgid "Now we can re-source the setup file and Spack modules will be put in our module path."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:196
# b4f0837af86c455e9852fe581ff5ff78
msgid "Add a new compiler"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:198
# 0f98e9ffeb154546abaf5cee1fcc45d5
msgid "The second step is to build a recent compiler. On first use, Spack scans the environment and automatically locates the compiler(s) already available on the system. For this tutorial, however, we want to use ``gcc@7.2.0``."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:211
# aff6c4348c58479da4e51a969168a3fb
msgid "Once ``gcc`` is installed we can use shell support to load it and make it readily available:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:218
# 8bfb0ea7b2d1421dbea538dcdc972158
msgid "It may not be apparent, but the last command employed the module files generated automatically by Spack. What happens under the hood when you use the ``spack load`` command is:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:222
# ae5bca6dcd0b41feb901fc008d6101b3
msgid "the spec passed as argument is translated into a module file name"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:223
# 011a52876622401987361aaf374ebfbb
msgid "the current module tool is used to load that module file"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:225
# 3bc50553540247d1bc9a12e009a1efdb
msgid "You can use this command to double check:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:233
# f8e1c082cece46d0891e43e0e45cdb1d
msgid "Note that the 7-digit hash at the end of the generated module may vary depending on architecture or package version. Now that we have ``gcc@7.2.0`` in ``PATH`` we can finally add it to the list of compilers known to Spack:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:256
# f90e20744cbd4859992b16c099448c56
msgid "Build the software that will be used in the tutorial"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:258
# f8c57c7f57714459970bc5a91f3081bf
msgid "Finally, we should use Spack to install the packages used in the examples:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:273
# d4ef7bc77e854494a10eb4d6abdad9ba
msgid "Non-hierarchical module files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:275
# cdc60445cac04f7e8e35dce2cab86b5e
msgid "If you arrived to this point you should have an environment that looks similar to:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:313
# ae2e6f09b6504525a5327fdf849a6937
msgid "The non-hierarchical module files that have been generated so far follow :ref:`the default rules for module generation <modules-yaml>`. Taking a look at the ``gcc`` module you'll see, for example:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:341
# 0751142648d742a891f41e936228cb5a
msgid "As expected, a few environment variables representing paths will be modified by the module file according to the default prefix inspection rules."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:347
# eb3e7fad14bb47b99cf1e453ab6ac7ce
msgid "Filter unwanted modifications to the environment"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:349
# f9d7eceeae7d44198092806a7bb4c1fd
msgid "Now consider the case that your site has decided that ``CPATH`` and ``LIBRARY_PATH`` modifications should not be present in module files. What you can do to abide by the rules is to create a configuration file ``~/.spack/modules.yaml`` with the following content:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:362
# d5ebbb9b1d834bc19257430b5738b6fe
msgid "Next you should regenerate all the module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:390
# 077c96af1b1d4ddeac1ec18a92e57244
msgid "If you take a look now at the module for ``gcc`` you'll see that the unwanted paths have disappeared:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:416
# 24c357e2b66c404bb13c6cfd57d78787
msgid "Prevent some module files from being generated"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:418
# 2f61053b960949729c3e1183aad7f44a
msgid "Another common request at many sites is to avoid exposing software that is only needed as an intermediate step when building a newer stack. Let's try to prevent the generation of module files for anything that is compiled with ``gcc@5.4.0`` (the OS provided compiler)."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:423
# e5d8316dd860417abaa9e34fb74bb0ab
msgid "To do this you should add a ``blacklist`` keyword to ``~/.spack/modules.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:436
# 3c0972f9794541f7bc58e4bbf7f6ee1a
msgid "and regenerate the module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:438
# d794514828a84738a145e9b99db8e5f3
msgid "This time it is convenient to pass the option ``--delete-tree`` to the command that regenerates the module files to instruct it to delete the existing tree and regenerate a new one instead of overwriting the files in the existing directory."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:487
# b5574453aec34c32b0d03a466a4795aa
msgid "If you look closely you'll see though that we went too far in blacklisting modules: the module for ``gcc@7.2.0`` disappeared as it was bootstrapped with ``gcc@5.4.0``. To specify exceptions to the blacklist rules you can use ``whitelist``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:504
# 23fe64b1f48644638e5879fe24a7dac2
msgid "``whitelist`` rules always have precedence over ``blacklist`` rules. If you regenerate the modules again:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:512
# fe244a4ab7d9470b8c512d45db986ee8
msgid "you'll see that now the module for ``gcc@7.2.0`` has reappeared:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:524
# ac83b53fb18b426c9426afbffa5d0df9
msgid "An additional possibility that you can leverage to unclutter the environment is that of preventing the generation of module files for implicitly installed packages. In this case all one needs to do is to add the following line:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:542
# 66cf8a052d774317abcc7bc59f4754e6
msgid "to ``modules.yaml`` and regenerate the module file tree as above."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:546
# 28e6f8bd58214a39b65f5d4009856e56
msgid "Change module file naming"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:548
# f771db6b2cfb416ea73e719689a85c29
msgid "The next step in making  module files more user-friendly is to improve their naming scheme. To reduce the length of the hash or remove it altogether you can use the ``hash_length`` keyword in the configuration file:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:567
# 35c95efe71484b1f965727c5d5d456cf
msgid "If you try to regenerate the module files now you will get an error:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:584
# f5b9e249f30c4cb1916194ba334da675
msgid "We try to check for errors upfront!"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:584
# d634bf1d18e14ad9a595f1107e480428
msgid "In Spack we check for errors upfront whenever possible, so don't worry about your module files: as a name clash was detected nothing has been changed on disk."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:587
# 2c03e6fa4aaa4cd9974de5b5ea3dc4aa
msgid "The problem here is that without the hashes the four different flavors of ``netlib-scalapack`` map to the same module file name. We can add suffixes to differentiate them:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:612
# 8673da8819f046f8910e9fbcb9a2d4d4
msgid "As you can see it is possible to specify rules that apply only to a restricted set of packages using :ref:`anonymous specs <anonymous_specs>`. Regenerating module files now we obtain:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:640
# d4c1e939fc034f5dac13cf3d62881db0
msgid "Finally we can set a ``naming_scheme`` to prevent users from loading modules that refer to different flavors of the same library/application:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:667
# 10bc70d95b3646c6a01ff56c0280d886
msgid "The final result should look like:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:698
# 12af5232765045929150115cb97ee454
msgid "TCL specific directive"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:698
# f833778536c74cc986249398198906ad
msgid "The directives ``naming_scheme`` and ``conflict`` are TCL specific and can't be used in the ``lmod`` section of the configuration file."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:703
# 5472b7f1f191464094ad6427e1567863
msgid "Add custom environment modifications"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:705
# 7424e56dc360426780f6c931338e5ea2
msgid "At many sites it is customary to set an environment variable in a package's module file that points to the folder in which the package is installed. You can achieve this with Spack by adding an ``environment`` directive to the configuration file:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:737
# f46e3c2d52bd448782efbd0e72259401
msgid "Under the hood Spack uses the :meth:`~spack.spec.Spec.format` API to substitute tokens in either environment variable names or values. There are two caveats though:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:740
# 145361e2ca62426c9e37cbc0ebb255cd
msgid "The set of allowed tokens in variable names is restricted to ``name``, ``version``, ``compiler``, ``compiler.name``, ``compiler.version``, ``architecture``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:743
# 1927a61fc89b4a7b823e86db21ec0dfa
msgid "Any token expanded in a variable name is made uppercase, but other than that case sensitivity is preserved"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:746
# 7be0ab805b28407db8a67d5fe9b6193f
msgid "Regenerating the module files results in something like:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:775
# 73e37bfeecbf4691acccc67ff7a02510
msgid "As you can see, the ``gcc`` module has the environment variable ``GCC_ROOT`` set."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:777
# 5329cab612a64f8a8ba2ce7446ff4948
msgid "Sometimes it's also useful to apply environment modifications selectively and target only certain packages. You can, for instance set the common variables ``CC``, ``CXX``, etc. in the ``gcc`` module file and apply other custom modifications to the ``openmpi`` modules as follows:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:822
# 33a7e1e9a0ad485cbd2c4fef940931ce
msgid "This time we will be more selective and regenerate only the ``gcc`` and ``openmpi`` module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:886
# 188114f79c07402c9e3df6283a0d1392
msgid "Autoload dependencies"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:888
# 54c571b8c1a24bb3a82b205a26cb0e46
msgid "Spack can also generate module files that contain code to load the dependencies automatically. You can, for instance generate python modules that load their dependencies by adding the ``autoload`` directive and assigning it the value ``direct``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:936
# 38e5359500ec49d5bc14f87d070e8804
msgid "and regenerating the module files for every package that depends on ``python``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:943
# 6eac3d6fd30b486a9241aecd985babca
msgid "Now the ``py-scipy`` module will be:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:981
# 6eba14db44ff41ebb16b0c12b0f6339c
msgid "and will contain code to autoload all the dependencies:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:990
# 0ac58dc153ec43f5815688481515964d
msgid "In case messages are unwanted during the autoload procedure, it will be sufficient to omit the line setting ``verbose: True`` in the configuration file above."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:995
# 44a142d22d674d3ab5ca04fe43225260
msgid "Hierarchical module files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:997
# 3b5f0656c23145fdbf07ca24f1304b06
msgid "So far we worked with non-hierarchical module files, i.e. with module files that are all generated in the same root directory and don't attempt to dynamically modify the ``MODULEPATH``. This results in a flat module structure where all the software is visible at the same time:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1028
# b66d2c37585046c487308b2b5ffb3cb6
msgid "This layout is quite simple to deploy, but you can see from the above snippet that nothing prevents users from loading incompatible sets of modules:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1040
# a946eb11692144a287f5036b322ef0b6
msgid "Even if ``conflicts`` directives are carefully placed in module files, they:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1042
# e092f37ef14246fe964d54cd140ea792
msgid "won't enforce a consistent environment, but will just report an error"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1043
# 4287ca34c63b46df96141835a3026858
msgid "need constant updates, for instance as soon as a new compiler or MPI library is installed"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1045
# 12123f2eda924c1ea020def7b72aed83
msgid "`Hierarchical module files <http://lmod.readthedocs.io/en/latest/080_hierarchy.html>`_ try to overcome these shortcomings by showing at start-up only a restricted view of what is available on the system: more specifically only the software that has been installed with OS provided compilers. Among this software there will be other - usually more recent - compilers that, once loaded, will prepend new directories to ``MODULEPATH`` unlocking all the software that was compiled with them. This \"unlocking\" idea can then be extended arbitrarily to virtual dependencies, as we'll see in the following section."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1055
# b7fa9a9cf74644c0a69c4ffeec509ddc
msgid "Core/Compiler/MPI"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1057
# eab859c38dce470d8bb55084ea036276
msgid "The most widely used hierarchy is the so called ``Core/Compiler/MPI`` where, on top of the compilers, different MPI libraries also unlock software linked to them. There are just a few steps needed to adapt the ``modules.yaml`` file we used previously:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1061
# bbfbb7a4ef254b459a6864ff4c09095b
msgid "enable the ``lmod`` file generator"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1062
# 20d32003d0554bf38949032e5616bcb1
msgid "change the ``tcl`` tag to ``lmod``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1063
# 2bbb4ca5daf04db3972a4cf2e6c26d59
msgid "remove ``tcl`` specific directives (``naming_scheme`` and ``conflict``)"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1064
# 1813069e50314a00a7efdf96742b741b
msgid "declare which compilers are considered ``core_compilers``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1065
# a6400b2adbee498bb9a46e4389a29372
msgid "remove the ``mpi`` related suffixes (as they will be substituted by hierarchies)"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1067
# 1081fd0501ad4590951b570e534b4ad4
msgid "After these modifications your configuration file should look like:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1113
# 922bdf6a684e4f32b8dd171eeb3c06f1
msgid "Double colon in configuration files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1111
# 52870aa02cc54532a2a79ef48cefd548
msgid "The double colon after ``enable`` is intentional and it serves the purpose of overriding the default list of enabled generators so that only ``lmod`` will be active (see :ref:`config-overrides` for more details)."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1116
# 9712e2bfd5014d05a5328a65284b73d9
msgid "The directive ``core_compilers`` accepts a list of compilers. Everything built using these compilers will create a module in the ``Core`` part of the hierarchy, which is the entry point for hierarchical module files. It is common practice to put the OS provided compilers in the list and only build common utilities and other compilers with them."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1122
# 5a87b909f6034f1cbb9bd9b412f6a43b
msgid "If we now regenerate the module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1129
# 677b5d7b90424c959591bf2f6b4e12d3
msgid "and update ``MODULEPATH`` to point to the ``Core``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1137
# 6fb2945ae0ab4341afbdd2f8b4a8d958
msgid "asking for the available modules will return:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1149
# d8eb2e92966043f7b963955e17f45d4e
msgid "Unsurprisingly, the only visible module is ``gcc``. Loading that we'll unlock the ``Compiler`` part of the hierarchy:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1173
# 5aa680dc4bba4869bd393bb43a57442a
msgid "The same holds true also for the ``MPI`` part, that you can enable by loading either ``mpich`` or ``openmpi``. Let's start by loading ``mpich``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1208
# c5e5755fc9164393a14e2d55b08f9f64
msgid "At this point we can showcase the improved consistency that a hierarchical layout provides over a non-hierarchical one:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1221
# ed7659c42c814ec7a81171775a8f2fa2
msgid "``Lmod`` took care of swapping the MPI provider for us, and it also substituted the ``netlib-scalapack`` module to conform to the change in the MPI. In this way we can't accidentally pull-in two different MPI providers at the same time or load a module file for a package linked to ``openmpi`` when ``mpich`` is also loaded. Consistency for compilers and MPI is ensured by the tool."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1230
# 4b8efca10d3944ab8ef88706cd153640
msgid "Add LAPACK to the hierarchy"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1232
# 36553a62e7a54097a354fe0b9e389669
msgid "The hierarchy just shown is already a great improvement over non-hierarchical layouts, but it still has an asymmetry: ``LAPACK`` providers cover the same semantic role as ``MPI`` providers, but yet they are not part of the hierarchy."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1236
# eded343b39514043bf91a0129ab55dd8
msgid "To be more practical, this means that although we have gained an improved consistency in our environment when it comes to ``MPI``, we still have the same problems as we had before for ``LAPACK`` implementations:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1257
# f7fa5f2deb554805989c5d3721b29546
msgid "Hierarchies that are deeper than ``Core``/``Compiler``/``MPI`` are probably still considered \"unusual\" or \"impractical\" at many sites, mainly because module files are written manually and keeping track of the combinations among multiple providers quickly becomes quite involved."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1262
# ee7ddde6203b4297b81648c90f603778
msgid "For instance, having both ``MPI`` and ``LAPACK`` in the hierarchy means we must classify software into one of four categories:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1265
# d2f9945ed8ad4738a52e580783dc6575
msgid "Software that doesn't depend on ``MPI`` or ``LAPACK``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1266
# 66b36da2e6d54fb3b0ab4395c504c93a
msgid "Software that depends only on ``MPI``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1267
# e4d9ab48a01e4c8c9104d9803ecf416c
msgid "Software that depends only on ``LAPACK``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1268
# 5ff186fd24e84fa5aaaf30b979009942
msgid "Software that depends on both"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1270
# 691726b0e0c044239281eebfa8455959
msgid "to decide when to show it to the user. The situation becomes more involved as the number of virtual dependencies in the hierarchy increases."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1273
# dea03c8fb8ee410ca25e0ab78cfba522
msgid "We can take advantage of the DAG that Spack maintains for the installed software and solve this combinatorial problem in a clean and automated way. In some sense Spack's ability to manage this combinatorial complexity makes deeper hierarchies feasible."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1278
# d60a1297c5df42a6bc42d3581ff2dfeb
msgid "Coming back to our example, let's add ``lapack`` to the hierarchy and remove any remaining suffix:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1317
# 1c185beafbf6475aba196d96414a0fb7
msgid "After module files have been regenerated as usual:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1326
# 5f50102b2a994889ba7aadad5ea46392
msgid "we can see that now we have additional components in the hierarchy:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1379
# 9ff977eb2d3143f18e2e255f468da63e
msgid "Both ``MPI`` and ``LAPACK`` providers will now benefit from the same safety features:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1403
# be6856cd9824465bb66cfbbde51857ca
msgid "Because we only compiled ``py-numpy`` with ``openblas`` the module is made inactive when we switch the ``LAPACK`` provider. The user environment is now consistent by design!"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1409
# 9b9562162d89420891b48561229c1563
msgid "Working with templates"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1411
# a677b61a8d6a4115991f3909dbd16d71
msgid "As briefly mentioned in the introduction, Spack uses `Jinja2 <http://jinja.pocoo.org/docs/2.9/>`_ to generate each individual module file. This means that you have all of its flexibility and power when it comes to customizing what gets generated!"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1418
# ad448f35bf6d4beebbe47dea91a7c90b
msgid "Module file templates"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1420
# dd999ff15dbd4ff08d9532a1815edda3
msgid "The templates that Spack uses to generate module files are stored in the ``share/spack/templates/module`` directory within the Spack prefix, and they all share the same common structure.  Usually, they start with a header that identifies the type of module being generated. In the case of hierarchical module files it's:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1430
# 0ee2da053925473084304a5f5307f927
msgid "The statements within double curly brackets ``{{ ... }}`` denote `expressions <http://jinja.pocoo.org/docs/2.9/templates/#expressions>`_ that will be evaluated and substituted at module generation time. The rest of the file is then divided into `blocks <http://jinja.pocoo.org/docs/2.9/templates/#template-inheritance>`_ that can be overridden or extended by users, if need be. `Control structures <http://jinja.pocoo.org/docs/2.9/templates/#list-of-control-structures>`_ , delimited by ``{% ... %}``, are also permitted in the template language:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1444
# 818417c19f71496d9e7e551e3dde901e
msgid "The locations where Spack looks for templates are specified in ``config.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1451
# 4ed7f6929f47401f8d25a1c65b726518
msgid "and can be extended by users to employ custom templates, as we'll see next."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1455
# 5f6cd0b2f3b747eaa33075a6502a7a26
msgid "Extend the default templates"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1457
# 421a392f535241f48d33b853ea5d709a
msgid "Let's assume one of our software is protected by group membership: allowed users belong to the same linux group, and access is granted at group level. Wouldn't it be nice if people that are not yet entitled to use it could receive a helpful message at module load time that tells them who to contact in your organization to be inserted in the group?"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1463
# bffb4b2531f647f888ccae0e078d5bef
msgid "To automate the generation of module files with such site-specific behavior we'll start by extending the list of locations where Spack looks for module files. Let's create the file ``~/.spack/config.yaml`` with the content:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1473
# 57e1210655eb45c9b5d1fc581f626983
msgid "This tells Spack to also search another location when looking for template files. Next, we need to create our custom template extension in the folder listed above:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1489
# 0af949dc2415425c8014b5b7533ae6d1
msgid "Let's name this file ``group-restricted.lua``. The line:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1495
# 12cb7e690de8427bb5bf471eb0f8107b
msgid "tells Jinja2 that we are reusing the standard template for hierarchical module files. The section:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1510
# 5b8a7d271b5f4f6c9b591c515a83c277
msgid "overrides the ``footer`` block. Finally, we need to add a couple of lines in ``modules.yaml`` to tell Spack which specs need to use the new custom template. For the sake of illustration let's assume it's ``netlib-scalapack``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1555
# ddb1c6905619479ba694b3f1393c6a81
msgid "If we regenerate the module files one last time:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1562
# 2a42236b6dbf4dd6be305b4f5930a4a2
msgid "we'll find the following at the end of each ``netlib-scalapack`` module file:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1574
# 3746fed7e9bd4de6b78704b6445c5b72
msgid "and every user that doesn't have access to the software will now be redirected to the right e-mail address where to ask for it!"
msgstr ""

