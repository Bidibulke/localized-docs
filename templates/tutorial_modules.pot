# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-27 13:31-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/tutorial_modules.rst:10
msgid "Module Files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:12
msgid "In this tutorial, we'll introduce a few concepts that are fundamental to the generation of module files with Spack, and we'll guide you through the customization of both module files content and their layout on disk. In the end you should have a clear understanding of:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:17
msgid "What are module files and how they work"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:18
msgid "How Spack generates them"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:19
msgid "Which commands are available to ease their maintenance"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:20
msgid "How it is possible to customize them in all aspects"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:26
msgid "Modules at a glance"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:28
msgid "Let's start by summarizing what module files are and how you can use them to modify your environment. The idea is to give enough information so that people without any previous exposure to them will be able to follow the tutorial later on. We'll also give a high-level view of how module files are generated in Spack. If you are already familiar with these topics you can quickly skim through this section or move directly to :ref:`module_file_tutorial_prerequisites`."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:39
msgid "What are module files?"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:41
msgid "Module files are an easy way to modify your environment in a controlled manner during a shell session. In general, they contain the information needed to run an application or use a library, and they work in conjunction with a tool that interprets them. Typical module files instruct this tool to modify the environment variables when a module file is loaded:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:69
msgid "and to undo the modifications when the same module file is unloaded:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:78
msgid "Different formats exist for module files, and different tools provide various levels of support for them. Spack can natively generate:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:81
msgid "Non-hierarchical module files written in TCL"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:82
msgid "Hierarchical module files written in Lua"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:84
msgid "and can build `environment-modules <http://modules.sourceforge.net/>`_ and `lmod <http://lmod.readthedocs.io/en/latest>`_ as support tools. Which of the formats or tools best suits one's needs depends on each particular use-case. For the sake of illustration, we'll be working on both formats using ``lmod``."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:97
msgid "Environment modules"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:92
msgid "This is the original tool that provided modules support. Its first version was coded in C in the early '90s and was later substituted by a version completely coded in TCL - the one Spack is distributing. More details on its features are given in the `homepage of the project <http://modules.sourceforge.net/>`_ or in its `github page <https://github.com/cea-hpc/modules>`_. The tool is able to interpret the non-hierarchical TCL modulefiles written by Spack."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:106
msgid "Lmod"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:100
msgid "Lmod is a module system written in Lua, designed to easily handle hierarchies of module files. It's a drop-in replacement of Environment Modules and works with both of the module file formats generated by Spack. Despite being fully compatible with Environment Modules there are many features that are unique to Lmod. These features are either `targeted towards safety <http://lmod.readthedocs.io/en/latest/010_user.html#safety-features>`_ or meant to `extend the module system functionality <http://lmod.readthedocs.io/en/latest/010_user.html#module-hierarchy>`_."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:112
msgid "How do we generate module files?"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:114
msgid "Before  we dive into the hands-on sections it's worth spending a couple of words to explain how module files are generated by Spack. The following diagram provides a high-level view of the process:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:121
msgid "The red dashed line above represents Spack's boundaries, the blue one Spack's dependencies [#f1]_. Module files are generated by combining:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:124
msgid "the configuration details in ``config.yaml`` and ``modules.yaml``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:125
msgid "the information contained in Spack packages (and processed by the module subpackage)"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:126
msgid "a set of template files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:128
msgid "with `Jinja2 <http://jinja.pocoo.org/docs/2.9/>`_, an external template engine that stamps out each particular module file. As Spack serves very diverse needs this process has many points of customization, and we'll explore most of them in the next sections."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:133
msgid "Spack vendors its dependencies! This means that Spack comes with a copy of each one of its dependencies, including ``Jinja2``, and is already configured to use them."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:140
msgid "Setup for the tutorial"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:142
msgid "In order to showcase the capabilities of Spack's module file generation, we need a representative set of software to work with. This set must include different flavors of the same packages installed alongside each other and some :ref:`external packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:147
msgid "The purpose of this setup is not to make our life harder but to demonstrate how Spack can help with similar situations, as they will happen on real HPC clusters. For instance, it's often preferable for Spack to use vendor-provided MPI implementations than to build one itself."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:152
msgid "To keep the set of software we're dealing with manageable, we're going to uninstall everything from earlier in the tutorial."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:161
msgid "Build a module tool"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:163
msgid "The first thing that we need is the module tool. In this case we choose ``lmod`` as it can work with both hierarchical and non-hierarchical module file layouts."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:171
msgid "Once the module tool is installed we need to have it available in the current shell. As the installation directories are definitely not easy to remember, we'll employ the command ``spack location`` to retrieve the ``lmod`` prefix directly from Spack:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:180
msgid "Now we can re-source the setup file and Spack modules will be put in our module path."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:196
msgid "Add a new compiler"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:198
msgid "The second step is to build a recent compiler. On first use, Spack scans the environment and automatically locates the compiler(s) already available on the system. For this tutorial, however, we want to use ``gcc@7.2.0``."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:211
msgid "Once ``gcc`` is installed we can use shell support to load it and make it readily available:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:218
msgid "It may not be apparent, but the last command employed the module files generated automatically by Spack. What happens under the hood when you use the ``spack load`` command is:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:222
msgid "the spec passed as argument is translated into a module file name"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:223
msgid "the current module tool is used to load that module file"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:225
msgid "You can use this command to double check:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:233
msgid "Note that the 7-digit hash at the end of the generated module may vary depending on architecture or package version. Now that we have ``gcc@7.2.0`` in ``PATH`` we can finally add it to the list of compilers known to Spack:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:256
msgid "Build the software that will be used in the tutorial"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:258
msgid "Finally, we should use Spack to install the packages used in the examples:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:273
msgid "Non-hierarchical module files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:275
msgid "If you arrived to this point you should have an environment that looks similar to:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:313
msgid "The non-hierarchical module files that have been generated so far follow :ref:`the default rules for module generation <modules-yaml>`. Taking a look at the ``gcc`` module you'll see, for example:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:341
msgid "As expected, a few environment variables representing paths will be modified by the module file according to the default prefix inspection rules."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:347
msgid "Filter unwanted modifications to the environment"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:349
msgid "Now consider the case that your site has decided that ``CPATH`` and ``LIBRARY_PATH`` modifications should not be present in module files. What you can do to abide by the rules is to create a configuration file ``~/.spack/modules.yaml`` with the following content:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:362
msgid "Next you should regenerate all the module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:390
msgid "If you take a look now at the module for ``gcc`` you'll see that the unwanted paths have disappeared:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:416
msgid "Prevent some module files from being generated"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:418
msgid "Another common request at many sites is to avoid exposing software that is only needed as an intermediate step when building a newer stack. Let's try to prevent the generation of module files for anything that is compiled with ``gcc@5.4.0`` (the OS provided compiler)."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:423
msgid "To do this you should add a ``blacklist`` keyword to ``~/.spack/modules.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:436
msgid "and regenerate the module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:438
msgid "This time it is convenient to pass the option ``--delete-tree`` to the command that regenerates the module files to instruct it to delete the existing tree and regenerate a new one instead of overwriting the files in the existing directory."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:487
msgid "If you look closely you'll see though that we went too far in blacklisting modules: the module for ``gcc@7.2.0`` disappeared as it was bootstrapped with ``gcc@5.4.0``. To specify exceptions to the blacklist rules you can use ``whitelist``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:504
msgid "``whitelist`` rules always have precedence over ``blacklist`` rules. If you regenerate the modules again:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:512
msgid "you'll see that now the module for ``gcc@7.2.0`` has reappeared:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:524
msgid "An additional possibility that you can leverage to unclutter the environment is that of preventing the generation of module files for implicitly installed packages. In this case all one needs to do is to add the following line:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:542
msgid "to ``modules.yaml`` and regenerate the module file tree as above."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:546
msgid "Change module file naming"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:548
msgid "The next step in making  module files more user-friendly is to improve their naming scheme. To reduce the length of the hash or remove it altogether you can use the ``hash_length`` keyword in the configuration file:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:567
msgid "If you try to regenerate the module files now you will get an error:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:584
msgid "We try to check for errors upfront!"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:584
msgid "In Spack we check for errors upfront whenever possible, so don't worry about your module files: as a name clash was detected nothing has been changed on disk."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:587
msgid "The problem here is that without the hashes the four different flavors of ``netlib-scalapack`` map to the same module file name. We can add suffixes to differentiate them:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:612
msgid "As you can see it is possible to specify rules that apply only to a restricted set of packages using :ref:`anonymous specs <anonymous_specs>`. Regenerating module files now we obtain:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:640
msgid "Finally we can set a ``naming_scheme`` to prevent users from loading modules that refer to different flavors of the same library/application:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:667
msgid "The final result should look like:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:698
msgid "TCL specific directive"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:698
msgid "The directives ``naming_scheme`` and ``conflict`` are TCL specific and can't be used in the ``lmod`` section of the configuration file."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:703
msgid "Add custom environment modifications"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:705
msgid "At many sites it is customary to set an environment variable in a package's module file that points to the folder in which the package is installed. You can achieve this with Spack by adding an ``environment`` directive to the configuration file:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:737
msgid "Under the hood Spack uses the :meth:`~spack.spec.Spec.format` API to substitute tokens in either environment variable names or values. There are two caveats though:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:740
msgid "The set of allowed tokens in variable names is restricted to ``name``, ``version``, ``compiler``, ``compiler.name``, ``compiler.version``, ``architecture``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:743
msgid "Any token expanded in a variable name is made uppercase, but other than that case sensitivity is preserved"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:746
msgid "Regenerating the module files results in something like:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:775
msgid "As you can see, the ``gcc`` module has the environment variable ``GCC_ROOT`` set."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:777
msgid "Sometimes it's also useful to apply environment modifications selectively and target only certain packages. You can, for instance set the common variables ``CC``, ``CXX``, etc. in the ``gcc`` module file and apply other custom modifications to the ``openmpi`` modules as follows:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:822
msgid "This time we will be more selective and regenerate only the ``gcc`` and ``openmpi`` module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:886
msgid "Autoload dependencies"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:888
msgid "Spack can also generate module files that contain code to load the dependencies automatically. You can, for instance generate python modules that load their dependencies by adding the ``autoload`` directive and assigning it the value ``direct``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:936
msgid "and regenerating the module files for every package that depends on ``python``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:943
msgid "Now the ``py-scipy`` module will be:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:981
msgid "and will contain code to autoload all the dependencies:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:990
msgid "In case messages are unwanted during the autoload procedure, it will be sufficient to omit the line setting ``verbose: True`` in the configuration file above."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:995
msgid "Hierarchical module files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:997
msgid "So far we worked with non-hierarchical module files, i.e. with module files that are all generated in the same root directory and don't attempt to dynamically modify the ``MODULEPATH``. This results in a flat module structure where all the software is visible at the same time:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1028
msgid "This layout is quite simple to deploy, but you can see from the above snippet that nothing prevents users from loading incompatible sets of modules:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1040
msgid "Even if ``conflicts`` directives are carefully placed in module files, they:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1042
msgid "won't enforce a consistent environment, but will just report an error"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1043
msgid "need constant updates, for instance as soon as a new compiler or MPI library is installed"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1045
msgid "`Hierarchical module files <http://lmod.readthedocs.io/en/latest/080_hierarchy.html>`_ try to overcome these shortcomings by showing at start-up only a restricted view of what is available on the system: more specifically only the software that has been installed with OS provided compilers. Among this software there will be other - usually more recent - compilers that, once loaded, will prepend new directories to ``MODULEPATH`` unlocking all the software that was compiled with them. This \"unlocking\" idea can then be extended arbitrarily to virtual dependencies, as we'll see in the following section."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1055
msgid "Core/Compiler/MPI"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1057
msgid "The most widely used hierarchy is the so called ``Core/Compiler/MPI`` where, on top of the compilers, different MPI libraries also unlock software linked to them. There are just a few steps needed to adapt the ``modules.yaml`` file we used previously:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1061
msgid "enable the ``lmod`` file generator"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1062
msgid "change the ``tcl`` tag to ``lmod``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1063
msgid "remove ``tcl`` specific directives (``naming_scheme`` and ``conflict``)"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1064
msgid "declare which compilers are considered ``core_compilers``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1065
msgid "remove the ``mpi`` related suffixes (as they will be substituted by hierarchies)"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1067
msgid "After these modifications your configuration file should look like:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1113
msgid "Double colon in configuration files"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1111
msgid "The double colon after ``enable`` is intentional and it serves the purpose of overriding the default list of enabled generators so that only ``lmod`` will be active (see :ref:`config-overrides` for more details)."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1116
msgid "The directive ``core_compilers`` accepts a list of compilers. Everything built using these compilers will create a module in the ``Core`` part of the hierarchy, which is the entry point for hierarchical module files. It is common practice to put the OS provided compilers in the list and only build common utilities and other compilers with them."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1122
msgid "If we now regenerate the module files:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1129
msgid "and update ``MODULEPATH`` to point to the ``Core``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1137
msgid "asking for the available modules will return:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1149
msgid "Unsurprisingly, the only visible module is ``gcc``. Loading that we'll unlock the ``Compiler`` part of the hierarchy:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1173
msgid "The same holds true also for the ``MPI`` part, that you can enable by loading either ``mpich`` or ``openmpi``. Let's start by loading ``mpich``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1208
msgid "At this point we can showcase the improved consistency that a hierarchical layout provides over a non-hierarchical one:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1221
msgid "``Lmod`` took care of swapping the MPI provider for us, and it also substituted the ``netlib-scalapack`` module to conform to the change in the MPI. In this way we can't accidentally pull-in two different MPI providers at the same time or load a module file for a package linked to ``openmpi`` when ``mpich`` is also loaded. Consistency for compilers and MPI is ensured by the tool."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1230
msgid "Add LAPACK to the hierarchy"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1232
msgid "The hierarchy just shown is already a great improvement over non-hierarchical layouts, but it still has an asymmetry: ``LAPACK`` providers cover the same semantic role as ``MPI`` providers, but yet they are not part of the hierarchy."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1236
msgid "To be more practical, this means that although we have gained an improved consistency in our environment when it comes to ``MPI``, we still have the same problems as we had before for ``LAPACK`` implementations:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1257
msgid "Hierarchies that are deeper than ``Core``/``Compiler``/``MPI`` are probably still considered \"unusual\" or \"impractical\" at many sites, mainly because module files are written manually and keeping track of the combinations among multiple providers quickly becomes quite involved."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1262
msgid "For instance, having both ``MPI`` and ``LAPACK`` in the hierarchy means we must classify software into one of four categories:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1265
msgid "Software that doesn't depend on ``MPI`` or ``LAPACK``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1266
msgid "Software that depends only on ``MPI``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1267
msgid "Software that depends only on ``LAPACK``"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1268
msgid "Software that depends on both"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1270
msgid "to decide when to show it to the user. The situation becomes more involved as the number of virtual dependencies in the hierarchy increases."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1273
msgid "We can take advantage of the DAG that Spack maintains for the installed software and solve this combinatorial problem in a clean and automated way. In some sense Spack's ability to manage this combinatorial complexity makes deeper hierarchies feasible."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1278
msgid "Coming back to our example, let's add ``lapack`` to the hierarchy and remove any remaining suffix:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1317
msgid "After module files have been regenerated as usual:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1326
msgid "we can see that now we have additional components in the hierarchy:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1379
msgid "Both ``MPI`` and ``LAPACK`` providers will now benefit from the same safety features:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1403
msgid "Because we only compiled ``py-numpy`` with ``openblas`` the module is made inactive when we switch the ``LAPACK`` provider. The user environment is now consistent by design!"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1409
msgid "Working with templates"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1411
msgid "As briefly mentioned in the introduction, Spack uses `Jinja2 <http://jinja.pocoo.org/docs/2.9/>`_ to generate each individual module file. This means that you have all of its flexibility and power when it comes to customizing what gets generated!"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1418
msgid "Module file templates"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1420
msgid "The templates that Spack uses to generate module files are stored in the ``share/spack/templates/module`` directory within the Spack prefix, and they all share the same common structure.  Usually, they start with a header that identifies the type of module being generated. In the case of hierarchical module files it's:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1430
msgid "The statements within double curly brackets ``{{ ... }}`` denote `expressions <http://jinja.pocoo.org/docs/2.9/templates/#expressions>`_ that will be evaluated and substituted at module generation time. The rest of the file is then divided into `blocks <http://jinja.pocoo.org/docs/2.9/templates/#template-inheritance>`_ that can be overridden or extended by users, if need be. `Control structures <http://jinja.pocoo.org/docs/2.9/templates/#list-of-control-structures>`_ , delimited by ``{% ... %}``, are also permitted in the template language:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1444
msgid "The locations where Spack looks for templates are specified in ``config.yaml``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1451
msgid "and can be extended by users to employ custom templates, as we'll see next."
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1455
msgid "Extend the default templates"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1457
msgid "Let's assume one of our software is protected by group membership: allowed users belong to the same linux group, and access is granted at group level. Wouldn't it be nice if people that are not yet entitled to use it could receive a helpful message at module load time that tells them who to contact in your organization to be inserted in the group?"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1463
msgid "To automate the generation of module files with such site-specific behavior we'll start by extending the list of locations where Spack looks for module files. Let's create the file ``~/.spack/config.yaml`` with the content:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1473
msgid "This tells Spack to also search another location when looking for template files. Next, we need to create our custom template extension in the folder listed above:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1489
msgid "Let's name this file ``group-restricted.lua``. The line:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1495
msgid "tells Jinja2 that we are reusing the standard template for hierarchical module files. The section:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1510
msgid "overrides the ``footer`` block. Finally, we need to add a couple of lines in ``modules.yaml`` to tell Spack which specs need to use the new custom template. For the sake of illustration let's assume it's ``netlib-scalapack``:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1555
msgid "If we regenerate the module files one last time:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1562
msgid "we'll find the following at the end of each ``netlib-scalapack`` module file:"
msgstr ""

#: ../spack/lib/spack/docs/tutorial_modules.rst:1574
msgid "and every user that doesn't have access to the software will now be redirected to the right e-mail address where to ask for it!"
msgstr ""

