# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 08:25-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/build_systems.rst:11
# 518880a8003d4d02b3ac400a411d3645
msgid "Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:13
# 41b3ed4842e74375a7c67ec5b81ee632
msgid "Spack defines a number of classes which understand how to use common `build systems  <https://en.wikipedia.org/wiki/List_of_build_automation_software>`_ (Makefiles, CMake, etc.). Spack package definitions can inherit these classes in order to streamline their builds."
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:18
# 1553608b50e34a98bc31e7a2107f056b
msgid "This guide provides information specific to each particular build system. It assumes that you've read the :ref:`packaging-guide` and expands on these ideas for each distinct build system that Spack supports:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:22
# 6b0a8b747b924fa3b4224fa1082a8d23
msgid "Make-based"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:28
# 92884533607b4033b48579a6bd07124f
msgid "Make-incompatible"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:35
# 67cdd235b80143b6aa54be5fba9002ed
msgid "Build-script generation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:44
# de2c0f6db50c4f4a87dcf3c8763f99be
msgid "Language-specific"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:54
# a1046473af7144648c24ebb13ac73d30
msgid "Other"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:62
# 829e6a1e09954f70860e63dd1ec4fe68
msgid "For reference, the :py:mod:`Build System API docs <spack.build_systems>` provide a list of build systems and methods/attributes that can be overridden. If you are curious about the implementation of a particular build system, you can view the source code by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:72
# 5b063758a07b4e4db11c0001d74adb30
msgid "This will open up the ``AutotoolsPackage`` definition in your favorite editor. In addition, if you are working with a less common build system like QMake, SCons, or Waf, it may be useful to see examples of other packages. You can quickly find examples by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:83
# 4c5d0b14f6874c23a484903d1e5e4dc1
msgid "You can then view these packages with ``spack edit``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:85
# 988e44c9273740798730838b03ca3d3f
msgid "This guide is intended to supplement the :py:mod:`Build System API docs <spack.build_systems>` with examples of how to override commonly used methods. It also provides rules of thumb and suggestions for package developers who are unfamiliar with a particular build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:10
# 91d0fc57f50d46d79ce0e58dd5b815e1
msgid "AutotoolsPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:12
# 3f0f92201ab3405493b0d80eedff592c
msgid "Autotools is a GNU build system that provides a build-script generator. By running the platform-independent ``./configure`` script that comes with the package, you can generate a platform-dependent Makefile."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:18
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:22
#: ../spack/lib/spack/docs/build_systems/custompackage.rst:48
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:19
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:18
#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:16
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:17
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:16
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:30
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:20
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:34
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:17
# c4c59df73a6a4a0592671f3e41bbfc77
# e53a14864626486ba0288d2ad1debdb0
# e12b5ccd2c97495aae4a92430f54db06
# d26a58dbf3824ffd9de8d3a23bf1e2c3
# 6eb2404cdfa74feba58e1ae0fb370513
# 452ccfb1a56945a0907cc59082dcd7b2
# 56ddbad7ef5347699fe3b231c172c9a0
# 4b55cfe93d5e4ec9ae99d7a6bca8d3a9
# 59c74ddddd804b55b8340b1dc588f8a8
# f5bb38431f1b42fda40ff69d0dea4fab
# 607986e68a7341058f47dace968a3088
# 61a64a9eba1b4ff5b9b27c5e2ed3d884
msgid "Phases"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:20
# 8c5a64b7776d4b8ea3d905cfb9385bec
msgid "The ``AutotoolsPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:22
# 0c51ed9a3a444a60a9925e94bfabb377
msgid "``autoreconf`` - generate the configure script"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:23
# d7c640b3b55344f9933e74daad37186f
msgid "``configure`` - generate the Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:24
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:27
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:22
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:48
# b42a453ecd8741cca0f219436ab06498
# a79d56da042f4d5b8b008b762f822f4d
# 75774bd876a84445bf2c4be09d846477
# 482b50c6d4344affa8d4667732b8f2db
msgid "``build`` - build the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:25
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:28
#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:20
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:23
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:24
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:49
# 9279483dddb042f78d78796cc22cb4f7
# da67a0006f6148aebb132027688530b1
# 54cc237490f9430295b43188c98fc470
# e5af249b9e3541a99858e811f45dc966
# 571c03171a8b40be81882fabaf1f8d5c
# 23cd063594ac404ab19c630eb43ef983
msgid "``install`` - install the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:27
# fdb5fe825805434987757772a2012f8d
msgid "Most of the time, the ``autoreconf`` phase will do nothing, but if the package is missing a ``configure`` script, ``autoreconf`` will generate one for you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:31
# 505e9681d2504245b42a96f6fa9132c9
msgid "The other phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:42
# c6ed3b2f5f944769b6f45034f90d5b1e
msgid "Of course, you may need to add a few arguments to the ``./configure`` line."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:47
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:48
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:39
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:51
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:86
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:60
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:65
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:74
# 780dcaba008946a582a2e4c25d3f4725
# 78dffbdf035e453b96adfb358040ba05
# c32d440b63754d57b0e5f43132d21006
# e947b4ab349147dd826d404ea693b598
# ab70e7a020174ebc9e766d94d8ae83d7
# 065df9194cf743ff957209d94b6b8b0d
# c9c70d2b7d644b3da26e4cdc9c01393c
# 94aa1626192c4d3d9770641b89474773
msgid "Important files"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:49
# 3c3640a65c874cb9b062eee56c2998a5
msgid "The most important file for an Autotools-based package is the ``configure`` script. This script is automatically generated by Autotools and generates the appropriate Makefile when run."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:55
# ecd1975cbf8a43f4a33d9216ace77828
msgid "Watch out for fake Autotools packages!"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:57
# 5f660cd13c0e4712bd39ece997db9ee0
msgid "Autotools is a very popular build system, and many people are used to the classic steps to install a package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:67
# c3d13a34e6864ec5a7e14db4db5a8c26
msgid "For this reason, some developers will write their own ``configure`` scripts that have nothing to do with Autotools. These packages may not accept the same flags as other Autotools packages, so it is better to use the ``Package`` base class and create a :ref:`custom build system <custompackage>`. You can tell if a package uses Autotools by running ``./configure --help`` and comparing the output to other known Autotools packages. You should also look for files like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:75
# d1855ca5b4b6480b8ebf1e2f75363509
msgid "``configure.ac``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:76
# d048c4fb0a4547bf95967eb7aa0daf2d
msgid "``configure.in``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:77
# 54bac3f260f241bba77c0eb61a5406fb
msgid "``Makefile.am``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:79
# 1e69412cd70544f883cd9c9d2b0edb13
msgid "Packages that don't use Autotools aren't likely to have these files."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:83
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:77
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:53
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:81
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:114
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:248
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:78
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:125
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:83
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:88
# b3454ec132d24a28a3d4899148dd87f5
# 812f1b3184454dcfa907ffded3c0847c
# 243c112b0155467e9c7752c2394eac57
# 339154d044b84933aba1b32877b7a324
# b5dbe190e2334aa99655c0e47c7b148e
# 3c251993bf3543b0aa99ef43c94880aa
# c669192bc4254a388784d681be12b0f5
# 4e4e27540e7b4b59a5aa126e33226d75
# 39634ab585764cd4ab294706ee21cf39
# cd24ed0eebb44f00bc5b8df3b0ad36cc
msgid "Build system dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:85
# e7100191895b4380ad295f2d7d94a195
msgid "Whether or not your package requires Autotools to install depends on how the source code is distributed. Most of the time, when developers distribute tarballs, they will already contain the ``configure`` script necessary for installation. If this is the case, your package does not require any Autotools dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:91
# d6760b4bfb284064a4ce39c2020fca9c
msgid "However, a basic rule of version control systems is to never commit code that can be generated. The source code repository itself likely does not have a ``configure`` script. Developers typically write (or auto-generate) a ``configure.ac`` script that contains configuration preferences and a ``Makefile.am`` script that contains build instructions. Then, ``autoconf`` is used to convert ``configure.ac`` into ``configure``, while ``automake`` is used to convert ``Makefile.am`` into ``Makefile.in``. ``Makefile.in`` is used by ``configure`` to generate a platform-dependent ``Makefile`` for you. The following diagram provides a high-level overview of the process:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:105
# 54d652ca87d2455e9674b102948d4269
msgid "`GNU autoconf and automake process for generating makefiles <https://commons.wikimedia.org/wiki/File:Autoconf-automake-process.svg>`_ by `Jdthood` under `CC BY-SA 3.0 <https://creativecommons.org/licenses/by-sa/3.0/deed.en>`_"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:108
# dc1b59335c72477d9428643776402e48
msgid "If a ``configure`` script is not present in your tarball, you will need to generate one yourself. Luckily, Spack already has an ``autoreconf`` phase to do most of the work for you. By default, the ``autoreconf`` phase runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:119
# 78e5b4e95d3c47d88a022f39a37f4045
msgid "All you need to do is add a few Autotools dependencies to the package. Most stable releases will come with a ``configure`` script, but if you check out a commit from the ``develop`` branch, you would want to add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:130
# 2db6dea421424502bb4201840056c372
msgid "In some cases, developers might need to distribute a patch that modifies one of the files used to generate ``configure`` or ``Makefile.in``. In this case, these scripts will need to be regenerated. It is preferable to regenerate these manually using the patch, and then create a new patch that directly modifies ``configure``. That way, Spack can use the secondary patch and additional build system dependencies aren't necessary."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:140
# 809816ac6117418fa9dec67b175645e0
msgid "force_autoreconf"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:142
# 49a499b9d9064e808d9b0a7dab62f36d
msgid "If for whatever reason you really want to add the original patch and tell Spack to regenerate ``configure``, you can do so using the following setting:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:150
# bddf2b6bd53841168b4bd9cf0f83b848
msgid "This line tells Spack to wipe away the existing ``configure`` script and generate a new one. If you only need to do this for a single version, this can be done like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:162
# 380c26676b744a19b44204229a3302b8
msgid "Finding configure flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:164
# 07a83e2404c44c6dac987da96c40585c
msgid "Once you have a ``configure`` script present, the next step is to determine what option flags are available. These flags can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:172
# b539aaa3e7d44ee68e92dc333a5d6e12
msgid "``configure`` will display a list of valid flags separated into some or all of the following sections:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:175
# 3a18aff29b554ee48491465450c30799
msgid "Configuration"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:176
# 58d7a56ad27d47448220ea5418186a98
msgid "Installation directories"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:177
# 69942863f4224b6ca6330247d477ca15
msgid "Fine tuning of the installation directories"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:178
# f07228acfc604cfbb260135b90d57ac4
msgid "Program names"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:179
# b32695a889114aad8a8580ee3a5a9722
msgid "X features"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:180
# 829e24e2c4c143f78759efecb69c4ddb
msgid "System types"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:181
# ff22e2bf7abf466fa3617e2691d9f0dc
msgid "**Optional Features**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:182
# e88b1fd5a6de41b880b1bc9e1c23dbf1
msgid "**Optional Packages**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:183
# 958ad63527654909a31cee2ba1a6e1b8
msgid "**Some influential environment variables**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:185
# f545f802c7ea415c97bb3ead866aa36c
msgid "For the most part, you can ignore all but the last 3 sections. The \"Optional Features\" sections lists flags that enable/disable features you may be interested in. The \"Optional Packages\" section often lists dependencies and the flags needed to locate them. The \"environment variables\" section lists environment variables that the build system uses to pass flags to the compiler and linker."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:194
# 15ce56f68e7344d0a68a387d84a86855
msgid "Addings flags to configure"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:196
# ffd0c80a56774f0792e5bd2977687b0b
msgid "For most of the flags you encounter, you will want a variant to optionally enable/disable them. You can then optionally pass these flags to the ``configure`` call by overriding the ``configure_args`` function like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:213
# 16ae9eef5d15488d930d5bf0e9f92773
msgid "Note that we are explicitly disabling MPI support if it is not requested. This is important, as many Autotools packages will enable options by default if the dependencies are found, and disable them otherwise. We want Spack installations to be as deterministic as possible. If two users install a package with the same variants, the goal is that both installations work the same way. See `here <https://www.linux.com/news/best-practices-autotools>`__ and `here <https://wiki.gentoo.org/wiki/Project:Quality_Assurance/Automagic_dependencies>`__ for a rationale as to why these so-called \"automagic\" dependencies are a problem."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:223
# 6a059985f4094c2cab0a145bf5b88908
msgid "By default, Autotools installs packages to ``/usr``. We don't want this, so Spack automatically adds ``--prefix=/path/to/installation/prefix`` to your list of ``configure_args``. You don't need to add this yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:229
# 9e26d6cc7054451f9ee8b01c9132b627
msgid "Helper functions"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:231
# c6ce87090c164b3b90ab6fa27cd2a352
msgid "You may have noticed that most of the Autotools flags are of the form ``--enable-foo``, ``--disable-bar``, ``--with-baz=<prefix>``, or ``--without-baz``. Since these flags are so common, Spack provides a couple of helper functions to make your life easier."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:236
# 3990b2c2f0e9477cb0e123388b9accaa
msgid "TODO: document ``with_or_without`` and ``enable_or_disable``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:240
# f0745fb76d3c4a9ab8fdde393002edf6
msgid "Configure script in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:242
# 30ee0b6cf5c64979aa9ff545b1db839b
msgid "Occasionally, developers will hide their source code and ``configure`` script in a subdirectory like ``src``. If this happens, Spack won't be able to automatically detect the build system properly when running ``spack create``. You will have to manually change the package base class and tell Spack where the ``configure`` script resides. You can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:255
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:233
# e60597d934fb426c914e3f37972d8a9d
# 000a150ffe904ba8841159f5932e9395
msgid "Building out of source"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:257
# 74b201f73fd3492f958dbcaeb0ffbeda
msgid "Some packages like ``gcc`` recommend building their software in a different directory than the source code to prevent build pollution. This can be done using the ``build_directory`` variable:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:265
# b244356273694e49881c49987b4d6136
msgid "By default, Spack will build the package in the same directory that contains the ``configure`` script"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:270
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:245
# 4b6eb51a21f5449a9cd04b4b90417faa
# 3ba1173ad3124caba88cf3af12d64a82
msgid "Build and install targets"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:272
# e109abf2f0fc45f0b7fc7b460c89f6a6
msgid "For most Autotools packages, the usual:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:280
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:255
# 192bb8afa6c54f2faac34050c33c6646
# db55bee1170047af813a40a0e577b970
msgid "is sufficient to install the package. However, if you need to run make with any other targets, for example, to build an optional library or build the documentation, you can add these like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:291
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:266
#: ../spack/lib/spack/docs/build_systems/custompackage.rst:169
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:518
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:55
# 6693611fa798411eac2bb036791b8101
# 00b59d7043be47cb971d1960ab3d3bf0
# c83bfcd6c042480581ce7f4ff4bbdc6f
# f304f9d01f3d4ca09d8d65df4a506d05
# 37895587ada348928b39df3a622ae0e9
msgid "Testing"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:293
# ff81c83dafaf49c1ab3a2b5aa68d15b0
msgid "Autotools-based packages typically provide unit testing via the ``check`` and ``installcheck`` targets. If you build your software with ``spack install --test=root``, Spack will check for the presence of a ``check`` or ``test`` target in the Makefile and run ``make check`` for you. After installation, it will check for an ``installcheck`` target and run ``make installcheck`` if it finds one."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:302
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:276
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:306
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:131
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:206
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:744
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:113
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:343
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:303
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:126
# 58dc61e9c1ab46229e3d322324dad00a
# 607bc157712f4635b87081edcad8c466
# 6bd98e10fd9b448a9b1034c57d42eb73
# 37c8de87bc574e49b09891fc699e2480
# 3254e03f4f1145119a8e915ccd7de49f
# 47974eb0edde420ba755e2f2c2339b51
# 2719ad57ead340e5b74080be0fd8b73b
# 54e427aebafe45ec90e69e1228fd8dd6
# 1f64ae15f83746179640b1a15da5b61f
# 1847a0e4b21844098936d18e7992315a
msgid "External documentation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:304
# 9bfa405c07a64bb7936f99d6ebd67e29
msgid "For more information on the Autotools build system, see: https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:10
# 5d92eadb156a4d9383fcfcc7fbb9bfac
msgid "CMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:12
# dde38aef89c6458ebfb2c52428c77278
msgid "Like Autotools, CMake is a widely-used build-script generator. Designed by Kitware, CMake is the most popular build system for new C, C++, and Fortran projects, and many older projects are switching to it as well."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:16
# e84ff1acd81e40c1a7ab917a8b6ea19c
msgid "Unlike Autotools, CMake can generate build scripts for builders other than Make: Ninja, Visual Studio, etc. It is therefore cross-platform, whereas Autotools is Unix-only."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:24
# b6d2e956322649af941d36fd2e7d2b83
msgid "The ``CMakePackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:26
# 61288af0cfdc40a8bda5bbe361f8d5b7
msgid "``cmake`` - generate the Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:30
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:26
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:38
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:25
# d62069e9964f4fe89d5d611a2692c9e5
# d668e8064a2343c69b09f03cb33c0f35
# ceaf8f713b8943d18ba51a2705759c2a
# 843f592d4a8448f6a95ae947341d6257
msgid "By default, these phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:42
# 31e8db2dad5845fa82ccfda1852c0bb3
msgid "A few more flags are passed to ``cmake`` by default, including flags for setting the build type and flags for locating dependencies. Of course, you may need to add a few arguments yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:50
# f5ea1070417e46838c533709716e1816
msgid "A CMake-based package can be identified by the presence of a ``CMakeLists.txt`` file. This file defines the build flags that can be passed to the cmake invocation, as well as linking instructions. If you are familiar with CMake, it can prove very useful for determining dependencies and dependency version requirements."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:56
# 022411bedf0b4ae6b68bdd8e5cc9e45a
msgid "One thing to look for is the ``cmake_minimum_required`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:63
# 7e8082b4049646388e35c4f2455c60a6
msgid "This means that CMake 2.8.12 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:66
# 7c30ef8d86b84afeb3fa1b40c3a8f3ad
msgid "CMake-based packages may also contain ``CMakeLists.txt`` in subdirectories. This modularization helps to manage complex builds in a hierarchical fashion. Sometimes these nested ``CMakeLists.txt`` require additional dependencies not mentioned in the top-level file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:71
# 157619cbf2b044519ef6226a8fdc90a0
msgid "There's also usually a ``cmake`` or ``CMake`` directory containing additional macros, find scripts, etc. These may prove useful in determining dependency version requirements."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:79
# da1d1a40a2824d51ba3e30d48adf6175
msgid "Every package that uses the CMake build system requires a ``cmake`` dependency. Since this is always the case, the ``CMakePackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:88
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:93
# 8f0a255644e04b358379576df53ca2ee
# 58ba431c48154c63b2af37cb86f73d8e
msgid "If you need to specify a particular version requirement, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:98
# 93806943b7684dbabdb5f7e931a24e90
msgid "Finding cmake flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:100
# 2668bbd739c34571a0e5dfab18d54d95
msgid "To get a list of valid flags that can be passed to ``cmake``, run the following command in the directory that contains ``CMakeLists.txt``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:108
# 8629a81739b440309d6534c623ebfa15
msgid "CMake will start by checking for compilers and dependencies. Eventually it will begin to list build options. You'll notice that most of the build options at the top are prefixed with ``CMAKE_``. You can safely ignore most of these options as Spack already sets them for you. This includes flags needed to locate dependencies, RPATH libraries, set the installation directory, and set the build type."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:115
# 6d6f0a3f2dfa49a6abb2a47835c9f17b
msgid "The rest of the flags are the ones you should consider adding to your package. They often include flags to enable/disable support for certain features and locate specific dependencies. One thing you'll notice that makes CMake different from Autotools is that CMake has an understanding of build flag hierarchy. That is, certain flags will not display unless their parent flag has been selected. For example, flags to specify the ``lib`` and ``include`` directories for a package might not appear unless CMake found the dependency it was looking for. You may need to manually specify certain flags to explore the full depth of supported build flags, or check the ``CMakeLists.txt`` yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:128
# 7c11370a9aac4085a70b5cf546ead17f
msgid "Adding flags to cmake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:130
# 7c807769b1cc4797b2ecab3399d91e53
msgid "To add additional flags to the ``cmake`` call, simply override the ``cmake_args`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:148
# 0c4a34fe294d47f7a59632ea21c42a2b
msgid "Generators"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:150
# 21d0f449be8c46d8926d4a296cd3ac1c
msgid "CMake and Autotools are build-script generation tools; they \"generate\" the Makefiles that are used to build a software package. CMake actually supports multiple generators, not just Makefiles. Another common generator is Ninja. To switch to the Ninja generator, simply add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:160
# 4b88c308a07a453897e81e7c854359df
msgid "``CMakePackage`` defaults to \"Unix Makefiles\". If you switch to the Ninja generator, make sure to add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:167
# e6a27b34be724ba39cab4c325407473c
msgid "to the package as well. Aside from that, you shouldn't need to do anything else. Spack will automatically detect that you are using Ninja and run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:177
# 57bc2d406638470f9adbc23202e4f4f1
msgid "Spack currently only supports \"Unix Makefiles\" and \"Ninja\" as valid generators, but it should be simple to add support for alternative generators. For more information on CMake generators, see: https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:184
# 5647f349e32745b69b495add815fd5ba
msgid "CMAKE_BUILD_TYPE"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:186
# 0d93a70bf220404c91193ba296096c25
msgid "Every CMake-based package accepts a ``-DCMAKE_BUILD_TYPE`` flag to dictate which level of optimization to use. In order to ensure uniformity across packages, the ``CMakePackage`` base class adds a variant to control this:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:197
# 0c0c57f0131344aa997c106b4705f837
msgid "However, not every CMake package accepts all four of these options. Grep the ``CMakeLists.txt`` file to see if the default values are missing or replaced. For example, the `dealii <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/dealii/package.py>`_ package overrides the default variant with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:209
# b993ee42cdb3420ca5972d68755b4d6d
msgid "For more information on ``CMAKE_BUILD_TYPE``, see: https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:214
# ad09a63682724a75bb859b4178cf16a0
msgid "CMakeLists.txt in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:216
# 58e1920cf3604ea49d9b0e147e6fa346
msgid "Occasionally, developers will hide their source code and ``CMakeLists.txt`` in a subdirectory like ``src``. If this happens, Spack won't be able to automatically detect the build system properly when running ``spack create``. You will have to manually change the package base class and tell Spack where ``CMakeLists.txt`` resides. You can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:228
# 8a4b7b82019747dfa4299a12515a5891
msgid "Note that this path is relative to the root of the extracted tarball, not to the ``build_directory``. It defaults to the current directory."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:235
# 8d952b17ad02465abbdf7390c6569b3a
msgid "By default, Spack builds every ``CMakePackage`` in a ``spack-build`` sub-directory. If, for whatever reason, you would like to build in a different sub-directory, simply override ``build_directory`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:247
# 9c35f57c57ff4152846544715cc77edc
msgid "For most CMake packages, the usual:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:268
# 91b03c4bc39942d4bdea7107f7123ec3
msgid "CMake-based packages typically provide unit testing via the ``test`` target. If you build your software with ``--test=root``, Spack will check for the presence of a ``test`` target in the Makefile and run ``make test`` for you. If you want to run a different test instead, simply override the ``check`` method."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:278
# 973cb0e80e2a4c21bcc70239825a22db
msgid "For more information on the CMake build system, see: https://cmake.org/cmake/help/latest/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:10
# ce6000e730f04db9b8f2b632d9ada5be
msgid "CudaPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:12
# 9b1dccd0b327419d90c890c1e6a80a2e
msgid "Different from other packages, ``CudaPackage`` does not represent a build system. Instead its goal is to simplify and unify usage of ``CUDA`` in other packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:18
# e46cd8ec28954b668e1d2ada4e4abe38
msgid "Provided variants and dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:20
# 37b09ecabb814fe29fa354be70a440aa
msgid "``CudaPackage`` provides ``cuda`` variant (default to ``off``) to enable/disable ``CUDA``, and ``cuda_arch`` variant to optionally specify the architecture. It also declares dependencies on the ``CUDA`` package ``depends_on('cuda@...')`` based on the architecture as well as specifies conflicts for certain compiler versions."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:27
# 72e6528f7f4f45fb8c94b691652a37e1
msgid "Usage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:29
# b487e986f40642b3aefc463673b663fd
msgid "In order to use it, just add another base class to your package, for example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:10
# a7bd8f9fad924ff595a087f454f2e284
msgid "Custom Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:12
# 31a9d60a68ed40569fdb4f659ed2eaea
msgid "While the build systems listed above should meet your needs for the vast majority of packages, some packages provide custom build scripts. This guide is intended for the following use cases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:16
# 2552d126069a406ba5f1e46d1b53188c
msgid "Packaging software with its own custom build system"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:17
# c7123be705c343c18ab779018e30578d
msgid "Adding support for new build systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:19
# 33afc63bc54f4dccad7dae8c4fba5459
msgid "If you want to add support for a new build system, a good place to start is to look at the definitions of other build systems. This guide focuses mostly on how Spack's build systems work."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:23
# 34904a93c81e4c5096e08fee52169810
msgid "In this guide, we will be using the `perl <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/perl/package.py>`_ and `cmake <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cmake/package.py>`_ packages as examples. ``perl``'s build system is a hand-written ``Configure`` shell script, while ``cmake`` bootstraps itself during installation. Both of these packages require custom build systems."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:32
# 6269895afdc94b7a923ec7058ec50ca8
msgid "Base class"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:34
# b4262a7c2e6543e7a77d25bed02bbd5c
msgid "If your package does not belong to any of the aforementioned build systems that Spack already supports, you should inherit from the ``Package`` base class. ``Package`` is a simple base class with a single phase: ``install``. If your package is simple, you may be able to simply write an ``install`` method that gets the job done. However, if your package is more complex and installation involves multiple steps, you should add separate phases as mentioned in the next section."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:42
# 6be8835f5b5844c5902ec7790212ade3
msgid "If you are creating a new build system base class, you should inherit from ``PackageBase``. This is the superclass for all build systems in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:50
# a36479625c7442fd9f871f84b322822f
msgid "The most important concept in Spack's build system support is the idea of phases. Each build system defines a set of phases that are necessary to install the package. They usually follow some sort of \"configure\", \"build\", \"install\" guideline, but any of those phases may be missing or combined with another phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:56
# 03ecb093dc5d4ad8bfa3b0a75e7ac4f8
msgid "If you look at the ``perl`` package, you'll see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:62
# e080d5a1345c4e209eff2f7cfe9fc8a1
msgid "Similarly, ``cmake`` defines:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:68
# c3befeb78f904beb9fe3c7f2c865f545
msgid "If we look at the ``cmake`` example, this tells Spack's ``PackageBase`` class to run the ``bootstrap``, ``build``, and ``install`` functions in that order. It is now up to you to define these methods."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:74
# 7a4683278c704abcb7877d2d7fb3173b
msgid "Phase and phase_args functions"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:76
# abedfa76f3344665bb6101a8c2611f25
msgid "If we look at ``perl``, we see that it defines a ``configure`` method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:84
# cd75e47550684c369bb623883b20346f
msgid "There is also a corresponding ``configure_args`` function that handles all of the arguments to pass to ``Configure``, just like in ``AutotoolsPackage``. Comparatively, the ``build`` and ``install`` phases are pretty simple:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:97
# 7b77c650273b468f919c5a40c0490af4
msgid "The ``cmake`` package looks very similar, but with a ``bootstrap`` function instead of ``configure``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:112
# e9b54c6d1dba483383d2434a7df99bad
msgid "Again, there is a ``boostrap_args`` function that determines the correct bootstrap flags to use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:117
# b3a6329596a446a7a75a8ecb949e050e
msgid "run_before/run_after"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:119
# a172ce4efade4aebb1927715e1599075
msgid "Occasionally, you may want to run extra steps either before or after a given phase. This applies not just to custom build systems, but to existing build systems as well. You may need to patch a file that is generated by configure, or install extra files in addition to what ``make install`` copies to the installation prefix. This is where ``@run_before`` and ``@run_after`` come in."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:126
# 7f412d82c7f2467d904d325e0564b079
msgid "These Python decorators allow you to write functions that are called before or after a particular phase. For example, in ``perl``, we see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:142
# d89d3d10d3b148159512553f331536b3
msgid "This extra step automatically installs ``cpanm`` in addition to the base Perl installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:147
# 95287a62eb8c4440ab04ca3dd9bb689b
msgid "on_package_attributes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:149
# fb919f753ab04648bf3a9680ed11b30f
msgid "The ``run_before``/``run_after`` logic discussed above becomes particularly powerful when combined with the ``@on_package_attributes`` decorator. This decorator allows you to conditionally run certain functions depending on the attributes of that package. The most common example is conditional testing. Many unit tests are prone to failure, even when there is nothing wrong with the installation. Unfortunately, non-portable unit tests and tests that are \"supposed to fail\" are more common than we would like. Instead of always running unit tests on installation, Spack lets users conditionally run tests with the ``--test=root`` flag."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:160
# b01390e6809e4210bd8eb8ef9e9092e2
msgid "If we wanted to define a function that would conditionally run if and only if this flag is set, we would use the following line:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:171
# 6741bcbad6944f4191fbdf119e3bf4a9
msgid "Let's put everything together and add unit tests to our package. In the ``perl`` package, we can see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:181
# 4352b2ca31b34437acc02cc16a6336a6
msgid "As you can guess, this runs ``make test`` *after* building the package, if and only if testing is requested. Again, this is not specific to custom build systems, it can be added to existing build systems as well."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:185
# 7b6a79c96e3d4afdab4b5796b39826b2
msgid "Ideally, every package in Spack will have some sort of test to ensure that it was built correctly. It is up to the package authors to make sure this happens. If you are adding a package for some software and the developers list commands to test the installation, please add these tests to your ``package.py``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:193
# 4752cc11b2b7441dabed4d58ca03612e
msgid "The order of decorators matters. The following ordering:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:200
# 48f10a88d149452eb32f717c5e29e2f1
msgid "works as expected. However, if you reverse the ordering:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:207
# a0cf967fb326402ab15ef6cc0ed48c09
msgid "the tests will always be run regardless of whether or not ``--test=root`` is requested. See https://github.com/spack/spack/issues/3833 for more information"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:10
# 11c42f60f6fd4895830df24cc1dba325
msgid "IntelPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:12
# 67317f7defd04f858466f39abf567ceb
msgid "Contents"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:16
# 44bb4692c80d4654852b5e011c1afac8
msgid "Intel packages in Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:18
# a840c1a5b7574df7a55d78dc2a239cfc
msgid "Spack can install and use several software development products offered by Intel. Some of these are available under no-cost terms, others require a paid license. All share the same basic steps for configuration, installation, and, where applicable, license management. The Spack Python class ``IntelPackage`` implements these steps."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:24
# bad9b880bcc14b3a8961ba701bf65e90
msgid "Spack interacts with Intel tools in several routes, like it does for any other package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:29
# 6634c31215934cc3ad488146562f8570
msgid "Accept system-provided tools after you declare them to Spack as *external packages*."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:33
# 60ca7d2755e4413b9956763c1ff1b811
msgid "Install the products for you as *internal packages* in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:37
# 4b305ad8035f44269cae8fca73f91528
msgid "*Use* the packages, regardless of installation route, to install what we'll call *client packages* for you, this being Spack's primary purpose."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:40
# 57e3cd99429c447ba71a2e15c3a567cb
msgid "An auxiliary route follows from route 2, as it would for most Spack packages, namely:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:45
# a5c2c5b2d95b4b2ca6f85225664f00de
msgid "Make Spack-installed Intel tools available outside of Spack for ad-hoc use, typically through Spack-managed modulefiles."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:48
# ef2d54e3be764fb0ba002cc2bd3eb676
msgid "This document covers routes 1 through 3."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:53
# b2f4b31ff2f54c5399385ea610ee5aae
msgid "Packages under no-cost license"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:55
# 9ab3bbfc0ffa4dd8937d7caa7fbf2944
msgid "Intel's standalone performance library products, notably MKL and MPI, are available for use under a `simplified license <https://software.intel.com/en-us/license/intel-simplified-software-license>`_ since 2017 [fn1]_. They are packaged in Spack as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:60
# b0b5f14e7eb7420aa5172b3a65223e50
msgid "``intel-mkl`` -- Math Kernel Library (linear algebra and FFT),"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:61
# a6cdc3d5ccec4eb78c8ab0a46216ffb7
msgid "``intel-mpi`` -- The Intel-MPI implementation (derived from MPICH),"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:62
# 931c5b7fe4464c97aa3ea275b7c6caea
msgid "``intel-ipp`` -- Primitives for image-, signal-, and data-processing,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:63
# 0dfff00cf426403d9f9e53113780f27e
msgid "``intel-daal`` -- Machine learning and data analytics."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:65
# 7c34edd8df264041af5f76ccef5652bb
msgid "Some earlier versions of these libraries were released under a paid license. For these older versions, the license must be available at installation time of the products and during compilation of client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:69
# 30813635b7604cb8a60c896ca3200ced
msgid "The library packages work well with the Intel compilers but do not require them -- those packages can just as well be used with other compilers.  The Intel compiler invocation commands offer custom options to simplify linking Intel libraries (sometimes considerably), but Spack always uses fairly explicit linkage anyway."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:78
# 8c345b7f524345b099be574364037910
msgid "Licensed packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:80
# f48b495b17984030bdb148e8c9123b55
msgid "Intel's core software development products that provide compilers, analyzers, and optimizers do require a paid license.  In Spack, they are packaged as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:83
# c3351f103b514dba9c1f87228567da04
msgid "``intel-parallel-studio`` -- the entire suite of compilers and libraries,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:84
# 14d3a1e94b0f4f359fdb056eb5c6ba2d
msgid "``intel`` -- a subset containing just the compilers and the Intel-MPI runtime [fn2]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:97
# 42c766ca804c4b02a6426ded4723a512
msgid "The license is needed at installation time and to compile client packages, but never to merely run any resulting binaries. The license status for a given Spack package is normally specified in the *package code* through directives like `license_required` (see :ref:`Licensed software <license>`). For the Intel packages, however, the *class code* provides these directives (in exchange of forfeiting a measure of OOP purity) and takes care of idiosyncasies like historic version dependence."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:105
# 6a13760370da4d27a28926a71ee67068
msgid "The libraries that are provided in the standalone packages are also included in the all-encompassing ``intel-parallel-studio``. To complicate matters a bit, that package is sold in 3 \"editions\", of which only the upper-tier ``cluster`` edition supports *compiling* MPI applications, and hence only that edition can provide the ``mpi`` virtual package.  (As mentioned [fn2]_, all editions provide support for *running* MPI applications.)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:112
# 07a3991507a7406ca2b5aabb5b47c096
msgid "The edition forms the leading part of the version number for Spack's ``intel*`` packages discussed here. This differs from the primarily numeric version numbers seen with most other Spack packages. For example, we have:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:133
# 3642b3c7c2bf4e5c8ba391634ab44258
msgid "The full studio suite, capable of compiling MPI applications, currently requires about 12 GB of disk space when installed (see section `Install steps for packages with compilers and libraries`_ for detailed instructions). If you need to save disk space or installation time, you could install the ``intel`` compilers-only subset (0.6 GB) and just the library packages you need, for example ``intel-mpi`` (0.5 GB) and ``intel-mkl`` (2.5 GB)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:143
# 666ac53a4f7749a2a97b953dd3bdd819
msgid "Unrelated packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:145
# d80386286fa5408bb20dd0783e5553e1
msgid "The following packages do not use the Intel installer and are not in class ``IntelPackage`` that is discussed here:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:148
# e26a809ac1cb4ebfb76861668b51b19d
msgid "``intel-gpu-tools`` -- Test suite and low-level tools for the Linux `Direct Rendering Manager <https://en.wikipedia.org/wiki/Direct_Rendering_Manager>`_"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:150
# 4f4bd1c5a5fa4dd69d0d5d590c3d3a21
msgid "``intel-mkl-dnn`` -- Math Kernel Library for Deep Neural Networks (``CMakePackage``)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:151
# 7a9c254ccd694009a3df4aa602eaedf5
msgid "``intel-xed`` -- X86 machine instructions encoder/decoder"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:152
# 564e9e9783544f17b1150d0af0963fbe
msgid "``intel-tbb`` -- Standalone version of Intel Threading Building Blocks. Note that a TBB runtime version is included with ``intel-mkl``, and development versions are provided by the packages ``intel-parallel-studio`` (all editions) and its ``intel`` subset."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:159
# a31c4158a49f41ae9eda9db18fdbf063
msgid "Configuring Spack to use Intel licenses"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:161
# 70f22aae22f94247aeeea858a00b4cf4
msgid "If you wish to integrate licensed Intel products into Spack as external packages (`route 1`_ above) we assume that their license configuration is in place and is working [fn3]_. In this case, skip to section `Integration of Intel tools installed external to Spack`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:166
# a160ae17917a4579bfc2ac284fc4d8cf
msgid "If you plan to have Spack install licensed products for you (`route 2`_ above), the Intel product installer that Spack will run underneath must have access to a license that is either provided by a *license server* or as a *license file*. The installer may be able to locate a license that is already configured on your system.  If it cannot, you must configure Spack to provide either the server location or the license file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:173
# 0f50623e48834d4686e91feef40fbbe8
msgid "For authoritative information on Intel licensing, see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:175
# 92a3688da2f243d7bc1c53363becbecc
msgid "https://software.intel.com/en-us/faq/licensing"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:176
# 370b07c8c2824840aa8f1125dc5c8c9d
msgid "https://software.intel.com/en-us/articles/how-do-i-manage-my-licenses"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:180
# eca8d39682d14e0dbf31ecb15a3b2de1
msgid "Pointing to an existing license server"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:182
# 20fd4ad567e345238a416bad38400fa7
msgid "Installing and configuring a license server is outside the scope of Spack. We assume that:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:185
# c428d87317c34d399f12e41291d8e6dc
msgid "Your system administrator has a license server running."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:186
# 55c5c2ef92b84e889af6c61101f90d64
msgid "The license server offers valid licenses for the Intel packages of interest."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:187
# e97cc81a166b4bfaa77122b566f6e1a6
msgid "You can access these licenses under the user id running Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:189
# 9de87c54ae76492885a1116393c070b5
msgid "Be aware of the difference between (a) installing and configuring a license server, and (b) configuring client software to *use* a server's so-called floating licenses.  We are concerned here with (b) only. The process of obtaining a license from a server for temporary use is called \"checking out a license\".  For that, a client application such as the Intel package installer or a compiler needs to know the host name and port number of one or more license servers that it may query [fn4]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:197
# 56188e445f974f8692610f578cd225d2
msgid "Follow one of three methods to `point client software to a floating license server <https://software.intel.com/en-us/articles/licensing-setting-up-the-client-floating-license>`_. Ideally, your license administrator will already have implemented one that can be used unchanged in Spack: Look for the environment variable ``INTEL_LICENSE_FILE`` or for files ``/opt/intel/licenses/*.lic`` that contain::"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:207
# f278bcfd169f40bbb059bf81eb4f3378
msgid "The relevant tokens, among possibly others, are the ``USE_SERVER`` line, intended specifically for clients, and one or more ``SERVER`` lines above it which give the network address."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:211
# 4469ae91866b46879c5fa9a034065232
msgid "If you cannot find pre-existing ``/opt/intel/licenses/*.lic`` files and the ``INTEL_LICENSE_FILE`` environment variable is not set (even after you loaded any relevant modulefiles), ask your license administrator for the server address(es) and place them in a \"global\" license file within your Spack directory tree `as shown below <Spack-managed file_>`_)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:220
# 4f5ea6f9b9174cb5a4c6133566896acd
msgid "Installing a standalone license file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:222
# 8b30cd3788d44fdc9cc181a1377a9517
msgid "If you purchased a user-specific license, follow `Intel's instructions <https://software.intel.com/en-us/faq/licensing#license-management>`_ to \"activate\" it for your serial number, then download the resulting license file. If needed, `request to have the file re-sent <https://software.intel.com/en-us/articles/resend-license-file>`_ to you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:228
# d854ccbe48be442798f83bf790af62b8
msgid "Intel's license files are text files that contain tokens in the proprietary \"FLEXlm\" format and whose name ends in ``.lic``. Intel installers and compilers look for license files in several locations when they run. Place your license by one of the following means, in order of decreasing preference:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:233
# 75420e963b3448979dd70810d8015ad7
msgid "Default directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:235
# 9b51365f009e4a6abe0808558bfa8ab7
msgid "Install your license file in the directory ``/opt/intel/licenses/`` if you have write permission to it. This directory is inspected by all Intel tools and is therefore preferred, as no further configuration will be needed. Create the directory if it does not yet exist.  For the file name, either keep the downloaded name or use another suitably plain yet descriptive name that ends in ``.lic``. Adjust file permissions for access by licensed users."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:244
# a3b18963eadd4a83925bce9b56592879
msgid "Directory given in environment variable"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:246
# 3521f517b3654c30a9fc506f275c27a1
msgid "If you cannot use the default directory, but your system already has set the environment variable ``INTEL_LICENSE_FILE`` independent from Spack [fn5]_, then, if you have the necessary write permissions, place your license file in one of the directories mentioned in this environment variable.  Adjust file permissions to match licensed users."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:254
# b0b43a6a7a2b46d3becf6dfdaef288c7
msgid "If your system has not yet set and used the environment variable ``INTEL_LICENSE_FILE``, you could start using it with the ``spack install`` stage of licensed tools and subsequent client packages. You would, however, be in a bind to always set that variable in the same manner, across updates and re-installations, and perhaps accommodate additions to it. As this may be difficult in the long run, we recommend that you do *not* attempt to start using the variable solely for Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:264
# 826b0c82398249e99ea6ae9a3564c3c2
msgid "Spack-managed file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:266
# 005a82f537ce4ac3b5263d451590ee3c
msgid "The first time Spack encounters an Intel package that requires a license, it will initialize a Spack-global Intel-specific license file for you, as a template with instructional comments, and bring up an editor [fn6]_.  Spack will do this *even if you have a working license elsewhere* on the system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:271
# 6f44fffcb48448378b5fe9f0fb825461
msgid "To proceed with an externally configured license, leave the newly templated file as is (containing comments only) and close the editor. You do not need to touch the file again."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:275
# c9a221d1d5fa4f588e3c16e302605643
msgid "To configure your own standalone license, copy the contents of your downloaded license file into the opened file, save it, and close the editor."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:278
# 465aa6975dca4530841e89d70b6f4041
msgid "To use a license server (i.e., a floating network license) that is not already configured elsewhere on the system, supply your license server address(es) in the form of ``SERVER`` and ``USE_SERVER`` lines at the *beginning of the file* [fn7]_, in the format shown in section `Pointing to an existing license server`_. Save the file and close the editor."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:284
# c2714d8691574c81bad3fe40550b4519
msgid "To revisit and manually edit this file, such as prior to a subsequent installation attempt, find it at ``$SPACK_ROOT/etc/spack/licenses/intel/intel.lic`` ."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:288
# a7ea096019e6451a8a0f063cb511d3fe
msgid "Spack will place symbolic links to this file in each directory where licensed Intel binaries were installed.  If you kept the template unchanged, Intel tools will simply ignore it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:297
# 81770e4dcaf24ea5bc97fb071cb95354
msgid "Integration of Intel tools installed *external* to Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:299
# 20e9f35177a641728ef3c07e8433925d
msgid "This section discusses `route 1`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:301
# 7b3c9a40c70f4cfa9222b1eddeed1e69
msgid "A site that already uses Intel tools, especially licensed ones, will likely have some versions already installed on the system, especially at a time when Spack is just being introduced. It will be useful to make such previously installed tools available for use by Spack as they are. How to do this varies depending on the type of the tools:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:309
# 1a1b2268e98f46b99a4c0a10e7449326
msgid "Integrating external compilers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:311
# 8f7a5989ca1742ee8b8a7b97b3a6cb9c
msgid "For Spack to use external Intel compilers, you must tell it both *where* to find them and *when* to use them.  The present section documents the \"where\" aspect, involving ``compilers.yaml`` and, in most cases, long absolute paths. The \"when\" aspect actually relates to `route 3`_ and requires explicitly stating the compiler as a spec component (in the form ``foo %intel`` or ``foo %intel@compilerversion``) when installing client packages or altering Spack's compiler default in ``packages.yaml``. See section `Selecting Intel compilers <Selecting Intel compilers_>`_ for details."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:320
# 3b7f0ddacb1a423eb96619970104e272
msgid "To integrate a new set of externally installed Intel compilers into Spack follow section :ref:`Compiler configuration <compiler-config>`. Briefly, prepare your shell environment like you would if you were to use these compilers normally, i.e., typically by a ``module load ...`` or a shell ``source ...`` command, then use ``spack compiler find`` to make Spack aware of these compilers.  This will create a new entry in a suitably scoped and possibly new ``compilers.yaml`` file. You could certainly create such a compiler entry manually, but this is error-prone due to the indentation and different data types involved."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:331
# c6e3086ac29644b0b83ca891dd4d7fc1
msgid "The Intel compilers need and use the system's native GCC compiler (``gcc`` on most systems, ``clang`` on macOS) to provide certain functionality, notably to support C++. To provide a different GCC compiler for the Intel tools, or more generally set persistent flags for all invocations of the Intel compilers, locate the ``compilers.yaml`` entry that defines your Intel compiler, and, using a text editor, change one or both of the following:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:338
# 020e26d4d143486890d17e8779702187
msgid "At the ``modules:`` tag, add a ``gcc`` module to the list."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:339
# 286805d16e994c3585ee37aafd56c6b2
msgid "At the ``flags:`` tag, add ``cflags:``, ``cxxflags:``, and ``fflags:`` key-value entries."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:341
# d3f9031384274041b35423a44dc0429f
msgid "Consult the examples under :ref:`Compiler configuration <compiler-config>` and :ref:`Vendor-Specific Compiler Configuration <vendor-specific-compiler-configuration>` in the Spack documentation. When done, validate your compiler definition by running ``spack compiler info intel@compilerversion`` (replacing ``compilerversion`` by the version that you defined)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:350
# f5464442212b499ebecb2d51bdac701b
msgid "Be aware that both the GCC integration and persistent compiler flags can also be affected by an advanced third method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:353
# 4c2cc5a5bbec4824be37598c3468d275
msgid "A modulefile that provides the Intel compilers for you could, for the benefit of users outside of Spack, implicitly integrate a specific ``gcc`` version via compiler flag environment variables or (hopefully not) via a sneaky extra ``PATH`` addition."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:358
# aa23b9ff2a9645ffbad80490cd0f7322
msgid "Next, visit section `Selecting Intel Compilers`_ to learn how to tell Spack to use the newly configured compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:363
# afb98e5c5cfc42218dbf626555add891
msgid "Integrating external libraries"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:365
# 3c4fa3e028814dec9efd42fc3f869de4
msgid "Configure external library-type packages (as opposed to compilers) in the files ``$SPACK_ROOT/etc/spack/packages.yaml`` or ``~/.spack/packages.yaml``, following the Spack documentation under :ref:`External Packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:370
# f70dc1f9bbd245d48901499d28ddd204
msgid "Similar to ``compilers.yaml``, the ``packages.yaml`` files define a package external to Spack in terms of a Spack spec and resolve each such spec via either the ``paths`` or ``modules`` tokens to a specific pre-installed package version on the system.  Since Intel tools generally need environment variables to interoperate, which cannot be conveyed in a mere ``paths`` specification, the ``modules`` token will be more sensible to use. It resolves the Spack-side spec to a modulefile generated and managed outside of Spack's purview, which Spack will load internally and transiently when the corresponding spec is called upon to compile client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:380
# c4c17e47626e44a990514f48249eeaaf
msgid "Unlike for compilers, where ``spack find compilers [spec]`` generates an entry in an existing or new ``compilers.yaml`` file, Spack does not offer a command to generate an entirely new ``packages.yaml`` entry.  You must create new entries yourself in a text editor, though the command ``spack config [--scope=...] edit packages`` can help with selecting the proper file. See section :ref:`Configuration Scopes <configuration-scopes>` for an explanation about the different files and section :ref:`Build customization <build-settings>` for specifics and examples for ``packages.yaml`` files."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:400
# 3ef45cff4f3d4351a1f68a127412b226
msgid "The following example integrates packages embodied by hypothetical external modulefiles ``intel-mkl/18/...`` into Spack as packages ``intel-mkl@...``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:408
# bab820f94a524fa4a2b4ae68bd67ecdf
msgid "Make sure the file begins with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:414
# 16e3aa67416a485f847cbff1ac5e153e
msgid "Adapt the following example. Be sure to maintain the indentation:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:425
# 50f5a40fadbb498f8787e032d50b2331
msgid "The version numbers for the ``intel-mkl`` specs defined here correspond to file and directory names that Intel uses for its products because they were adopted and declared as such within Spack's package repository. You can inspect the versions known to your current Spack installation by:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:434
# e55471c9a5d14fadbef5594166aa26ef
msgid "Using the same version numbers for external packages as for packages known internally is useful for clarity, but not strictly necessary.  Moreover, with a ``packages.yaml`` entry, you can go beyond internally known versions."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:440
# 87fb39029c8e46c2ae7be59586d941dd
msgid "Note that the Spack spec in the example does not contain a compiler specification. This is intentional, as the Intel library packages can be used unmodified with different compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:444
# 19c513987d364e289daeb1836e444819
msgid "A slightly more advanced example illustrates how to provide :ref:`variants <basic-variants>` and how to use the ``buildable: False`` directive to prevent Spack from installing other versions or variants of the named package through its normal internal mechanism."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:459
# 30b42c89dba34869a3f9b0c91e6a9c46
msgid "One additional example illustrates the use of ``paths:`` instead of ``modules:``, useful when external modulefiles are not available or not suitable:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:472
# cfd922eef2a944498130d3eabd85fb67
msgid "Note that for the Intel packages discussed here, the directory values in the ``paths:`` entries must be the high-level and typically version-less \"installation directory\" that has been used by Intel's product installer. Such a directory will typically accumulate various product versions.  Amongst them, Spack will select the correct version-specific product directory based on the ``@version`` spec component that each path is being defined for."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:479
# a06f8be804f24d9d9d89554c79eacf4b
msgid "For further background and details, see :ref:`External Packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:485
# 33463a0075134287b3cd4ed0f9bcca62
msgid "Installing Intel tools *within* Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:487
# c96d5a20848b4fc39716efa3077c2857
msgid "This section discusses `route 2`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:489
# c74d2f0166474003acc3cfdbdd44d8c0
msgid "When a system does not yet have Intel tools installed already, or the installed versions are undesirable, Spack can install these tools like any regular Spack package for you and, with appropriate pre- and post-install configuration, use its compilers and/or libraries to install client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:498
# f17fa5d2e00b4038a0cfd448a5d5b590
msgid "Install steps for packages with compilers and libraries"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:500
# e5931547bd5c49f08b4ba31eb06bd597
msgid "The packages ``intel-parallel-studio`` and ``intel`` (which is a subset of the former) are many-in-one products that contain both compilers and a set of library packages whose scope depends on the edition. Because they are general products geared towards shell environments, it can be somewhat involved to integrate these packages at their full extent into Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:507
# 6ec27e41ea964dea957ba37dd3e76a73
msgid "Note: To install library-only packages like ``intel-mkl``, ``intel-mpi``, and ``intel-daal`` follow `the next section <intel-install-libs_>`_ instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:510
# a80768b849644d38ad4fe7480e0ba2ff
msgid "Review the section `Configuring spack to use intel licenses`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:514
# 72fe4d37d55741c3a934a1e11f6e0dd3
msgid "To install a version of ``intel-parallel-studio`` that provides Intel compilers at a version that you have *not yet declared in Spack*, the following preparatory steps are recommended:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:518
# be5e40d94ee64d90af2a3b98494f8c9f
msgid "Determine the compiler spec that the new ``intel-parallel-studio`` package will provide, as follows: From the package version, combine the last two digits of the version year, a literal \"0\" (zero), and the version component that immediately follows the year."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:524
# 3914ca7d9781402db95156ad5a1d6532
msgid "Package version"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:524
# 254808819c26457384eed1597b26cbba
msgid "Compiler spec provided"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:526
# b69e36168687455abd01c61450a14293
msgid "``intel-parallel-studio@edition.YYyy.u``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:526
# 37075ad5a3db48268f0365d11756f256
msgid "``intel@yy.0.u``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:529
# 46fb13b40d354a1d889a670dc0f2060d
msgid "Example: The package ``intel-parallel-studio@cluster.2018.3`` will provide the compiler with spec ``intel@18.0.3``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:534
# 00355781ada949718d201a465e878873
msgid "Add a new compiler section with the newly anticipated version at the end of a ``compilers.yaml`` file in a suitable scope.  For example, run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:541
# b5e364f700aa4a67825b6940b309dc49
msgid "and append a stub entry:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:556
# c8d905d934634b2f834edb8011362079
msgid "Replace ``18.0.3`` with the version that you determined in the preceeding step. The contents under ``paths:`` do not matter yet."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:559
# 912e57c784ba407799789c252bf6165b
msgid "You are right to ask: \"Why on earth is that necessary?\" [fn8]_. The answer lies in Spack striving for strict compiler consistency. Consider what happens without such a pre-declared compiler stub: Say, you ask Spack to install a particular version ``intel-parallel-studio@edition.V``.  Spack will apply an unrelated compiler spec to concretize and install your request, resulting in ``intel-parallel-studio@edition.V %X``. That compiler ``%X`` is not going to be the version that this new package itself provides. Rather, it would typically be ``%gcc@...`` in a default Spack installation or possibly indeed ``%intel@...``, but at a version that precedes ``V``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:570
# 7674623f4b3b4fb49021402ac69432a1
msgid "The problem comes to the fore as soon as you try to use any virtual ``mkl`` or ``mpi`` packages that you would expect to now be provided by ``intel-parallel-studio@edition.V``.  Spack will indeed see those virtual packages, but only as being tied to the compiler that the package ``intel-parallel-studio@edition.V`` was concretized with *at installation*. If you were to install a client package with the new compilers now available to you, you would naturally run ``spack install foo +mkl %intel@V``, yet Spack will either complain about ``mkl%intel@V`` being missing (because it only knows about ``mkl%X``) or it will go and attempt to install *another instance* of ``intel-parallel-studio@edition.V %intel@V`` so as to match the compiler spec ``%intel@V`` that you gave for your client package ``foo``. This will be unexpected and will quickly get annoying because each reinstallation takes up time and extra disk space."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:584
# 61fe726a8d434aa78c229449e2946cc4
msgid "To escape this trap, put the compiler stub declaration shown here in place, then use that pre-declared compiler spec to install the actual package, as shown next.  This approach works because during installation only the package's own self-sufficient installer will be used, not any compiler."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:591
# e562cbd1c2e74438bc4d201c555367dc
msgid "Verify that the compiler version provided by the new ``studio`` version would be used as expected if you were to compile a client package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:598
# 8623622b3c02405dae36a3a006dfce03
msgid "If the version does not match, explicitly state the anticipated compiler version, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:604
# 7bcdd66ba6cd4bad89d6ad7d3489d9f0
msgid "if there are problems, review and correct the compiler's ``compilers.yaml`` entry, be it still in stub form or already complete (as it would be for a re-installation)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:608
# 1e18a07ab28043d497965edf3084a97c
msgid "Install the new ``studio`` package using Spack's regular ``install`` command. It may be wise to provide the anticipated compiler (`see above <verify-compiler-anticipated_>`_) as an explicit concretization element:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:618
# ceac119d421a487680731b5678758c4b
msgid "Follow the same steps as under `Integrating external compilers`_ to tell Spack the minutiae for actually using those compilers with client packages. If you placed a stub entry in a ``compilers.yaml`` file, now is the time to edit it and fill in the particulars."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:623
# afe23f2f04c74b8fbd49a2d6a488997e
msgid "Under ``paths:``, give the full paths to the actual compiler binaries (``icc``, ``ifort``, etc.) located within the Spack installation tree, in all their unsightly length [fn9]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:627
# f02afef7b5464c70850f21107a3df982
msgid "To determine the full path to the C compiler, adapt and run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:634
# 0e6fb47975ce4d45ad879538dd30f712
msgid "If you get hits for both ``intel64`` and ``ia32``, you almost certainly will want to use the ``intel64`` variant.  The ``icpc`` and ``ifort`` compilers will be located in the same directory as ``icc``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:638
# b5141ecf3d094eaa8bdd4d85b5aabf87
msgid "Use the ``modules:`` and/or ``cflags:`` tokens to specify a suitable accompanying ``gcc`` version to help pacify picky client packages that ask for C++ standards more recent than supported by your system-provided ``gcc`` and its ``libstdc++.so``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:643
# 51a06abf6d9d4304939e7cb0f524956b
msgid "To set the Intel compilers for default use in Spack, instead of the usual ``%gcc``, follow section `Selecting Intel compilers`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:648
# efd0e834054042489c5869ebecff57cd
msgid "Compiler packages like ``intel-parallel-studio`` can easily be above 10 GB in size, which can tax the disk space available for temporary files on small, busy, or restricted systems (like virtual machines). The Intel installer will stop and report insufficient space as::"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:658
# d3d28867d36d4b77acd3ffa4879f5bea
msgid "As first remedy, clean Spack's existing staging area:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:664
# 58667019fe9f4d7489bc57b7005ca370
msgid "then retry installing the large package. Spack normally cleans staging directories but certain failures may prevent it from doing so."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:667
# 9e030588702f4dc295c91083564c25fd
msgid "If the error persists, tell Spack to use an alternative location for temporary files:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:670
# d51aa613829b4d03a1cc4f9897023419
msgid "Run ``df -h`` to identify an alternative location on your system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:672
# 767a8c9a92984e9ba68cf7f9ccc25d8e
msgid "Tell Spack to use that location for staging. Do **one** of the following:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:674
# fc10885e5e4844d9a685a82067fa588f
msgid "Run Spack with the environment variable ``TMPDIR`` altered for just a single command. For example, to use your ``$HOME`` directory:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:681
# 16b635cf281344f28d81a86c6dd1b7c0
msgid "This example uses Bourne shell syntax. Adapt for other shells as needed."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:683
# e6c9894db3eb40bd9962d49b4ee5eaab
msgid "Alternatively, customize Spack's ``build_stage`` :ref:`configuration setting <config-overrides>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:690
# ab04fffc597443ae877111535b76fc23
msgid "Append:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:698
# 908668cd8a4e45068f7142e606e23b93
msgid "Do not duplicate the ``config:`` line if it already is present. Adapt the location, which here is the same as in the preceeding example."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:701
# eb2b458e47a4455c88cf143544614523
msgid "Retry installing the large package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:708
# 11467f3027934339912f1c99f8d53205
msgid "Install steps for library-only packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:710
# 276d0602a8854d1996cd9d6bde30e441
msgid "To install library-only packages like ``intel-mkl``, ``intel-mpi``, and ``intel-daal`` follow the steps given here. For packages that contain a compiler, follow `the previous section <intel-install-studio_>`_ instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:715
# 80365f66ea2442779879ac3ea5317027
msgid "For pre-2017 product releases, review the section `Configuring Spack to use Intel licenses`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:717
# 92770e6129f948a7a65c6d63531c382d
msgid "Inspect the package spec. Specify an explicit compiler if necessary, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:724
# 6848c4f2db7742678c6db68c5237b17b
msgid "Check that the package will use the compiler flavor and version that you expect."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:726
# b6a8d4d7b54745baac54c7a51ae17175
msgid "Install the package normally within Spack. Use the same spec as in the previous command, i.e., as general or as specific as needed:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:734
# 328c6b144ccd43a892a09cc635c939fa
msgid "To prepare the new packages for use with client packages, follow `Selecting libraries to satisfy virtual packages`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:740
# 112449bedbf34d829bace9d411108dfb
msgid "Debug notes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:742
# a0af13c7ab7246a79b7384fbd197b96f
msgid "You can trigger a wall of additional diagnostics using Spack options, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:748
# 8bf687dffb2e4bcea7d03b0673ec84a4
msgid "The ``--debug`` option can also be useful while installing client packages `(see below) <Using Intel tools in Spack to install client packages_>`_ to confirm the integration of the Intel tools in Spack, notably MKL and MPI."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:753
# 05cdbae8d2df4b6fb8af848d1d27554b
msgid "The ``.spack/`` subdirectory of an installed ``IntelPackage`` will contain, besides Spack's usual archival items, a copy of the ``silent.cfg`` file that was passed to the Intel installer:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:762
# e10c6180fa5c40dd9735eee9164f8f8d
msgid "If an installation error occurs, Spack will normally clean up and remove a partially installed target directory. You can direct Spack to keep it using ``--keep-prefix``, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:770
# 1a1872599e5a4874842e4253fde92d35
msgid "You must, however, *remove such partial installations* prior to subsequent installation attempts. Otherwise, the Intel installer will behave incorrectly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:777
# a8d1d3ce89044c01a70ceb3176c07f96
msgid "Using Intel tools in Spack to install client packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:779
# 1b2043227dc54e249fc7eee6a5110198
msgid "Finally, this section pertains to `route 3`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:781
# 79f90ef172854ed38cf45b62eecf0971
msgid "Once Intel tools are installed within Spack as external or internal packages they can be used as intended for installing client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:789
# c9243d1439574987ba48c7c2102a3bc3
msgid "Selecting Intel compilers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:791
# 1f3a1107051b4cf582940e56700b0504
msgid "Select Intel compilers to compile client packages, like any compiler in Spack, by one of the following means:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:794
# 512c965492c6429c9c36253f87c7d597
msgid "Request the Intel compilers explicitly in the client spec, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:801
# a7d70f6223cf4df9a0843826359f0682
msgid "Alternatively, request Intel compilers implicitly by concretization preferences. Configure the order of compilers in the appropriate ``packages.yaml`` file, under either an ``all:`` or client-package-specific entry, in a ``compiler:`` list. Consult the Spack documentation for :ref:`Configuring Package Preferences <configs-tutorial-package-prefs>` and :ref:`Concretization Preferences <concretization-preferences>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:809
# 9a70650ef1f945a98478c1981240842f
msgid "Example: ``etc/spack/packages.yaml`` might simply contain:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:817
# 1da79e24848b45ceb92302023256a20d
msgid "To be more specific, you can state partial or full compiler version numbers, for example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:830
# e4b21d2c1fca489198cdb22fceabab8f
msgid "Selecting libraries to satisfy virtual packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:832
# 63b2f6e5aa1743ec9dbb50f3da95233e
msgid "Intel packages, whether integrated into Spack as external packages or installed within Spack, can be called upon to satisfy the requirement of a client package for a library that is available from different providers. The relevant virtual packages for Intel are ``blas``, ``lapack``, ``scalapack``, and ``mpi``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:838
# c644732307684b6cb11e12740a319430
msgid "In both integration routes, Intel packages can have optional :ref:`variants <basic-variants>` which alter the list of virtual packages they can satisfy.  For Spack-external packages, the active variants are a combination of the defaults declared in Spack's package repository and the spec it is declared as in ``packages.yaml``. Needless to say, those should match the components that are actually present in the external product installation. Likewise, for Spack-internal packages, the active variants are determined, persistently at installation time, from the defaults in the repository and the spec selected to be installed."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:848
# e96b77f6d8f94dcd89c4916d003804c3
msgid "To have Intel packages satisfy virtual package requests for all or selected client packages, edit the ``packages.yaml`` file.  Customize, either in the ``all:`` or a more specific entry, a ``providers:`` dictionary whose keys are the virtual packages and whose values are the Spack specs that satisfy the virtual package, in order of decreasing preference.  To learn more about the ``providers:`` settings, see the Spack tutorial for :ref:`Configuring Package Preferences <configs-tutorial-package-prefs>` and the section :ref:`Concretization Preferences <concretization-preferences>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:858
# 2109104233b3444b9cbe04adeaf88be3
msgid "Example: The following fairly minimal example for ``packages.yaml`` shows how to exclusively use the standalone ``intel-mkl`` package for all the linear algebra virtual packages in Spack, and ``intel-mpi`` as the preferred MPI implementation. Other providers can still be chosen on a per-package basis."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:873
# b7d4511eb0c544c59a84cac841085f01
msgid "If you have access to the ``intel-parallel-studio@cluster`` edition, you can use instead:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:886
# 54616c05167d4fe3a415819cd2c443ae
msgid "If you installed ``intel-parallel-studio`` within Spack (\"`route 2`_\"), make sure you followed the `special installation step <intel-compiler-anticipation_>`_ to ensure that its virtual packages match the compilers it provides."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:894
# 0bd80daedf324dcaad92ab44fc63d81f
msgid "Using Intel tools as explicit dependency"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:896
# 72773814cb694d23a04ccb58cbe650c5
msgid "With the proper installation as detailed above, no special steps should be required when a client package specifically (and thus deliberately) requests an Intel package as dependency, this being one of the target use cases for Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:903
# 5b7cfc2dfbba459ebaf45f8ae99f205a
msgid "Tips for configuring client packages to use MKL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:905
# 87220177fe174a88b3b75b44bc844071
msgid "The Math Kernel Library (MKL) is provided by several Intel packages, currently ``intel-parallel-studio`` when variant ``+mkl`` is active (it is by default) and the standalone ``intel-mkl``. Because of these different provider packages, a *virtual* ``mkl`` package is declared in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:910
# 04c29879fbd842168c979bf50fc68a98
msgid "To use MKL-specific APIs in a client package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:912
# 661876de0fc249b18166875522e0f499
msgid "Declare a dependency on ``mkl``, rather than a specific provider like ``intel-mkl``.  Declare the dependency either absolutely or conditionally based on variants that your package might have declared:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:923
# b3082f78863140b6a25f8da7f6abc1a6
msgid "The ``MKLROOT`` environment variable (part of the documented API) will be set during all stages of client package installation, and is available to both the Spack packaging code and the client code."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:927
# 77ed70bfbd4244f5844341dcc66807a0
msgid "To use MKL as provider for BLAS, LAPACK, or ScaLAPACK:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:929
# 4364ce59c1154de9920e25ae78a9cfe9
msgid "The packages that provide ``mkl`` also provide the narrower virtual ``blas``, ``lapack``, and ``scalapack`` packages. See the relevant :ref:`Packaging Guide section <blas_lapack_scalapack>` for an introduction. To portably use these virtual packages, construct preprocessor and linker option strings in your package configuration code using the package functions ``.headers`` and ``.libs`` in conjunction with utility functions from the following classes:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:938
# 726863264ab0467f97b71447b77679d0
msgid ":py:class:`llnl.util.filesystem.FileList`,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:939
# 793fbb9fb88c4afa9759009ac883c4ea
msgid ":py:class:`llnl.util.filesystem.HeaderList`,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:940
# b91ead1a7a7b44aea40af8c438ebd061
msgid ":py:class:`llnl.util.filesystem.LibraryList`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:943
# 19c6645eb3ff47de95f9eb88fb18f680
msgid "*Do not* use constructs like ``.prefix.include`` or ``.prefix.lib``, with Intel or any other implementation of ``blas``, ``lapack``, and ``scalapack``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:947
# cbdfc8ac962f48d78a590db7fda6531a
msgid "For example, for an :ref:`AutotoolsPackage <autotoolspackage>` use ``.libs.ld_flags`` to transform the library file list into linker options passed to ``./configure``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:962
# 463d8b557a814a658fd53aea75799c44
msgid "Even though ``.ld_flags`` will return a string of multiple words, *do not* use quotes for options like ``--with-blas=...`` because Spack passes them to ``./configure`` without invoking a shell."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:966
# c49be189df8649c493c9dd3a237eb464
msgid "Likewise, in a :ref:`MakefilePackage <makefilepackage>` or similiar package that does not use AutoTools you may need to provide include and link options for use on command lines or in environment variables. For example, to generate an option string of the form ``-I<dir>``, use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:976
# 8540e99b46bb479a863f4d09ce305300
msgid "and to generate linker options (``-L<dir> -llibname ...``), use the same as above,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:982
# 0fd0f18511fc477d89e976dcee809c2f
msgid "See :ref:`MakefilePackage <makefilepackage>` and more generally the :ref:`Packaging Guide <blas_lapack_scalapack>` for background and further examples."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:991
# 48c3e105c5f94a41886fa99e9fde80d8
msgid "Footnotes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:993
# 0f1335cfe85544099c225289ab049cbf
msgid "Strictly speaking, versions from ``2017.2`` onward."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:995
# 79f1cca7e64e4dcb9e260abc84f60cb4
msgid "The package ``intel`` intentionally does not have a ``+mpi`` variant since it is meant to be small. The native installer will always add MPI *runtime* components because it follows defaults defined in the download package, even when ``intel-parallel-studio ~mpi`` has been requested."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1000
# 5b19309a7ff74a8fad8b241e78516261
msgid "For ``intel-parallel-studio +mpi``, the class function :py:func:``.IntelPackage.pset_components`` will include ``\"intel-mpi intel-imb\"`` in a list of component patterns passed to the Intel installer. The installer will extend each pattern word with an implied glob-like ``*`` to resolve it to package names that are *actually present in the product BOM*. As a side effect, this pattern approach accommodates occasional package name changes, e.g., capturing both ``intel-mpirt`` and ``intel-mpi-rt`` ."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1009
# 256c597086da46da8cbe1864e7284b1e
msgid "How could the external installation have succeeded otherwise?"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1011
# 52a4d588df924a53a8cdaa747faa0c94
msgid "According to Intel's documentation, there is supposedly a way to install a product using a network license even `when a FLEXlm server is not running <https://software.intel.com/en-us/articles/licensing-setting-up-the-client-floating-license>`_: Specify the license in the form ``port@serverhost`` in the ``INTEL_LICENSE_FILE`` environment variable. All other means of specifying a network license require that the license server be up."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1018
# f1010c52775041c986188d076a0df635
msgid "Despite the name, ``INTEL_LICENSE_FILE`` can hold several and diverse entries. They  can be either directories (presumed to contain ``*.lic`` files), file names, or network locations in the form ``port@host`` (on Linux and Mac), with all items separated by \":\" (on Linux and Mac)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1023
# a9af4e3cb4184b90b91f8ccb9c0508a7
msgid "Should said editor turn out to be ``vi``, you better be in a position to know how to use it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1026
# 6f8f56c7487c4aa382bf2fa6025bd363
msgid "Comment lines in FLEXlm files, indicated by ``#`` as the first non-whitespace character on the line, are generally allowed anywhere in the file. There `have been reports <https://github.com/spack/spack/issues/6534>`_, however, that as of 2018, ``SERVER`` and ``USE_SERVER`` lines must precede any comment lines."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1037
# 0b163a4efd284229b98e827b3946a775
msgid "Spack's close coupling of installed packages to compilers, which both necessitates the detour for installing ``intel-parallel-studio``, and largely limits any of its provided virtual packages to a single compiler, heavily favors `recommending to install Intel Parallel Studio outside of Spack <integrate-external-intel_>`_ and declare it for Spack in ``packages.yaml`` by a `compiler-less spec <compiler-neutral-package_>`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1044
# 7d629f5865d643c7b03a30eccac3fd15
msgid "With some effort, you can convince Spack to use shorter paths."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1046
# efa62a372a634f8ab2da6be2e6864703
msgid "Altering the naming scheme means that Spack will lose track of all packages it has installed for you so far. That said, the time is right for this kind of customization when you are defining a new set of compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1051
# b5ff75bca3714ceba68a9eb7d59df9c7
msgid "The relevant tunables are:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1053
# b57ab4ad5c4a474f94c3c2116516bd8b
msgid "Set the ``install_tree`` location in ``config.yaml`` (:ref:`see doc <config-yaml>`)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1055
# 074a85e40b064b0bb0f4359a36967bd2
msgid "Set the hash length in ``install-path-scheme``, also in ``config.yaml`` (:ref:`q.v. <config-yaml>`)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1057
# dbc867c2fc5e48b78278218a17541b51
msgid "You will want to set the *same* hash length for :ref:`tcl module files <modules-naming-scheme>` if you have Spack produce them for you, under ``naming_scheme`` in ``modules.yaml``.  Other module dialects cannot be altered in this manner."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:10
# 51eb303d19414121b0dd722a0d8f27d1
msgid "MakefilePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:12
# 06b12c7346f0410a93417dc8b2af99ce
msgid "The most primitive build system a package can use is a plain Makefile. Makefiles are simple to write for small projects, but they usually require you to edit the Makefile to set platform and compiler-specific variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:21
# 17e8ab491b2c437d86cb5aefcc3ac5a0
msgid "The ``MakefilePackage`` base class comes with 3 phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:23
# f76bf79170be4097ba5c3cba6ba7e3ca
msgid "``edit`` - edit the Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:24
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:23
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:35
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:22
# af90fb443492413389977c00480d10b9
# f831a5560ad942968ba1476146407962
# 89323c3116fb4bdbae14f6de8021a193
# 629f2d85d7f54c90b46ed0d5f41b0224
msgid "``build`` - build the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:25
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:24
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:36
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:23
# b4373b72256d4b229313474630a114f8
# b49c17a952d1421db7ae453d8539ee88
# b7b714d6711e41a2a2511ef0a8312412
# 7d3d08ab9ef34cfd9ef6cda3efd404a1
msgid "``install`` - install the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:27
# 726b923b082049b0b83cec796f54614f
msgid "By default, ``edit`` does nothing, but you can override it to replace hard-coded Makefile variables. The ``build`` and ``install`` phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:41
# c7b5b8199cc9462ca81d8426ed0ae298
msgid "The main file that matters for a ``MakefilePackage`` is the Makefile. This file will be named one of the following ways:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:44
# 0682176450574a0c96bd138a7ba01767
msgid "GNUmakefile (only works with GNU Make)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:45
# b675a795319e4ae39927a3429da3e72e
msgid "Makefile (most common)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:46
# 178d3af8c4a04599ba461acaeceb000d
msgid "makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:48
# 5679de813c2743e0b02eabff1a002ab3
msgid "Some Makefiles also *include* other configuration files. Check for an ``include`` directive in the Makefile."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:55
# 84a4e9efd96a4a69b54e31508d0d69ac
msgid "Spack assumes that the operating system will have a valid ``make`` utility installed already, so you don't need to add a dependency on ``make``. However, if the package uses a ``GNUmakefile`` or the developers recommend using GNU Make, you should add a dependency on ``gmake``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:67
# 59cd20d58e6047ae965528068814bda5
msgid "Types of Makefile packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:69
# f22fb1bab2544176b54c3473f208f3dc
msgid "Most of the work involved in packaging software that uses Makefiles involves overriding or replacing hard-coded variables. Many packages make the mistake of hard-coding compilers, usually for GCC or Intel. This is fine if you happen to be using that particular compiler, but Spack is designed to work with *any* compiler, and you need to ensure that this is the case."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:76
# fe945e686da948f7bbf1ee4852f7f9bf
msgid "Depending on how the Makefile is designed, there are 4 common strategies that can be used to set or override the appropriate variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:81
# 657c1697ff8340c08e5ad6f85e79c735
msgid "Environment variables"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:83
# f2fdc312dbd44fe78cc5542e84259698
msgid "Make has multiple types of `assignment operators <https://www.gnu.org/software/make/manual/make.html#Setting>`_. Some Makefiles use ``=`` to assign variables. The only way to override these variables is to edit the Makefile or override them on the command-line. However, Makefiles that use ``?=`` for assignment honor environment variables. Since Spack already sets ``CC``, ``CXX``, ``F77``, and ``FC``, you won't need to worry about setting these variables. If there are any other variables you need to set, you can do this in the ``edit`` method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:100
# b444c7f0c82e419a927e22ec67eb38fa
msgid "`cbench <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cbench/package.py>`_ is a good example of a simple package that does this, while `esmf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/esmf/package.py>`_ is a good example of a more complex package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:107
# a4c6f14372174c6fa30011061da036bd
msgid "Command-line arguments"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:109
# 1b2f5d56747b42a0a3819aceb4081d92
msgid "If the Makefile ignores environment variables, the next thing to try is command-line arguments. You can do this by overriding the ``build_targets`` attribute. If you don't need access to the spec, you can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:119
# aa3843f0a9e1431d898a495db3bdf8f1
msgid "If you do need access to the spec, you can create a property like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:133
# febf5ef8a29c4cf283f5e0f8acdf6642
msgid "`cloverleaf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cloverleaf/package.py>`_ is a good example of a package that uses this strategy."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:138
# bfe27e785cca4dfbaf7588cfdc797a5a
msgid "Edit Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:140
# 48c338bc970f43cab44566dbe73b81da
msgid "Some Makefiles are just plain stubborn and will ignore command-line variables. The only way to ensure that these packages build correctly is to directly edit the Makefile. Spack provides a ``FileFilter`` class and a ``filter_file`` method to help with this. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:154
# d6e97f4408594e79a3060dab7e37f22a
msgid "`stream <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/stream/package.py>`_ is a good example of a package that involves editing a Makefile to set the appropriate variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:160
# 1eb71123d9ae405eba17ca6e72012b61
msgid "Config file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:162
# 4b65ce7f34f64a5da41e4963b260fe4d
msgid "More complex packages often involve Makefiles that *include* a configuration file. These configuration files are primarily composed of variables relating to the compiler, platform, and the location of dependencies or names of libraries. Since these config files are dependent on the compiler and platform, you will often see entire directories of examples for common compilers and architectures. Use these examples to help determine what possible values to use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:170
# 05e9b1c53a55421aa10c352751482c47
msgid "If the config file is long and only contains one or two variables that need to be modified, you can use the technique above to edit the config file. However, if you end up needing to modify most of the variables, it may be easier to write a new file from scratch."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:175
# 3024427826d243bb8bfaf8741ed617e7
msgid "If each variable is independent of each other, a dictionary works well for storing variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:194
# 9b8665450b0c43739b6d328285245b07
msgid "`elk <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/elk/package.py>`_ is a good example of a package that uses a dictionary to store configuration variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:198
# bee631bb720c47778e8148159bcd06bf
msgid "If the order of variables is important, it may be easier to store them in a list:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:215
# 0df2a0863274451295c44536f85230e0
msgid "`hpl <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/hpl/package.py>`_ is a good example of a package that uses a list to store configuration variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:221
# 9184fe58630b4a439988a9f3a77d0ff0
msgid "Variables to watch out for"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:223
# 1c1d12bf6e074964816d3af26b07e0f4
msgid "The following is a list of common variables to watch out for. The first two sections are `implicit variables <https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html>`_ defined by Make and will always use the same name, while the rest are user-defined variables and may vary from package to package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:229
# 8b471c0a8db346be9d730981610aa104
msgid "**Compilers**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:231
# f3c29a27fcf84a5788f2642b9efdebdd
msgid "This includes variables such as ``CC``, ``CXX``, ``F77``, ``F90``, and ``FC``, as well as variables related to MPI compiler wrappers, like ``MPICC`` and friends."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:235
# a3107477979940369f34137c86765058
msgid "**Compiler flags**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:237
# 066973a92fe443c28e144c6a9635de25
msgid "This includes variables for specific compilers, like ``CFLAGS``, ``CXXFLAGS``, ``F77FLAGS``, ``F90FLAGS``, ``FCFLAGS``, and ``CPPFLAGS``. These variables are often hard-coded to contain flags specific to a certain compiler. If these flags don't work for every compiler, you may want to consider filtering them."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:243
# 87d9bda072454194bbed9d9c7f0307d1
msgid "**Variables that enable or disable features**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:245
# 2e0ad17d44d34e44900f9a3f5adde38d
msgid "This includes variables like ``MPI``, ``OPENMP``, ``PIC``, and ``DEBUG``. These flags often require you to create a variant so that you can either build with or without MPI support, for example. These flags are often compiler-dependent. You should replace them with the appropriate compiler flags, such as ``self.compiler.openmp_flag`` or ``self.compiler.pic_flag``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:252
# 9bedf3ca263c40de9dd7237d7e713d90
msgid "**Platform flags**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:254
# 83269d9a1c3642e682a04820193d6dca
msgid "These flags control the type of architecture that the executable is compiler for. Watch out for variables like ``PLAT`` or ``ARCH``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:257
# 876b1f221f634753abb2c3b389029c09
msgid "**Dependencies**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:259
# e6d2635135824e1a92d9c5a35768c4bc
msgid "Look out for variables that sound like they could be used to locate dependencies, such as ``JAVA_HOME``, ``JPEG_ROOT``, or ``ZLIBDIR``. Also watch out for variables that control linking, such as ``LIBS``, ``LDFLAGS``, and ``INCLUDES``. These variables need to be set to the installation prefix of a dependency, or to the correct linker flags to link to that dependency."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:266
# 2b21a2a9babe4f3195e1e767d774552f
msgid "**Installation prefix**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:268
# a909e4394b0442c1bf1e1085cc8a67c5
msgid "If your Makefile has an ``install`` target, it needs some way of knowing where to install. By default, many packages install to ``/usr`` or ``/usr/local``. Since many Spack users won't have sudo privileges, it is imperative that each package is installed to the proper prefix. Look for variables like ``PREFIX`` or ``INSTALL``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:277
# 00db0ebf52bb47f3a176720f72675780
msgid "Makefiles in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:279
# 6793cd271abf4f2b97d837b6579bf94a
msgid "Not every package places their Makefile in the root of the package tarball. If the Makefile is in a sub-directory like ``src``, you can tell Spack where to locate it like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:290
# c82b421502f84a3691335394c6b82bb6
msgid "Manual installation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:292
# c959e3e55fb84e619437e1351cd8e84d
msgid "Not every Makefile includes an ``install`` target. If this is the case, you can override the default ``install`` method to manually install the package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:308
# 1f2716b11cb04d78a3d5499639149863
msgid "For more information on reading and writing Makefiles, see: https://www.gnu.org/software/make/manual/make.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:10
# ba4dae53f4a245fba66df3413723b564
msgid "MesonPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:12
# aec1ea701b6d4dffa369f33ff872c86d
msgid "Much like Autotools and CMake, Meson is a build system.  But it is meant to be both fast and as user friendly as possible.  GNOME's goal is to port modules to use the Meson build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:20
# e702c9cb10194be2ae548450339ff5a7
msgid "The ``MesonPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:22
# b57eb50772084623b17ba9c4052afd33
msgid "``meson`` - generate ninja files"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:38
# b5c5c45633684881bc012d8004b74c14
msgid "Any of these phases can be overridden in your package as necessary. There is also a ``check`` method that looks for a ``test`` target in the build file. If a ``test`` target exists and the user runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:47
# 336dc08a55954133bb65918096b65098
msgid "Spack will run ``ninja test`` after the build phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:53
# 62bfc649af1a40e4b29960c78166dbec
msgid "Packages that use the Meson build system can be identified by the presence of a ``meson.build`` file. This file declares things like build instructions and dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:57
# fad3142798914a18a42d3ae908aea511
msgid "One thing to look for is the ``meson_version`` key that gets passed to the ``project`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:76
# f64c5a4bd9924a0fbcae6716931d3067
msgid "This means that Meson 0.43.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:83
# aeedc8d45da54a4283ec3732f09db176
msgid "At the bare minimum, packages that use the Meson build system need ``meson`` and ```ninja``` dependencies. Since this is always the case, the ``MesonPackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:104
# 23d119cb408a49e19269bae5f8ef9840
msgid "Finding meson flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:106
# 137370ddd8b642cd8436788520b86ccb
msgid "To get a list of valid flags that can be passed to ``meson``, run the following command in the directory that contains ``meson.build``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:116
# 2dd5e09e66d54a62b635156310dc95e7
msgid "Passing arguments to meson"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:118
# a33021c0d868488ca76c6d88360ac4c3
msgid "If you need to pass any arguments to the ``meson`` call, you can override the ``meson_args`` method like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:127
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:109
# 86585a640932401881b71e3e95c7159d
# 61652504f6f74df982bf5eb66778be35
msgid "This method can be used to pass flags as well as variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:133
# 58b951aebfa24dda846ec58c3dc01140
msgid "For more information on the Meson build system, see: https://mesonbuild.com/index.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:10
# 5ca7227745d54fa5a3fa6c44aacac214
msgid "OctavePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:12
# 1d451060721f4dd29ab7ce4af523bd85
msgid "Octave has its own build system for installing packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:18
# 884791f5444647fc920219979834a278
msgid "The ``OctavePackage`` base class has a single phase:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:22
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:26
# e5638a2299ab4df98c26fd03f77ca1c3
# f289fa29c5294ca2be8dfc57720e2e7a
msgid "By default, this phase runs the following command:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:29
# 694a7a741ee243bd9b07a9f87759fc66
msgid "Beware that uninstallation is not implemented at the moment. After uninstalling a package via Spack, you also need to manually uninstall it from Octave via ``pkg uninstall <package_name>``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:35
# 0e7d6fd723ea4bc7b23c6024db3617b8
msgid "Finding Octave packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:37
# 7c81333e018044c69cd526fef66d0d1d
msgid "Most Octave packages are listed at https://octave.sourceforge.io/packages.php."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:41
# db2a6a84f2aa42e39cd76ffbbf23934a
msgid "Dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:43
# f4b0050fcb314d89b1e9207c702bc332
msgid "Usually, the homepage of a package will list dependencies, i.e. ``Dependencies: Octave >= 3.6.0 struct >= 1.0.12``. The same information should be available in the ``DESCRIPTION`` file in the root of each archive."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:49
# eaf0efe5db9c482ab4c835f4cea8626b
msgid "External Documentation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:51
# ecc423bd1a334b49a413d9ca835b2e6c
msgid "For more information on the Octave build system, see: https://octave.org/doc/v4.4.0/Installing-and-Removing-Packages.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:10
# 31e540ef11a64c9badea436e9d3bef61
msgid "PerlPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:12
# 0c79bb7929f84699aca9849b23a06a65
msgid "Much like Octave, Perl has its own language-specific build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:19
# 680d21465c2649c4ba79e83ec459913f
msgid "The ``PerlPackage`` base class comes with 3 phases that can be overridden:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:21
# f3ab0114c1534c6ba2aba79418effabf
msgid "``configure`` - configure the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:25
# e35a1859920c42608f6b49a8009415bd
msgid "Perl packages have 2 common modules used for module installation:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:29
# db9b65e740714c24b4392af20e775f8a
msgid "``ExtUtils::MakeMaker``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:31
# 3b2e0d3661cb4dcc8dec01052ec64212
msgid "The ``ExtUtils::MakeMaker`` module is just what it sounds like, a module designed to generate Makefiles. It can be identified by the presence of a ``Makefile.PL`` file, and has the following installation steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:45
# 28b0f95b420b4e26bdd407a0842bd224
msgid "``Module::Build``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:47
# fb6af60a382740a0bdc5dd1cc321a6e4
msgid "The ``Module::Build`` module is a pure-Perl build system, and can be identified by the presence of a ``Build.PL`` file. It has the following installation steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:59
# 923267f80ee64be89c698ae08108cc76
msgid "If both ``Makefile.PL`` and ``Build.PL`` files exist in the package, Spack will use ``Makefile.PL`` by default. If your package uses a different module, ``PerlPackage`` will need to be extended to support it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:64
# 8448bc34b92a4e3291ad7ca00e772343
msgid "``PerlPackage`` automatically detects which build steps to use, so there shouldn't be much work on the package developer's side to get things working."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:70
# 9ddb43d65cdf4e77957c847f9eaecb58
msgid "Finding Perl packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:72
# fbe6ff07bdea4af38ea631201e134b5d
msgid "Most Perl modules are hosted on CPAN - The Comprehensive Perl Archive Network. If you need to find a package for ``XML::Parser``, for example, you should search for \"CPAN XML::Parser\"."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:76
# 21f6af8820a24ba2aa37e09254295ff6
msgid "Some CPAN pages are versioned. Check for a link to the \"Latest Release\" to make sure you have the latest version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:81
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:52
# b000229fc411421f934db97deee6c33b
# c992337f53104cda9cfd7cbfc926f0ae
msgid "Package name"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:83
# 82d777e5906b40c6a3fd50336f3bd6ee
msgid "When you use ``spack create`` to create a new Perl package, Spack will automatically prepend ``perl-`` to the front of the package name. This helps to keep Perl modules separate from other packages. The same naming scheme is used for other language extensions, like Python and R."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:90
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:113
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:73
# 7adf86711bb44abeb79ea14395422927
# c557c26fbaea46bab824f83d8baa444d
# ee0dcabc66d040689deb3b8ee40721d4
msgid "Description"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:92
# 0cab24cc394c4a7ea8ab0dabb1fb2eff
msgid "Most CPAN pages have a short description under \"NAME\" and a longer description under \"DESCRIPTION\". Use whichever you think is more useful while still being succinct."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:98
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:129
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:87
# 1cdde7d9025e447fbca88b70160ff052
# 05d526db3e404ce9b606d5b7a83df267
# aa54797841104369910e4247484afe23
msgid "Homepage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:100
# 6d57341621f34dca8fb8c8221bffa8af
msgid "In the top-right corner of the CPAN page, you'll find a \"permalink\" for the package. This should be used instead of the current URL, as it doesn't contain the version number and will always link to the latest release."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:107
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:145
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:102
# 04b8794090584ba292088d08ee9edcbe
# de0ade2d9cdc483caf4e754be169d571
# 42f93e7232444500b8d13c861cf18f03
msgid "URL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:109
# a00c773001fe4fb8bbb9973445ab7694
msgid "If you haven't found it already, the download URL is on the right side of the page below the permalink. Search for \"Download\"."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:116
# 3a27a8c6401b42b583f4c6b01e22a6c4
msgid "Every ``PerlPackage`` obviously depends on Perl at build and run-time, so ``PerlPackage`` contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:126
# 26405cdef4d04d4a9f1709de20f3008d
msgid "If your package requires a specific version of Perl, you should specify this."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:129
# 254b63efdb1f493f9f7239d9aa84ecce
msgid "Although newer versions of Perl include ``ExtUtils::MakeMaker`` and ``Module::Build`` as \"core\" modules, you may want to add dependencies on ``perl-extutils-makemaker`` and ``perl-module-build`` anyway. Many people add Perl as an external package, and we want the build to work properly. If your package uses ``Makefile.PL`` to build, add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:140
# 2898403f3b254db08ae3b68355b85267
msgid "If your package uses ``Build.PL`` to build, add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:149
# 7064a0080fd34013999aeb3f0454691d
msgid "Perl dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:151
# 190f3145eeb74b8c903179c0d6174a3f
msgid "Below the download URL, you will find a \"Dependencies\" link, which takes you to a page listing all of the dependencies of the package. Packages listed as \"Core module\" don't need to be added as dependencies, but all direct dependencies should be added. Don't add dependencies of dependencies. These should be added as dependencies to the dependency, not to your package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:160
# 10e18a7d64cc401193d64e7b3621b06d
msgid "Passing arguments to configure"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:162
# 2e1ae97229cc469d92a14f3481fd135a
msgid "Packages that have non-Perl dependencies often use command-line variables to specify their installation directory. You can pass arguments to ``Makefile.PL`` or ``Build.PL`` by overriding ``configure_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:180
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:720
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:312
# 9d6819dcbb354a3195cba536e3309e1a
# de092e10684647a68b82f2e55c860df0
# 2c2bace6cd22465dacfbaf6cfcad7a57
msgid "Alternatives to Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:182
# c8cc3148b9fc44869c6037a83bf6dc8e
msgid "If you need to maintain a stack of Perl modules for a user and don't want to add all of them to Spack, a good alternative is ``cpanm``. If Perl is already installed on your system, it should come with a ``cpan`` executable. To install ``cpanm``, run the following command:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:192
# 82730516ecfb4972b993c493d52d8d4c
msgid "Now, you can install any Perl module you want by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:199
# 32ff2c25e4404233967391399b78f1ed
msgid "Obviously, these commands can only be run if you have root privileges. Furthermore, ``cpanm`` is not capable of installing non-Perl dependencies. If you need to install to your home directory or need to install a module with non-Perl dependencies, Spack is a better option."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:208
# 93ea02a6a4a54cb0a17cbb152cbce456
msgid "You can find more information on installing Perl modules from source at: http://www.perlmonks.org/?node_id=128077"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:211
# abf2d86af10b43e595378419b645119e
msgid "More generic Perl module installation instructions can be found at: http://www.cpan.org/modules/INSTALL.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:10
# f71b94b3db9b4dd181fa44114604a7be
msgid "PythonPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:12
# 5662306d016844a7b2d63aa9c8ad77b2
msgid "Python packages and modules have their own special build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:18
# 939eaf4988dd488b98090548851bcf1b
msgid "The ``PythonPackage`` base class provides the following phases that can be overridden:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:21
# bc4610055d1149b5bffa94935708fd08
msgid "``build``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:22
# 1344a390c52f4c2fb160c35d8f35b9db
msgid "``build_py``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:23
# 856187ca89ca4eaaa29eef72c3f071a5
msgid "``build_ext``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:24
# e5c3fa9b2c984996ac9508b02ab05d7b
msgid "``build_clib``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:25
# 3de1ccb4320f40278cc55c3f6f2fc5e7
msgid "``build_scripts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:26
# dbdb5c344fb647d3af5d59c0a3b2d192
msgid "``clean``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:27
# abb85e65f31f438f88ef8ade30437d2b
msgid "``install``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:28
# a342f4f0c2fd4c5b8cfa46b37e186960
msgid "``install_lib``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:29
# 59d76966750d4dd9a9167fd7628c651e
msgid "``install_headers``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:30
# 16041ac2226142258e2109c23a793e9e
msgid "``install_scripts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:31
# 353b2ad760014f2bb1ad0e3c8f967c64
msgid "``install_data``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:32
# 3008d65aba674777bfa29e7432023ddc
msgid "``sdist``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:33
# b262842500e34b978861cd3cb611130e
msgid "``register``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:34
# 77a4afa12669491fb322ae8ad964d83a
msgid "``bdist``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:35
# 4d65657272be4413874428135e389fe7
msgid "``bdist_dumb``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:36
# 17f4f1d2334a40cab33eb05f18fbc84d
msgid "``bdist_rpm``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:37
# 961a8f48ed9f4f38a331e90ddf82fc4b
msgid "``bdist_wininst``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:38
# 5a48d330f8b94a08ac8305a61e8875dd
msgid "``upload``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:39
# dd1a9a0c53e84c469276453782a85991
msgid "``check``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:41
# 000df5e1460a4c1c934960007153dd09
msgid "These are all standard ``setup.py`` commands and can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:48
# 0bf799dfdd924ffb97049464a598671a
msgid "By default, only the ``build`` and ``install`` phases are run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:50
# 698c7ff187f64948b91f2cd73b45cbbe
msgid "``build`` - build everything needed to install"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:51
# 1c7a691240a9407c87a03c393cd69ff7
msgid "``install`` - install everything from build directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:53
# 0a9534a8f5ac4e93888c662e8499727a
msgid "If for whatever reason you need to run more phases, simply modify your ``phases`` list like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:61
# 051e36d8b49c4a40927f63c139c6e66f
msgid "Each phase provides a function ``<phase>`` that runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:68
# 08576c146adb41738830588082a4d5fc
msgid "Each phase also has a ``<phase_args>`` function that can pass arguments to this call. All of these functions are empty except for the ``install_args`` function, which passes ``--prefix=/path/to/installation/prefix``. There is also some additional logic specific to setuptools and eggs."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:73
# 83a0445cbf644a068482aa1202ac9a3d
msgid "If you need to run a phase that is not a standard ``setup.py`` command, you'll need to define a function for it like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:88
# 9d62a9056375463b827dc50293349a42
msgid "Python packages can be identified by the presence of a ``setup.py`` file. This file is used by package managers like ``pip`` to determine a package's dependencies and the version of dependencies required, so if the ``setup.py`` file is not accurate, the package will not build properly. For this reason, the ``setup.py`` file should be fairly reliable. If the documentation and ``setup.py`` disagree on something, the ``setup.py`` file should be considered to be the truth. As dependencies are added or removed, the documentation is much more likely to become outdated than the ``setup.py``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:100
# cd66a88e9ebd4cd4b7ea6c71172e179a
msgid "Finding Python packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:102
# 29603693ccc74249811c31cad18d2325
msgid "The vast majority of Python packages are hosted on PyPI - The Python Package Index. ``pip`` only supports packages hosted on PyPI, making it the only option for developers who want a simple installation. Search for \"PyPI <package-name>\" to find the download page. Note that some pages are versioned, and the first result may not be the newest version. Click on the \"Latest Version\" button to the top right to see if a newer version is available. The download page is usually at: https://pypi.org/project/<package-name>"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:115
# 81455d6355d74b26b75d9e6f151e104c
msgid "The top of the PyPI downloads page contains a description of the package. The first line is usually a short description, while there may be a several line \"Project Description\" that follows. Choose whichever is more useful. You can also get these descriptions on the command-line using:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:131
# b194cdf462d441b7be053153eca9e5db
msgid "Package developers use ``setup.py`` to upload new versions to PyPI. The ``setup`` method often passes metadata like ``homepage`` to PyPI. This metadata is displayed on the left side of the download page. Search for the text \"Homepage\" under \"Project links\" to find it. You should use this page instead of the PyPI page if they differ. You can also get the homepage on the command-line by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:147
# 7492dcb0334243379fead18d1a2d41fa
msgid "You may have noticed that Spack allows you to add multiple versions of the same package without adding multiple versions of the download URL. It does this by guessing what the version string in the URL is and replacing this with the requested version. Obviously, if Spack cannot guess the version correctly, or if non-version-related things change in the URL, Spack cannot substitute the version properly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:154
# f8f5b3d0b08745799384df0dc30050ce
msgid "Once upon a time, PyPI offered nice, simple download URLs like: https://pypi.python.org/packages/source/n/numpy/numpy-1.13.1.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:157
# 0d83ddc2e26b4256bc2f78b42662ca75
msgid "As you can see, the version is 1.13.1. It probably isn't hard to guess what URL to use to download version 1.12.0, and Spack was perfectly capable of performing this calculation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:161
# 945e12076a1844aead04b593de1e76d5
msgid "However, PyPI switched to a new download URL format: https://pypi.python.org/packages/c0/3a/40967d9f5675fbb097ffec170f59c2ba19fc96373e73ad47c2cae9a30aed/numpy-1.13.1.zip#md5=2c3c0f4edf720c3a7b525dacc825b9ae"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:164
# 8e06689d0f9644c48d12bda8afaf30c5
msgid "and more recently: https://files.pythonhosted.org/packages/b0/2b/497c2bb7c660b2606d4a96e2035e92554429e139c6c71cdff67af66b58d2/numpy-1.14.3.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:167
# e316044f0d364ae699e7722fabbedb92
msgid "As you can imagine, it is impossible for Spack to guess what URL to use to download version 1.12.0 given this URL. There is a solution, however. PyPI offers a new hidden interface for downloading Python packages that does not include a hash in the URL: https://pypi.io/packages/source/n/numpy/numpy-1.13.1.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:173
# 9e4d716365474bc99f8a7ca96ea9c4e5
msgid "This URL redirects to the files.pythonhosted.org URL. The general syntax for this pypi.io URL is: https://pypi.io/packages/source/<first-letter-of-name>/<name>/<name>-<version>.<extension>"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:177
# db1a9e06a81f49bda5edafccf564de27
msgid "Please use the pypi.io URL instead of the pypi.python.org URL. If both ``.tar.gz`` and ``.zip`` versions are available, ``.tar.gz`` is preferred. If some releases offer both ``.tar.gz`` and ``.zip`` versions, but some only offer ``.zip`` versions, use ``.zip``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:184
# 44a2f42be85242299a3538ec6bd67ccc
msgid "PyPI vs. GitHub"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:186
# 7b8440358d134e5fb9dbe01c567b4ba5
msgid "Many packages are hosted on PyPI, but are developed on GitHub and other version control systems. The tarball can be downloaded from either location, but PyPI is preferred for the following reasons:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:190
# 425e588bd3b44cb29146f6db0c2a54db
msgid "PyPI contains the bare minimum of files to install the package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:192
# cab8f3127c624fe99add5b8ea0b3c8e3
msgid "You may notice that the tarball you download from PyPI does not have the same checksum as the tarball you download from GitHub. When a developer uploads a new release to PyPI, it doesn't contain every file in the repository, only the files necessary to install the package. PyPI tarballs are therefore smaller."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:198
# 1d502131713040579588c05c1aa273be
msgid "PyPI is the official source for package managers like ``pip``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:200
# 01f1f842ccf8472ca42640123c6e1200
msgid "Let's be honest, ``pip`` is much more popular than Spack. If the GitHub tarball contains a file not present in the PyPI tarball that causes a bug, the developers may not realize this for quite some time. If the bug was in a file contained in the PyPI tarball, users would notice the bug much more quickly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:206
# 8b97102e240f4d289c413097f3005e57
msgid "GitHub release may be a beta version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:208
# 71050d0b6faa486fb5c423656ebe96cc
msgid "When a developer releases a new version of a package on GitHub, it may not be intended for most users. Until that release also makes its way to PyPI, it should be assumed that the release is not yet ready for general use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:213
# f33972827d144e4caf1b0bd53fbc0493
msgid "The checksum for a GitHub release may change."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:215
# 269cc4a8e3c5435aaaf6ecbda1014ea0
msgid "Unfortunately, some developers have a habit of patching releases without incrementing the version number. This results in a change in tarball checksum. Package managers like Spack that use checksums to verify the integrity of a download tarball grind to a halt when the checksum for a known version changes. Most of the time, the change is intentional, and contains a needed bug fix. However, sometimes the change indicates a download source that has been compromised, and a tarball that contains a virus. If this happens, you must contact the developers to determine which is the case. PyPI is nice because it makes it physically impossible to re-release the same version of a package with a different checksum."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:227
# 44817efe6eec4e74b09441034a39022c
msgid "There are some reasons to prefer downloading from GitHub:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:229
# b3fdcd99c68d45f4a236e0869f1e0453
msgid "The GitHub tarball may contain unit tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:231
# ff41b495f30a429f804c5ebecb83ed21
msgid "As previously mentioned, the PyPI tarball contains the bare minimum of files to install the package. Unless explicitly specified by the developers, it will not contain development files like unit tests. If you desire to run the unit tests during installation, you should use the GitHub tarball instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:237
# e73f15e90a3e4815a9578496a2fd7d40
msgid "Spack does not yet support ``spack versions`` and ``spack checksum`` with PyPI URLs"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:240
# 4482383e495b4ca4a4a9f506c5499a65
msgid "These commands work just fine with GitHub URLs. This is a minor annoyance, not a reason to prefer GitHub over PyPI."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:243
# 246636e2b7c64774b5300c3021a8dadd
msgid "If you really want to run these unit tests, no one will stop you from submitting a PR for a new package that downloads from GitHub."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:250
# 6e42655838dd4b9b8ba192c58332866b
msgid "There are a few dependencies common to the ``PythonPackage`` build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:254
# c309ed4d92a14f349aaae1a4048c02f7
msgid "Python"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:256
# 9a2d78f4d56944888a987791c8f66c7f
msgid "Obviously, every ``PythonPackage`` needs Python at build-time to run ``python setup.py build && python setup.py install``. Python is also needed at run-time if you want to import the module. Due to backwards incompatible changes between Python 2 and 3, it is very important to specify which versions of Python are supported. If the documentation mentions that Python 3 is required, this can be specified as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:268
# 1455fb23f473493284319591e98dc954
msgid "If Python 2 is required, this would look like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:275
# b6e3fcd4626b442cb3ace8c81cc02986
msgid "If Python 2.7 is the only version that works, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:282
# 9c4f113015c44887b3619e823d6e0555
msgid "The documentation may not always specify supported Python versions. Another place to check is in the ``setup.py`` file. Look for a line containing ``python_requires``. An example from `py-numpy <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-numpy/package.py>`_ looks like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:293
# e3020a182c2f44f4be0ada17d3805a92
msgid "More commonly, you will find a version check at the top of the file:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:301
# cd722ddbb9fb4d7a82cca80090f46c21
msgid "This can be converted to Spack's spec notation like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:310
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:466
# 4b7e796c00f844a48c8ef62d7eda7d61
# 6043c2f1d3c147feb4506a4a402d6ff7
msgid "setuptools"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:312
# 7323c9580e934c3981374e2c0ae95db2
msgid "Originally, the Python language had a single build system called distutils, which is built into Python. Distutils provided a common framework for package authors to describe their project and how it should be built. However, distutils was not without limitations. Most notably, there was no way to list a project's dependencies with distutils. Along came setuptools, a non-builtin build system designed to overcome the limitations of distutils. Both projects use a similar API, making the transition easy while adding much needed functionality. Today, setuptools is used in around 75% of the Python packages in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:323
# 8ab22e3e9b574adbae7281dcf3906fb1
msgid "Since setuptools isn't built-in to Python, you need to add it as a dependency. To determine whether or not a package uses setuptools, search the file for an import statement like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:332
# 92b9d8190e2d4c349f5079ec6e4cef98
msgid "or:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:339
# cefa3823aceb47d197f0b16db5b4f597
msgid "Some packages are designed to work with both setuptools and distutils, so you may find something like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:350
# ce756a1b456e42aca551070363b9986f
msgid "This uses setuptools if available, and falls back to distutils if not. In this case, you would still want to add a setuptools dependency, as it offers us more control over the installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:354
# 167fa6047e584b5f94c009fa07e350c6
msgid "Unless specified otherwise, setuptools is usually a build-only dependency. That is, it is needed to install the software, but is not needed at run-time. This can be specified as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:365
# 869c8fb197094ba6ab6a827101e28dee
msgid "cython"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:367
# 173147dce4bb4ffba861cce44ea046af
msgid "Compared to compiled languages, interpreted languages like Python can be quite a bit slower. To work around this, some Python developers rewrite computationally demanding sections of code in C, a process referred to as \"cythonizing\". In order to build these package, you need to add a build dependency on cython:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:378
# 6097c45a0c69470c9b8594f58d1df071
msgid "Look for references to \"cython\" in the ``setup.py`` to determine whether or not this is necessary. Cython may be optional, but even then you should list it as a required dependency. Spack is designed to compile software, and is meant for HPC facilities where speed is crucial. There is no reason why someone would not want an optimized version of a library instead of the pure-Python version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:388
# d1833cdf1bb5441f91bc5e74877752f9
msgid "Python dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:390
# 636937c86dec4866a110758d4ee134f1
msgid "When you install a package with ``pip``, it reads the ``setup.py`` file in order to determine the dependencies of the package. If the dependencies are not yet installed, ``pip`` downloads them and installs them for you. This may sound convenient, but Spack cannot rely on this behavior for two reasons:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:396
# 7a45b73789404043b459459fe9b95237
msgid "Spack needs to be able to install packages on air-gapped networks."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:398
# 9e5e5ee3f69040ce95afd4b0202477be
msgid "If there is no internet connection, ``pip`` can't download the package dependencies. By explicitly listing every dependency in the ``package.py``, Spack knows what to download ahead of time."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:402
# 72db2e769e2349e9bc7ab965b154264c
msgid "Duplicate installations of the same dependency may occur."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:404
# dfa8814a692a4a04b6bd66ef0890f29c
msgid "Spack supports *activation* of Python extensions, which involves symlinking the package installation prefix to the Python installation prefix. If your package is missing a dependency, that dependency will be installed to the installation directory of the same package. If you try to activate the package + dependency, it may cause a problem if that package has already been activated."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:411
# be8c61910eb94e90934fa75cc5c3fc0c
msgid "For these reasons, you must always explicitly list all dependencies. Although the documentation may list the package's dependencies, often the developers assume people will use ``pip`` and won't have to worry about it. Always check the ``setup.py`` to find the true dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:417
# c51c3b186ab44fbe95c48cab2bd81e00
msgid "If the package relies on ``distutils``, it may not explicitly list its dependencies. Check for statements like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:428
# 9f1abd19da974711a45d9079f7002749
msgid "Obviously, this means that ``py-numpy`` is a dependency."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:430
# bae9ff425892407c821e4c3efbbe55c1
msgid "If the package uses ``setuptools``, check for the following clues:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:432
# 336083eeec134b08afeddbc1846821a1
msgid "``install_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:434
# da2ac9ceff274de690041e422f824ba0
msgid "These packages are required for installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:436
# 6ca548f8338748d6b114ccc88348dbd5
msgid "``extra_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:438
# ed672ecb54924e93b9089c7ac7bb42b9
msgid "These packages are optional dependencies that enable additional functionality. You should add a variant that optionally adds these dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:442
# 261947d1f5b04990a7bd872326d50a08
msgid "``test_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:444
# 2dbeb131b37a4af283753c31fe5db60a
msgid "These are packages that are required to run the unit tests for the package. These dependencies can be specified using the ``type='test'`` dependency type."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:448
# 5a4c72ee167246cfac45c9c1126ad6c5
msgid "In the root directory of the package, you may notice a ``requirements.txt`` file. It may look like this file contains a list of all of the package's dependencies. Don't be fooled. This file is used by tools like Travis to install the pre-requisites for the package... and a whole bunch of other things. It often contains dependencies only needed for unit tests, like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:455
# 90d001ae851f4dbbb64cd997ebd301c4
msgid "mock"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:456
# 539cea20080b4d0ba1f3df1640ea6124
msgid "nose"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:457
# ea1d390f625a4f11b60985add908de09
msgid "pytest"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:459
# 7f5911fb3a934ba5809d077fd5d2eec9
msgid "It can also contain dependencies for building the documentation, like sphinx. If you can't find any information about the package's dependencies, you can take a look in ``requirements.txt``, but be sure not to add test or documentation dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:468
# f0c7b0ae32904b78bb04694e60b96f83
msgid "Setuptools is a bit of a special case. If a package requires setuptools at run-time, how do they express this? They could add it to ``install_requires``, but setuptools is imported long before this and needed to read this line. And since you can't install the package without setuptools, the developers assume that setuptools will already be there, so they never mention when it is required. We don't want to add run-time dependencies if they aren't needed, so you need to determine whether or not setuptools is needed. Grep the installation directory for any files containing a reference to ``setuptools`` or ``pkg_resources``. Both modules come from ``py-setuptools``. ``pkg_resources`` is particularly common in scripts in ``prefix/bin``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:482
# f62797b07bed42b5b67d6d6f0c85cd4c
msgid "Passing arguments to setup.py"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:484
# c512a148e7ea4190aa86737c2853a335
msgid "The default build and install phases should be sufficient to install most packages. However, you may want to pass additional flags to either phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:488
# 04aa2e9da35e4ae7ab686382ce12551b
msgid "You can view the available options for a particular phase with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:495
# 808feadcb4664b38990b7a1e09499d72
msgid "Each phase provides a ``<phase_args>`` function that can be used to pass arguments to that phase. For example, `py-numpy <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-numpy/package.py>`_ adds:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:520
# da346565f2484cd3bd02c7b4c3d9a1f0
msgid "``PythonPackage`` provides a couple of options for testing packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:524
# 36fbfcfbf7024a508126f75ecaa6b327
msgid "Import tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:526
# c77467e35b27483dabca117eccf4b75a
msgid "Just because a package successfully built does not mean that it built correctly. The most reliable test of whether or not the package was correctly installed is to attempt to import all of the modules that get installed. To get a list of modules, run the following command in the source directory:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:540
# ae6e09541761407f9d7f8d0ee77c8b63
msgid "Large, complex packages like ``numpy`` will return a long list of packages, while other packages like ``six`` will return an empty list. ``py-six`` installs a single ``six.py`` file. In Python packaging lingo, a \"package\" is a directory containing files like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:552
# b283e56e444e409caa90379803260385
msgid "whereas a \"module\" is a single Python file. Since ``find_packages`` only returns packages, you'll have to determine the correct module names yourself. You can now add these packages and modules to the package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:562
# 9d272b122ed549ce9d2f08e3b97a7746
msgid "When you run ``spack install --test=root py-six``, Spack will attempt to import the ``six`` module after installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:565
# 53b0fbb694874dcea7101ee80f0fe81d
msgid "These tests most often catch missing dependencies and non-RPATHed libraries. Make sure not to add modules/packages containing the word \"test\", as these likely won't end up in installation directory."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:571
# 545233ee3d324969a9db5b26d7f2bc6b
msgid "Unit tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:573
# 51573f5d787240b485452dc51a5c86e3
msgid "The package you want to install may come with additional unit tests. By default, Spack runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:581
# 6ad2baddbe92431585ed9e29db13cca7
msgid "if it detects that the ``setup.py`` file supports a ``test`` phase. You can add additional build-time or install-time tests by overriding ``test`` and ``installtest``, respectively. For example, ``py-numpy`` adds:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:595
# 97a75c7e7a3541409716c8e403aa9554
msgid "Setup file in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:597
# c735f34940b94c68872c3cf248714ce3
msgid "In order to be compatible with package managers like ``pip``, the package is required to place its ``setup.py`` in the root of the tarball. However, not every Python package cares about ``pip`` or PyPI. If you are installing a package that is not hosted on PyPI, you may find that it places its ``setup.py`` in a sub-directory. To handle this, add the directory containing ``setup.py`` to the package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:611
# db70768a398044e9bb823eb949a3eda2
msgid "Alternate names for setup.py"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:613
# a9285598d07d4fac8ea156c4e244ae24
msgid "As previously mentioned, packages need to call their setup script ``setup.py`` in order to be compatible with package managers like ``pip``. However, some packages like `py-meep <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-meep/package.py>`_  and `py-adios <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-adios/package.py>`_ come with multiple setup scripts, one for a serial build and another for a parallel build. You can override the default name to use like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:629
# 819696b7725849d696904f6f135fc218
msgid "PythonPackage vs. packages that use Python"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:631
# bfd44ae5f3c5465cae5002be6e1deb67
msgid "There are many packages that make use of Python, but packages that depend on Python are not necessarily ``PythonPackages``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:636
# a74def085cc74d8c804cf784a95570f2
msgid "Choosing a build system"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:638
# 6c70e6947618412a9ffe23d4c8133b03
msgid "First of all, you need to select a build system. ``spack create`` usually does this for you, but if for whatever reason you need to do this manually, choose ``PythonPackage`` if and only if the package contains a ``setup.py`` file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:645
# 989f78d9f95e4b748538b04fb9702d48
msgid "Choosing a package name"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:647
# f190ccc0ffcd46ec9915bb157ec25ef7
msgid "Selecting the appropriate package name is a little more complicated than choosing the build system. By default, ``spack create`` will prepend ``py-`` to the beginning of the package name if it detects that the package uses the ``PythonPackage`` build system. However, there are occasionally packages that use ``PythonPackage`` that shouldn't start with ``py-``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:654
# e1a89b8c9fb1451fbbc6aba12389c98b
msgid "busco"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:655
# d9a439648668445b94bb6dea7ad2970c
msgid "easybuild"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:656
# ab0faf18ae8647b48d537768a2716f54
msgid "httpie"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:657
# 1f52ce70cfee4724bcba5992dea12a88
msgid "mercurial"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:658
# 4f22dfcb83b24699a885351a613cbcc0
msgid "scons"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:659
# dd77ffd213c2473ca65e32df7a54fef2
msgid "snakemake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:661
# 5d2ff3d51b264151bdb657496e61c1d6
msgid "The thing these packages have in common is that they are command-line tools that just so happen to be written in Python. Someone who wants to install ``mercurial`` with Spack isn't going to realize that it is written in Python, and they certainly aren't going to assume the package is called ``py-mercurial``. For this reason, we manually renamed the package to ``mercurial``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:668
# 701ffb5b00cf42039f1eac1b2e9f4eed
msgid "Likewise, there are occasionally packages that don't use the ``PythonPackage`` build system but should still be prepended with ``py-``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:672
# da4075e449284e8b9b9703c7494f6f18
msgid "py-genders"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:673
# 5f46455af1f34906b2e5e5e60015f6cf
msgid "py-py2cairo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:674
# 67411e3d4b554023964ce0b920ef50c6
msgid "py-pygobject"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:675
# 612e26d627484501b7ccb57ddfb5e062
msgid "py-pygtk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:676
# b6f6782e745e47e1b1830d88d99db938
msgid "py-pyqt"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:677
# 1010a4ea90c34e3dbd76fd5caa708422
msgid "py-pyserial"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:678
# 621760eb951440638797c69c39e4db42
msgid "py-sip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:679
# 6878df680c154a5f8f979e641a00bc56
msgid "py-xpyb"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:681
# 921266b062d942f49d9b70a8300f3b7d
msgid "These packages are primarily used as Python libraries, not as command-line tools. You may see C/C++ packages that have optional Python language-bindings, such as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:685
# 2adfa23d63c94daaa252ee6824cd5056
msgid "antlr"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:686
# 6afbf6b78f8b48b6a24435f832c714d0
msgid "cantera"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:687
# 7f4290a9a95b44f4951147b7c30bd27b
msgid "conduit"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:688
# 37e5ac9ecc5d496aa4704b6ebd0af096
msgid "pagmo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:689
# bd6a4fc513834b7a9f03ec44979e9bf2
msgid "vtk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:691
# 43d0b8bd6c48463f825d938d53b1689a
msgid "Don't prepend these kind of packages with ``py-``. When in doubt, think about how this package will be used. Is it primarily a Python library that will be imported in other Python scripts? Or is it a command-line tool, or C/C++/Fortran program with optional Python modules? The former should be prepended with ``py-``, while the latter should not."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:700
# 41065ee04e8d46e19f0010d71d4f1474
msgid "extends vs. depends_on"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:702
# 8bf03c28c62a4e538a48ff6a18b37311
msgid "This is very similar to the naming dilemma above, with a slight twist. As mentioned in the :ref:`Packaging Guide <packaging_extensions>`, ``extends`` and ``depends_on`` are very similar, but ``extends`` adds the ability to *activate* the package. Activation involves symlinking everything in the installation prefix of the package to the installation prefix of Python. This allows the user to import a Python module without having to add that module to ``PYTHONPATH``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:710
# 0dc8ce6878844c41b55d2f8849c99031
msgid "When deciding between ``extends`` and ``depends_on``, the best rule of thumb is to check the installation prefix. If Python libraries are installed to ``prefix/lib/python2.7/site-packages`` (where 2.7 is the MAJOR.MINOR version of Python you used to install the package), then you should use ``extends``. If Python libraries are installed elsewhere or the only files that get installed reside in ``prefix/bin``, then don't use ``extends``, as symlinking the package wouldn't be useful."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:722
# 227289fdae0f4b309a91509f4472b5a7
msgid "PyPI has hundreds of thousands of packages that are not yet in Spack, and ``pip`` may be a perfectly valid alternative to using Spack. The main advantage of Spack over ``pip`` is its ability to compile non-Python dependencies. It can also build cythonized versions of a package or link to an optimized BLAS/LAPACK library like MKL, resulting in calculations that run orders of magnitude faster. Spack does not offer a significant advantage to other python-management systems for installing and using tools like flake8 and sphinx. But if you need packages with non-Python dependencies like numpy and scipy, Spack will be very valuable to you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:733
# 5a001776f0bd439aa6cee09e3ec540c3
msgid "Anaconda is another great alternative to Spack, and comes with its own ``conda`` package manager. Like Spack, Anaconda is capable of compiling non-Python dependencies. Anaconda contains many Python packages that are not yet in Spack, and Spack contains many Python packages that are not yet in Anaconda. The main advantage of Spack over Anaconda is its ability to choose a specific compiler and BLAS/LAPACK or MPI library. Spack also has better platform support for supercomputers. On the other hand, Anaconda offers Windows support."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:746
# 225560d702b54d4d8dc91305e5bd1e61
msgid "For more information on Python packaging, see: https://packaging.python.org/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:10
# db135c12415845688cc050e5809667ea
msgid "QMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:12
# d13875e322aa45fd821e7177b6b11d21
msgid "Much like Autotools and CMake, QMake is a build-script generator designed by the developers of Qt. In its simplest form, Spack's ``QMakePackage`` runs the following steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:24
# cdeb2c85df2a4e90b18e7b95f7f646b6
msgid "QMake does not appear to have a standardized way of specifying the installation directory, so you may have to set environment variables or edit ``*.pro`` files to get things working properly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:32
# e87898fd55d841c1aa3ce2c801659d57
msgid "The ``QMakePackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:34
# a03296bacc234d93b6fc238b9dc0a3d6
msgid "``qmake`` - generate Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:47
# 866d5b7ff36f4ffd900da9ac9d06e39c
msgid "Any of these phases can be overridden in your package as necessary. There is also a ``check`` method that looks for a ``check`` target in the Makefile. If a ``check`` target exists and the user runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:56
# 930bffe15f7c470e95fce66a6b7ea53f
msgid "Spack will run ``make check`` after the build phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:62
# 70fd160623f1486db0a15d4cdf76fc1b
msgid "Packages that use the QMake build system can be identified by the presence of a ``<project-name>.pro`` file. This file declares things like build instructions and dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:66
# db1ee1490a334b62919c3ec2ccb77964
msgid "One thing to look for is the ``minQtVersion`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:73
# 913d9b2fb9c743c493472a3f1f7d862b
msgid "This means that Qt 5.6.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:80
# 5c5e32444a31446bba731995a14adeea
msgid "At the bare minimum, packages that use the QMake build system need a ``qt`` dependency. Since this is always the case, the ``QMakePackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:89
# 11f56878caea480aa5d46d341d175e63
msgid "If you want to specify a particular version requirement, or need to link to the ``qt`` libraries, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:98
# 93b8bcdab99b46a4bdc6a996773317aa
msgid "Passing arguments to qmake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:100
# 968e6d3117374095b1b810acafee3547
msgid "If you need to pass any arguments to the ``qmake`` call, you can override the ``qmake_args`` method like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:115
# 7a8b1ce773024859ac2d9ad38ae5624d
msgid "For more information on the QMake build system, see: http://doc.qt.io/qt-5/qmake-manual.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:10
# f43d0c41a24247be928669161d115aef
msgid "RPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:12
# de0dfcda8d8043b59bcdcb8351285783
msgid "Like Python, R has its own built-in build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:14
# b7025d4de91a4c6eab3787d84b4352b0
msgid "The R build system is remarkably uniform and well-tested. This makes it one of the easiest build systems to create new Spack packages for."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:22
# ae4590c6ad4d473d9505eb543c11ae84
msgid "The ``RPackage`` base class has a single phase:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:35
# c89b84e89fba43028cea5fd08116eea4
msgid "Finding R packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:37
# a68d57296c03458196858a95666dabf1
msgid "The vast majority of R packages are hosted on CRAN - The Comprehensive R Archive Network. If you are looking for a particular R package, search for \"CRAN <package-name>\" and you should quickly find what you want. If it isn't on CRAN, try Bioconductor, another common R repository."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:42
# 14c8383420b34cca96697747aed560a8
msgid "For the purposes of this tutorial, we will be walking through `r-caret <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-caret/package.py>`_ as an example. If you search for \"CRAN caret\", you will quickly find what you are looking for at https://cran.r-project.org/web/packages/caret/index.html. If you search for \"Package source\", you will find the download URL for the latest release. Use this URL with ``spack create`` to create a new package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:54
# f7fb719bcd5b483bb3c66f2460875755
msgid "The first thing you'll notice is that Spack prepends ``r-`` to the front of the package name. This is how Spack separates R package extensions from the rest of the packages in Spack. Without this, we would end up with package name collisions more frequently than we would like. For instance, there are already packages for both:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:60
# 4e830bb332ec46b2b6165d54834422e2
msgid "``ape`` and ``r-ape``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:61
# f3e23043b4e74e4e868333567a1382da
msgid "``curl`` and ``r-curl``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:62
# 8478799be90c4cb4acaf501b7aa5e558
msgid "``gmp`` and ``r-gmp``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:63
# 50dbec3772c8487cb3abcba8c9be325e
msgid "``jpeg`` and ``r-jpeg``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:64
# 021966efe3b24731950f90f754c329c6
msgid "``openssl`` and ``r-openssl``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:65
# de7be9e5dab34969b1026fdea72cf34c
msgid "``uuid`` and ``r-uuid``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:66
# dda745432ca84704ad8eb21491f27494
msgid "``xts`` and ``r-xts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:68
# 353b5ef0620c498988bc359a4f8124b6
msgid "Many popular programs written in C/C++ are later ported to R as a separate project."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:75
# 45e4418432544ad39bd66bdc4aaaae21
msgid "The first thing you'll need to add to your new package is a description. The top of the homepage for ``caret`` lists the following description:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:78
# 297a8026c7124af0acb05d5df59200a8
msgid "caret: Classification and Regression Training"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:80
# 413f68b7da764e4c8772cf1d75b87bfb
msgid "Misc functions for training and plotting classification and regression models."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:82
# b7b93684126b4c9e97284d2901b98a87
msgid "You can either use the short description (first line), long description (second line), or both depending on what you feel is most appropriate."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:89
# 2fa27fb3ec37486bae6099af41642d61
msgid "If you look at the bottom of the page, you'll see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:91
# 54fd2e13670c4f2ead2bb973771eac7a
msgid "Linking:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:93
# dcdb9dd27fc24f969d3e38640fbfa4b9
msgid "Please use the canonical form https://CRAN.R-project.org/package=caret to link to this page."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:95
# 1df3edb2ce2b4a7d9a61c0602be953f1
msgid "Please uphold the wishes of the CRAN admins and use https://CRAN.R-project.org/package=caret as the homepage instead of https://cran.r-project.org/web/packages/caret/index.html. The latter may change without notice."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:104
# 1e1422d0b20e4c74951a35a39e9f321c
msgid "As previously mentioned, the download URL for the latest release can be found by searching \"Package source\" on the homepage."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:109
# 45576cd73f6744fd9a1134dc93b3f941
msgid "List URL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:111
# d989efd4c81d4e56a02afd1fc0aa089b
msgid "CRAN maintains a single webpage containing the latest release of every single package: https://cran.r-project.org/src/contrib/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:114
# 47e36dbdd626456297082c23f8067484
msgid "Of course, as soon as a new release comes out, the version you were using in your package is no longer available at that URL. It is moved to an archive directory. If you search for \"Old sources\", you will find: https://cran.r-project.org/src/contrib/Archive/caret"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:119
# 1169236a353447b0beca73aef172b902
msgid "If you only specify the URL for the latest release, your package will no longer be able to fetch that version as soon as a new release comes out. To get around this, add the archive directory as a ``list_url``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:127
# 77296a99c88a4327b1edced1c46f15fd
msgid "As an extension of the R ecosystem, your package will obviously depend on R to build and run. Normally, we would use ``depends_on`` to express this, but for R packages, we use ``extends``. ``extends`` is similar to ``depends_on``, but adds an additional feature: the ability to \"activate\" the package by symlinking it to the R installation directory. Since every R package needs this, the ``RPackage`` base class contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:140
# d7652e5f8b014af7a738c62b487ef269
msgid "Take a close look at the homepage for ``caret``. If you look at the \"Depends\" section, you'll notice that ``caret`` depends on \"R (≥ 2.10)\". You should add this to your package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:151
# dce21ac4a0e54c1ebe282d0b44b5cb3a
msgid "R dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:153
# 3164b0598832492d9cb1fb213ba1485a
msgid "R packages are often small and follow the classic Unix philosophy of doing one thing well. They are modular and usually depend on several other packages. You may find a single package with over a hundred dependencies. Luckily, CRAN packages are well-documented and list all of their dependencies in the following sections:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:159
# 1feebdd2e2e64a3296429e82e19cce9c
msgid "Depends"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:160
# c936fd4c3ce2476aa1624412d47c46dc
msgid "Imports"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:161
# f6dc34b739d745bfa101e577f57a44d8
msgid "LinkingTo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:163
# c0c17595f7674ec7af72b621f8715b64
msgid "As far as Spack is concerned, all 3 of these dependency types correspond to ``type=('build', 'run')``, so you don't have to worry about them. If you are curious what they mean, https://github.com/spack/spack/issues/2951 has a pretty good summary:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:168
# 7ff5dd2c16a849a9a82ad90c0ef3e096
msgid "``Depends`` is required and will cause those R packages to be *attached*, that is, their APIs are exposed to the user. ``Imports`` *loads* packages so that *the package* importing these packages can access their APIs, while *not* being exposed to the user. When a user calls ``library(foo)`` s/he *attaches* package ``foo`` and all of the packages under ``Depends``. Any function in one of these package can be called directly as ``bar()``. If there are conflicts, user can also specify ``pkgA::bar()`` and ``pkgB::bar()`` to distinguish between them. Historically, there was only ``Depends`` and ``Suggests``, hence the confusing names. Today, maybe ``Depends`` would have been named ``Attaches``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:179
# 34c67c2cdf454b48addd1b3b683fd258
msgid "The ``LinkingTo`` is not perfect and there was recently an extensive discussion about API/ABI among other things on the R-devel mailing list among very skilled R developers:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:183
# 3671419dd622435c96ba7310e88eabca
msgid "https://stat.ethz.ch/pipermail/r-devel/2016-December/073505.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:184
# 29ac7340fc7a476e9636b06b7b4bdbcc
msgid "https://stat.ethz.ch/pipermail/r-devel/2017-January/073647.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:186
# ff1e60549cf248dbb852e6de6509bef6
msgid "Some packages also have a fourth section:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:188
# 3d036f1aa9164f11ab8a0a06d5dd3394
msgid "Suggests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:190
# be27d18fa9be4bc499da965e4ad994d1
msgid "These are optional, rarely-used dependencies that a user might find useful. You should **NOT** add these dependencies to your package. R packages already have enough dependencies as it is, and adding optional dependencies can really slow down the concretization process. They can also introduce circular dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:198
# 7e0b3cb896214913b3e4d3e04bccc73b
msgid "Core, recommended, and non-core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:200
# 4f86b265e58647fab4d2a002e282abab
msgid "If you look at \"Depends\", \"Imports\", and \"LinkingTo\", you will notice 3 different types of packages:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:205
# 8805d6ab25e446b4aa96b402761f002a
msgid "Core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:207
# cf8db71fba654dd09361bd23bea0c668
msgid "If you look at the ``caret`` homepage, you'll notice a few dependencies that don't have a link to the package, like ``methods``, ``stats``, and ``utils``. These packages are part of the core R distribution and are tied to the R version installed. You can basically consider these to be \"R itself\". These are so essential to R so it would not make sense that they could be updated via CRAN. If so, you would basically get a different version of R. Thus, they're updated when R is updated."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:215
# 7c1320ed001c4e9b9af87efa0ccfc39c
msgid "You can find a list of these core libraries at: https://github.com/wch/r-source/tree/trunk/src/library"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:220
# 83d1edeab97f4a0c9ca6dea7e56b0989
msgid "Recommended packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:222
# 3d6ab4feda364b9dbf87405c8f1bcf0e
msgid "When you install R, there is an option called ``--with-recommended-packages``. This flag causes the R installation to include a few \"Recommended\" packages (legacy term). They are for historical reasons quite tied to the core R distribution, developed by the R core team or people closely related to it. The R core distribution \"knows\" about these package, but they are indeed distributed via CRAN. Because they're distributed via CRAN, they can also be updated between R version releases."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:230
# 92e21ee2009148708f659c4e1c562e45
msgid "Spack explicitly adds the ``--without-recommended-packages`` flag to prevent the installation of these packages. Due to the way Spack handles package activation (symlinking packages to the R installation directory), pre-existing recommended packages will cause conflicts for already-existing files. We could either not include these recommended packages in Spack and require them to be installed through ``--with-recommended-packages``, or we could not install them with R and let users choose the version of the package they want to install. We chose the latter."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:239
# f314093adaba4923aa65875a49b3931d
msgid "Since these packages are so commonly distributed with the R system, many developers may assume these packages exist and fail to list them as dependencies. Watch out for this."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:243
# 1c29dbafd0ab4350b597c0dd5a1db512
msgid "You can find a list of these recommended packages at: https://github.com/wch/r-source/blob/trunk/share/make/vars.mk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:248
# 2ee724e832ff4f0bb81b77c579626bcd
msgid "Non-core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:250
# ad5f809677324bae9bf6622883ea1f12
msgid "These are packages that are neither \"core\" nor \"recommended\". There are more than 10,000 of these packages hosted on CRAN alone."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:253
# 43d4d0e1beef43d8991143490f5385ee
msgid "For each of these package types, if you see that a specific version is required, for example, \"lattice (≥ 0.20)\", please add this information to the dependency:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:264
# 41b9d69e831d466fb5e3cc24869dd519
msgid "Non-R dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:266
# f98442b0824945b0b194d7e410b2134f
msgid "Some packages depend on non-R libraries for linking. Check out the `r-stringi <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-stringi/package.py>`_ package for an example: https://CRAN.R-project.org/package=stringi. If you search for the text \"SystemRequirements\", you will see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:271
# 79506f48b3734da591d5a4af29ef064b
msgid "ICU4C (>= 52, optional)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:273
# e6ae2f99a0ea4a2e8b2bf694cbe21d43
msgid "This is how non-R dependencies are listed. Make sure to add these dependencies. The default dependency type should suffice."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:278
# eaf644e3940c404792d08d05a9c86c67
msgid "Passing arguments to the installation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:280
# dae1d31fa39b4967b053ad76d1cfba1b
msgid "Some R packages provide additional flags that can be passed to ``R CMD INSTALL``, often to locate non-R dependencies. `r-rmpi <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-rmpi/package.py>`_ is an example of this, and flags for linking to an MPI library. To pass these to the installation command, you can override ``configure_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:307
# bbaec258a299448da2e5fd4ad228888b
msgid "There is a similar ``configure_vars`` function that can be overridden to pass variables to the build."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:314
# 8daffb61a2b94d89b6580c79d812c23c
msgid "CRAN hosts over 10,000 R packages, most of which are not in Spack. Many users may not need the advanced features of Spack, and may prefer to install R packages the normal way:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:324
# ae964c737c9d4ec9b0891a8186ff2236
msgid "R will search CRAN for the ``ggplot2`` package and install all necessary dependencies for you. If you want to update all installed R packages to the latest release, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:333
# e3796a9301b046cb97b296e068a3c88c
msgid "This works great for users who have internet access, but those on an air-gapped cluster will find it easier to let Spack build a download mirror and install these packages for you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:337
# d0be0045942442718f7e0f64a3f8d1fd
msgid "Where Spack really shines is its ability to install non-R dependencies and link to them properly, something the R installation mechanism cannot handle."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:345
# cb93bb9ebb4a49ac949e32368d803e24
msgid "For more information on installing R packages, see: https://stat.ethz.ch/R-manual/R-devel/library/utils/html/INSTALL.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:10
# 6351f56d156045cf94bd129a9e6fc5aa
msgid "RubyPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:12
# 2a0a6aeca7fb4ac89cb17fe918d68443
msgid "Like Perl, Python, and R, Ruby has its own build system for installing Ruby gems."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:15
# ed1ec0c6a5bb48f9a3ae1888d0e61996
msgid "This build system is a work-in-progress. See https://github.com/spack/spack/pull/3127 for more information."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:10
# eedbd2ccac7b4e1fb6b2849371c0edf0
msgid "SConsPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:12
# 29d4bfc64f5341cab4ca9a93b589d5c1
msgid "SCons is a general-purpose build system that does not rely on Makefiles to build software. SCons is written in Python, and handles all building and linking itself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:16
# 798171d54d6b4ad79c8b61c99864cf2d
msgid "As far as build systems go, SCons is very non-uniform. It provides a common framework for developers to write build scripts, but the build scripts themselves can vary drastically. Some developers add subcommands like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:29
# 4e175af71c3940f6a89ff8bb3b2217f6
msgid "Others don't add any subcommands. Some have configuration options that can be specified through variables on the command line. Others don't."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:36
# 18318d85ec0e4f6798ede8653113a8ee
msgid "As previously mentioned, SCons allows developers to add subcommands like ``build`` and ``install``, but by default, installation usually looks like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:45
# aaad5756307448abb58e2715aa0c6d7a
msgid "To facilitate this, the ``SConsPackage`` base class provides the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:51
# c51a0653a6cd458684dbd1da0431d51a
msgid "Package developers often add unit tests that can be invoked with ``scons test`` or ``scons check``. Spack provides a ``test`` method to handle this. Since we don't know which one the package developer chose, the ``test`` method does nothing by default, but can be easily overridden like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:67
# 8bc8c35209b94e3cbf36ea5e61c1d51f
msgid "SCons packages can be identified by their ``SConstruct`` files. These files handle everything from setting up subcommands and command-line options to linking and compiling."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:71
# 8c87a7dda8854d1ab4984272f516b9b5
msgid "One thing to look for is the ``EnsureSConsVersion`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:78
# d5dacbfa2e794d00a6fe4e1a9456f63c
msgid "This means that SCons 2.3.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:85
# 48d26a8fb3ff447888f4016eb17582bb
msgid "At the bare minimum, packages that use the SCons build system need a ``scons`` dependency. Since this is always the case, the ``SConsPackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:94
# 24d7132db8c74e8b9c142f75beece880
msgid "If you want to specify a particular version requirement, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:104
# a7ea7b97735f4b25bc805710122fecbc
msgid "Finding available options"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:106
# 5939a5c8b8044aad8de14bbd68363bd0
msgid "The first place to start when looking for a list of valid options to build a package is ``scons --help``. Some packages like `kahip <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/kahip/package.py>`_ don't bother overwriting the default SCons help message, so this isn't very useful, but other packages like `serf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/serf/package.py>`_ print a list of valid command-line variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:180
# 6c78cae96f5c4bef919bc20b064deca4
msgid "More advanced packages like `cantera <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cantera/package.py>`_ use ``scons --help`` to print a list of subcommands:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:227
# cc563992be0849858a29826bfbe090f5
msgid "You'll notice that cantera provides a ``scons help`` subcommand. Running ``scons help`` prints a list of valid command-line variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:232
# fbde6195f7e543978ca5de66db167306
msgid "Passing arguments to scons"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:234
# 7c6827e7e9a34b5d826114054a1dbcd0
msgid "Now that you know what arguments the project accepts, you can add them to the package build phase. This is done by overriding ``build_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:253
# 81c56de0d12040d1ba609e465e23db9c
msgid "``SConsPackage`` also provides an ``install_args`` function that you can override to pass additional arguments to ``scons install``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:258
# 4be40776b36e47a0b09b7252f702e3d2
msgid "Compiler wrappers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:260
# 1514b02164ed4a21a6bd86b73107351c
msgid "By default, SCons builds all packages in a separate execution environment, and doesn't pass any environment variables from the user environment. Even changes to ``PATH`` are not propagated unless the package developer does so."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:265
# 67a9336f886549aaaf83e4334fc41da7
msgid "This is particularly troublesome for Spack's compiler wrappers, which depend on environment variables to manage dependencies and linking flags. In many cases, SCons packages are not compatible with Spack's compiler wrappers, and linking must be done manually."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:270
# 9ff1d7115bca4027951e119b539c053b
msgid "First of all, check the list of valid options for anything relating to environment variables. For example, cantera has the following option:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:282
# 96a8372719a44eeb9d680b762df51334
msgid "In the case of cantera, using ``env_vars=all`` allows us to use Spack's compiler wrappers. If you don't see an option related to environment variables, try using Spack's compiler wrappers by passing ``spack_cc``, ``spack_cxx``, and ``spack_fc`` via the ``CC``, ``CXX``, and ``FC`` arguments, respectively. If you pass them to the build and you see an error message like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:294
# 7498101cf91247a6be86e11b939c3cfd
msgid "you'll know that the package isn't compatible with Spack's compiler wrappers. In this case, you'll have to use the path to the actual compilers, which are stored in ``self.compiler.cc`` and friends. Note that this may involve passing additional flags to the build to locate dependencies, a task normally done by the compiler wrappers. serf is an example of a package with this limitation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:305
# 8d449e305eb5409e8b09b6a3a8b19829
msgid "For more information on the SCons build system, see: http://scons.org/documentation.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:10
# 6ed9500cfec8469eb1eb0bbe1f0c1bb1
msgid "WafPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:12
# cfa7404c74fd4789aeeed6950495b031
msgid "Like SCons, Waf is a general-purpose build system that does not rely on Makefiles to build software."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:19
# 3550c521118b423186fb8481d112d3a3
msgid "The ``WafPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:21
# 65ff0cabd2304702b5c7b725acb5da97
msgid "``configure`` - configure the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:34
# 3e7ccd21fb0d402288abae435d915573
msgid "Each of these are standard Waf commands and can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:41
# 16281d4c0fe24a26bc5c2c2f4b4f18e2
msgid "Each phase provides a ``<phase>`` function that runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:48
# 1cf8b113c26f4a0eab66452659a04693
msgid "where ``<jobs>`` is the number of parallel jobs to build with. Each phase also has a ``<phase_args>`` function that can pass arguments to this call. All of these functions are empty except for the ``configure_args`` function, which passes ``--prefix=/path/to/installation/prefix``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:57
# 93efac093a8a4ed28b9eb58016f38258
msgid "``WafPackage`` also provides ``test`` and ``installtest`` methods, which are run after the ``build`` and ``install`` phases, respectively. By default, these phases do nothing, but you can override them to run package-specific unit tests. For example, the `py-py2cairo <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-py2cairo/package.py>`_ package uses:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:76
# 49886a67e6ea4784ae209e262065e4a2
msgid "Each Waf package comes with a custom ``waf`` build script, written in Python. This script contains instructions to build the project."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:79
# 84dbb11882ea44148394b1cca2ba3042
msgid "The package also comes with a ``wscript`` file. This file is used to override the default ``configure``, ``build``, and ``install`` phases to customize the Waf project. It also allows developers to override the default ``./waf --help`` message. Check this file to find useful information about dependencies and the minimum versions that are supported."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:90
# c3e17c60c5bf4bbda7f857ebd07d8955
msgid "``WafPackage`` does not require ``waf`` to build. ``waf`` is only needed to create the ``./waf`` script. Since ``./waf`` is a Python script, Python is needed to build the project. ``WafPackage`` adds the following dependency automatically:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:100
# 968c8d1c16bd4f4c8882739392183166
msgid "Waf only supports Python 2.5 and up."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:104
# f1f32ef798b54eaa95ba9f8ca0b2a382
msgid "Passing arguments to waf"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:106
# 92274850f7f54837b55c64dc064f6268
msgid "As previously mentioned, each phase comes with a ``<phase_args>`` function that can be used to pass arguments to that particular phase. For example, if you need to pass arguments to the build phase, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:122
# 0bb323dd6208482098a0ef0e968dcf5a
msgid "A list of valid options can be found by running ``./waf --help``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:128
# 9a5464a070e74898a39576bda8390409
msgid "For more information on the Waf build system, see: https://waf.io/book/"
msgstr ""

