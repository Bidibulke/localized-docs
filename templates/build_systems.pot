# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 00:42-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/build_systems.rst:11
# d977df2b28ff4dfd9a90dbe414d432df
msgid "Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:13
# 7d76bdaf9b6147609636e80292d84172
msgid "Spack defines a number of classes which understand how to use common `build systems  <https://en.wikipedia.org/wiki/List_of_build_automation_software>`_ (Makefiles, CMake, etc.). Spack package definitions can inherit these classes in order to streamline their builds."
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:18
# 68168f0df9a444dfb8ea51814c7d3224
msgid "This guide provides information specific to each particular build system. It assumes that you've read the :ref:`packaging-guide` and expands on these ideas for each distinct build system that Spack supports:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:22
# 9d81558df4f7490e8ac0500a9b3d8320
msgid "Make-based"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:28
# 569ab0025dc44307acf6acf41a939dd0
msgid "Make-incompatible"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:35
# 73dd37fde5c94f4ca293647c7a31104b
msgid "Build-script generation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:44
# e311467b1a874b6697d7d7d5b24778b4
msgid "Language-specific"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:54
# 1cca1b09927a41ed83ebafec028e4a83
msgid "Other"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:62
# afdf7f6c651346fca5a897f2631d50c2
msgid "For reference, the :py:mod:`Build System API docs <spack.build_systems>` provide a list of build systems and methods/attributes that can be overridden. If you are curious about the implementation of a particular build system, you can view the source code by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:72
# aa0b1162d7be423684f625c766820fde
msgid "This will open up the ``AutotoolsPackage`` definition in your favorite editor. In addition, if you are working with a less common build system like QMake, SCons, or Waf, it may be useful to see examples of other packages. You can quickly find examples by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:83
# 4e8996b5338d44efa977aac28a188639
msgid "You can then view these packages with ``spack edit``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems.rst:85
# 7090fab3355d456682375fa88fea8ee0
msgid "This guide is intended to supplement the :py:mod:`Build System API docs <spack.build_systems>` with examples of how to override commonly used methods. It also provides rules of thumb and suggestions for package developers who are unfamiliar with a particular build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:10
# 92eca83236ae495c8859fee353504d91
msgid "AutotoolsPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:12
# 2eef1e35f25c4ea69b54cd0270a3c10a
msgid "Autotools is a GNU build system that provides a build-script generator. By running the platform-independent ``./configure`` script that comes with the package, you can generate a platform-dependent Makefile."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:18
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:22
#: ../spack/lib/spack/docs/build_systems/custompackage.rst:48
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:19
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:18
#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:16
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:17
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:16
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:30
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:20
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:34
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:17
# c33e2ad8188043238198fe5000c970c1
# ec934313770746ceab0b958bb61a28a2
# 15fc95c6d89f45a2b5859a5583861db7
# 9297c98d76b84b6eab905cc066fe50e3
# a103397c4e4c42fc80e2f3d285c0f854
# d97c57f73a354bee8481c6a733cb1b0b
# 6ffb0708394b4c53bc2c1ff1bdf40821
# e157aa213bc54fa8b751bb2d592c16b9
# f6622ef280b14b62a9aae439d7701426
# 1ddde5b9f088422c9653a68b848e677f
# 59b551f51927472fb3b3467766e07aa0
# 5f1aa9537a8f473ba2f5da4e23e02db6
msgid "Phases"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:20
# f833b911fdb2487b8475b696374d5da7
msgid "The ``AutotoolsPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:22
# 79b80896bd684e40b1f2f916c04cbe63
msgid "``autoreconf`` - generate the configure script"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:23
# fbf44bb43d4c46e38043afcae8b3bddf
msgid "``configure`` - generate the Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:24
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:27
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:22
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:48
# 4c18cef789254364aeed46539df2c92d
# d238873f47414a8d9ba400dc91d230bf
# 29e63bf259a347aab16472a15967c5a7
# 5efbd855a89a4548a8c5bf707630d555
msgid "``build`` - build the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:25
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:28
#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:20
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:23
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:24
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:49
# 47dc793303834b4d907d2b620129c9d7
# 4a0093d7565249aa8954b0490d0cd2d6
# 053378b837c245f888aa52645748e0a2
# 2ba9fcb3c2a84becb360611c4c62575a
# e8daa3ff66f54dd7a9401bb145c8d9af
# e4f2977409e2493dac83759e14039017
msgid "``install`` - install the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:27
# 9acc8a3a82ff404586918041263cf4e2
msgid "Most of the time, the ``autoreconf`` phase will do nothing, but if the package is missing a ``configure`` script, ``autoreconf`` will generate one for you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:31
# 699ebbc7cd334d37bb6e537b14b4cbb9
msgid "The other phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:42
# 85aa5a8fd40341ba84572239557d53f0
msgid "Of course, you may need to add a few arguments to the ``./configure`` line."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:47
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:48
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:39
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:51
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:86
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:60
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:65
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:74
# 99c99302867f41b9a6da49663417061a
# bb80d0241f874223aa2a6bd23c395986
# 50d609c3b7194da4b946f841e22a8f6b
# 4fdd751554a945f885bb63497fd878f7
# 068c0bef83ad437896497f77c11a47f2
# 31d62a039cae4afcb5fd43658d35bd51
# 0daea0d3840947998bc95d393b43d68c
# 90445a582144463d9f7f3252b76ca83b
msgid "Important files"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:49
# a7752edd30c34e588139f5f87fa7f446
msgid "The most important file for an Autotools-based package is the ``configure`` script. This script is automatically generated by Autotools and generates the appropriate Makefile when run."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:55
# d67b4c3749044b8db8440060bd6f2676
msgid "Watch out for fake Autotools packages!"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:57
# c00c89547f4642829c4f2bc2e16b7d2c
msgid "Autotools is a very popular build system, and many people are used to the classic steps to install a package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:67
# df7b1a8be3274dfa8b0af146d1b9590f
msgid "For this reason, some developers will write their own ``configure`` scripts that have nothing to do with Autotools. These packages may not accept the same flags as other Autotools packages, so it is better to use the ``Package`` base class and create a :ref:`custom build system <custompackage>`. You can tell if a package uses Autotools by running ``./configure --help`` and comparing the output to other known Autotools packages. You should also look for files like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:75
# 8b59d6c428d848179ab65ad0f98027bd
msgid "``configure.ac``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:76
# d92f91c525ff4aafac1eb3d67a11b6e5
msgid "``configure.in``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:77
# a770e5959a6c422b8f18589d812d47ff
msgid "``Makefile.am``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:79
# b65a1820997b4315a4a40ceca7db4a6f
msgid "Packages that don't use Autotools aren't likely to have these files."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:83
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:77
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:53
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:81
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:114
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:248
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:78
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:125
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:83
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:88
# 853d7f54e08a45739c684230335bf7db
# ea5c5cd73dea4b0490eaf765d9e5f94a
# 1ce4f8e958874f70bff70ee9f2ff6fab
# 8029e0170445468b9f3910a6b786d0ed
# fc9aa71df69e4caaa40d603c06e61601
# e4955b4256744520bb0e71e5bc60369e
# cd0ed4a61c26477d886c1141fa7f0206
# 513244ba47e64828af61d902edea284a
# d2a36b26a62f4b8a91e6a52a345eda3e
# d6f98b92578b450e8749fdc2b1d6a862
msgid "Build system dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:85
# d98e1349c7ac43b285e84ea4a63111ab
msgid "Whether or not your package requires Autotools to install depends on how the source code is distributed. Most of the time, when developers distribute tarballs, they will already contain the ``configure`` script necessary for installation. If this is the case, your package does not require any Autotools dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:91
# 7edc12e4466c4d769f8100348541a2b9
msgid "However, a basic rule of version control systems is to never commit code that can be generated. The source code repository itself likely does not have a ``configure`` script. Developers typically write (or auto-generate) a ``configure.ac`` script that contains configuration preferences and a ``Makefile.am`` script that contains build instructions. Then, ``autoconf`` is used to convert ``configure.ac`` into ``configure``, while ``automake`` is used to convert ``Makefile.am`` into ``Makefile.in``. ``Makefile.in`` is used by ``configure`` to generate a platform-dependent ``Makefile`` for you. The following diagram provides a high-level overview of the process:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:105
# 3c211dc91d614948913bfecaf9da7050
msgid "`GNU autoconf and automake process for generating makefiles <https://commons.wikimedia.org/wiki/File:Autoconf-automake-process.svg>`_ by `Jdthood` under `CC BY-SA 3.0 <https://creativecommons.org/licenses/by-sa/3.0/deed.en>`_"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:108
# 50ccb76cb5184474a00f5bed34fcd3b6
msgid "If a ``configure`` script is not present in your tarball, you will need to generate one yourself. Luckily, Spack already has an ``autoreconf`` phase to do most of the work for you. By default, the ``autoreconf`` phase runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:119
# 1b38073a30fb48a3ae48364f3a5cc516
msgid "All you need to do is add a few Autotools dependencies to the package. Most stable releases will come with a ``configure`` script, but if you check out a commit from the ``develop`` branch, you would want to add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:130
# b99ff8ee617347a9acda3ce52064b3d3
msgid "In some cases, developers might need to distribute a patch that modifies one of the files used to generate ``configure`` or ``Makefile.in``. In this case, these scripts will need to be regenerated. It is preferable to regenerate these manually using the patch, and then create a new patch that directly modifies ``configure``. That way, Spack can use the secondary patch and additional build system dependencies aren't necessary."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:140
# c22c27dcd64a4e31b1f2dd18ff360c55
msgid "force_autoreconf"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:142
# 662aa5031b8e4eb6aee3ef2a07e95200
msgid "If for whatever reason you really want to add the original patch and tell Spack to regenerate ``configure``, you can do so using the following setting:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:150
# 796e672b5c544effbd60c57806fca401
msgid "This line tells Spack to wipe away the existing ``configure`` script and generate a new one. If you only need to do this for a single version, this can be done like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:162
# 2c55f3466f1d406882887011decf593c
msgid "Finding configure flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:164
# ffc5be668d5948838fe37a28484f8e29
msgid "Once you have a ``configure`` script present, the next step is to determine what option flags are available. These flags can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:172
# 7a45b07d0315452ba705d96cb4098eaa
msgid "``configure`` will display a list of valid flags separated into some or all of the following sections:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:175
# c5c09a0862154c46b9bf4f5680734887
msgid "Configuration"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:176
# 68e80f3981644452a4ead86b4bb7bfa8
msgid "Installation directories"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:177
# 4bb74855e9aa4fe08468148655419c0d
msgid "Fine tuning of the installation directories"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:178
# 9f3eb8a8caee40f2aaf641a66915f1b6
msgid "Program names"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:179
# 3430aff80e2e43e99cd5a1997cd0343e
msgid "X features"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:180
# 1f57d309e67b420ca9b8f106a4d7355a
msgid "System types"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:181
# 0695e715e77e46108686a0562a125134
msgid "**Optional Features**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:182
# fc8903e2f78a4123875bcd1a346b67c6
msgid "**Optional Packages**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:183
# e4426023898948e988ad1290c6ac088a
msgid "**Some influential environment variables**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:185
# 743b304f277d4b97b1eaeb8963e79a35
msgid "For the most part, you can ignore all but the last 3 sections. The \"Optional Features\" sections lists flags that enable/disable features you may be interested in. The \"Optional Packages\" section often lists dependencies and the flags needed to locate them. The \"environment variables\" section lists environment variables that the build system uses to pass flags to the compiler and linker."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:194
# 48878cbd0faf4a508ff882725ac838fa
msgid "Addings flags to configure"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:196
# 00111dc1fbb24123879ac6a08c1e1a5b
msgid "For most of the flags you encounter, you will want a variant to optionally enable/disable them. You can then optionally pass these flags to the ``configure`` call by overriding the ``configure_args`` function like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:213
# 054a5c10cf9a4d98a7be36279a58426a
msgid "Note that we are explicitly disabling MPI support if it is not requested. This is important, as many Autotools packages will enable options by default if the dependencies are found, and disable them otherwise. We want Spack installations to be as deterministic as possible. If two users install a package with the same variants, the goal is that both installations work the same way. See `here <https://www.linux.com/news/best-practices-autotools>`__ and `here <https://wiki.gentoo.org/wiki/Project:Quality_Assurance/Automagic_dependencies>`__ for a rationale as to why these so-called \"automagic\" dependencies are a problem."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:223
# ad4dcb2068cd4d0f9ea299aa88e99723
msgid "By default, Autotools installs packages to ``/usr``. We don't want this, so Spack automatically adds ``--prefix=/path/to/installation/prefix`` to your list of ``configure_args``. You don't need to add this yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:229
# e37fd5569f2e4c81831156190aff7a45
msgid "Helper functions"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:231
# 74ac1c9caeb24c45ab217733fb5d9ec3
msgid "You may have noticed that most of the Autotools flags are of the form ``--enable-foo``, ``--disable-bar``, ``--with-baz=<prefix>``, or ``--without-baz``. Since these flags are so common, Spack provides a couple of helper functions to make your life easier."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:236
# 26af958c8ad04da992ce6fec8b2725e4
msgid "TODO: document ``with_or_without`` and ``enable_or_disable``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:240
# 760663811c6043f7958efbc1309e82a2
msgid "Configure script in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:242
# 318f456d9f85431dbba3f0d0382e9441
msgid "Occasionally, developers will hide their source code and ``configure`` script in a subdirectory like ``src``. If this happens, Spack won't be able to automatically detect the build system properly when running ``spack create``. You will have to manually change the package base class and tell Spack where the ``configure`` script resides. You can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:255
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:233
# be5b25fdfa0c448aab36aa0abb133af1
# 7e5ac03ed3234d9da198eebe8423b2b2
msgid "Building out of source"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:257
# f0ec37b0f4184ceba437b5919807afec
msgid "Some packages like ``gcc`` recommend building their software in a different directory than the source code to prevent build pollution. This can be done using the ``build_directory`` variable:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:265
# 097b0774b17040afac0d8b95fdb766fe
msgid "By default, Spack will build the package in the same directory that contains the ``configure`` script"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:270
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:245
# 45ff82318ad748c9acd9ad6866537865
# 7baf5b73e778437ab3361d9a9044832f
msgid "Build and install targets"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:272
# d44a4d96209f4340967b7d003dec1996
msgid "For most Autotools packages, the usual:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:280
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:255
# 20396a5a46ca4b27a0b4564207d46ff9
# 37ff50a72fd84196884916f4817c788f
msgid "is sufficient to install the package. However, if you need to run make with any other targets, for example, to build an optional library or build the documentation, you can add these like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:291
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:266
#: ../spack/lib/spack/docs/build_systems/custompackage.rst:169
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:518
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:55
# 143f1e45111c47e0ae34fc9b79c153a2
# 1e17f802228b412c9ab113dbfae6b751
# 6413f0e47f4c4bab96c179a81cd38172
# b6e42cd36bcd4e64842666de928f40e6
# e931a209175e4bef9a23925891ab52ed
msgid "Testing"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:293
# 0d8ce026f94b4a3783eb70ee615c6c9b
msgid "Autotools-based packages typically provide unit testing via the ``check`` and ``installcheck`` targets. If you build your software with ``spack install --test=root``, Spack will check for the presence of a ``check`` or ``test`` target in the Makefile and run ``make check`` for you. After installation, it will check for an ``installcheck`` target and run ``make installcheck`` if it finds one."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:302
#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:276
#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:306
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:131
#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:206
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:744
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:113
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:343
#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:303
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:126
# 03a1467caf5b4275b0cb7664a584cd50
# 331b4026363a496386ebf3f2875541c0
# 67e52f71256c46b5a0bd0d5c6715b53e
# 5da64938d3874c99bcbc463ebf6f9f1c
# 8ec3eb3eb9104e999dcd3b4633090d6e
# 5ca5cf0fb27d4919b57de29bb8ba3b53
# 3b394f24861f4664a653a0f337c31a50
# 2c4a3fa7cc564dda95ff4ef6549a6001
# af98aa4097d74cf98cfe5c9ee1228572
# ae48eb3968f1433fa9d40d19d63c5333
msgid "External documentation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/autotoolspackage.rst:304
# 70385034f81d4e83a1b8a2091fa61a92
msgid "For more information on the Autotools build system, see: https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:10
# 295e9c5637f94f959cba1bbf8eff6861
msgid "CMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:12
# cffd4aa3fb0f499cadf6a011a7363cd5
msgid "Like Autotools, CMake is a widely-used build-script generator. Designed by Kitware, CMake is the most popular build system for new C, C++, and Fortran projects, and many older projects are switching to it as well."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:16
# 1900b32182624dfebbd11caf87696657
msgid "Unlike Autotools, CMake can generate build scripts for builders other than Make: Ninja, Visual Studio, etc. It is therefore cross-platform, whereas Autotools is Unix-only."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:24
# 03884eb300db401abc0cb877a10cc409
msgid "The ``CMakePackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:26
# 1577ca7705b34bd1983a1149707e3711
msgid "``cmake`` - generate the Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:30
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:26
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:38
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:25
# 1c0e7e462da94dfb9718400adefb549c
# 72258977c10b490687391d0c95be04c1
# 3543e2c3f7434a109e4548964a9ffdec
# f589b2e1d3b54318a578de91a2a9ec25
msgid "By default, these phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:42
# 47453896ba254499b082bce23c39f7aa
msgid "A few more flags are passed to ``cmake`` by default, including flags for setting the build type and flags for locating dependencies. Of course, you may need to add a few arguments yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:50
# 25e3618b578743368665cab74bf27347
msgid "A CMake-based package can be identified by the presence of a ``CMakeLists.txt`` file. This file defines the build flags that can be passed to the cmake invocation, as well as linking instructions. If you are familiar with CMake, it can prove very useful for determining dependencies and dependency version requirements."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:56
# e7a8ae1d85e844a0ac0df52b2e494ceb
msgid "One thing to look for is the ``cmake_minimum_required`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:63
# 5d60ef66fdf842488e3ed773c9bd2762
msgid "This means that CMake 2.8.12 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:66
# b98f04a1c6d64c5ca6288c768b6610ba
msgid "CMake-based packages may also contain ``CMakeLists.txt`` in subdirectories. This modularization helps to manage complex builds in a hierarchical fashion. Sometimes these nested ``CMakeLists.txt`` require additional dependencies not mentioned in the top-level file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:71
# 62254daedbf548c682626469be42fac4
msgid "There's also usually a ``cmake`` or ``CMake`` directory containing additional macros, find scripts, etc. These may prove useful in determining dependency version requirements."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:79
# b1c998f88d8a49b18f1f73f33c33c642
msgid "Every package that uses the CMake build system requires a ``cmake`` dependency. Since this is always the case, the ``CMakePackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:88
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:93
# e1b9a8a8cc2a4b5cb2443c7a61269126
# 3c06c931f1b149cd8d3852bfde792814
msgid "If you need to specify a particular version requirement, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:98
# b0d8db625c5546c7bb4d1514b7b4209a
msgid "Finding cmake flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:100
# a88dca9559dc436ebbf3c160a6c4fc00
msgid "To get a list of valid flags that can be passed to ``cmake``, run the following command in the directory that contains ``CMakeLists.txt``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:108
# 35ccf1ef1ce942d99825aab70d7e3972
msgid "CMake will start by checking for compilers and dependencies. Eventually it will begin to list build options. You'll notice that most of the build options at the top are prefixed with ``CMAKE_``. You can safely ignore most of these options as Spack already sets them for you. This includes flags needed to locate dependencies, RPATH libraries, set the installation directory, and set the build type."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:115
# 739019a48802469b9fb1b8ca4878bafc
msgid "The rest of the flags are the ones you should consider adding to your package. They often include flags to enable/disable support for certain features and locate specific dependencies. One thing you'll notice that makes CMake different from Autotools is that CMake has an understanding of build flag hierarchy. That is, certain flags will not display unless their parent flag has been selected. For example, flags to specify the ``lib`` and ``include`` directories for a package might not appear unless CMake found the dependency it was looking for. You may need to manually specify certain flags to explore the full depth of supported build flags, or check the ``CMakeLists.txt`` yourself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:128
# 48ce1fcaba404a75ae658c65032f08a1
msgid "Adding flags to cmake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:130
# f5f010bc3cdb455e845b328aea11aa13
msgid "To add additional flags to the ``cmake`` call, simply override the ``cmake_args`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:148
# 64e835c57c7946d3967a26fdb07e2295
msgid "Generators"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:150
# e799ace97a1a471b952e54213b481000
msgid "CMake and Autotools are build-script generation tools; they \"generate\" the Makefiles that are used to build a software package. CMake actually supports multiple generators, not just Makefiles. Another common generator is Ninja. To switch to the Ninja generator, simply add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:160
# f16b015607b34ca69b472a194c33fb19
msgid "``CMakePackage`` defaults to \"Unix Makefiles\". If you switch to the Ninja generator, make sure to add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:167
# 7aafb4c12f874d8da51c42d7481de607
msgid "to the package as well. Aside from that, you shouldn't need to do anything else. Spack will automatically detect that you are using Ninja and run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:177
# 1e8fdd2ab5d74b8a96c0efd4838fde15
msgid "Spack currently only supports \"Unix Makefiles\" and \"Ninja\" as valid generators, but it should be simple to add support for alternative generators. For more information on CMake generators, see: https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:184
# 6c323391660f4526856980c2941ac443
msgid "CMAKE_BUILD_TYPE"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:186
# ba4f99dd37354e21b8463d5e52631496
msgid "Every CMake-based package accepts a ``-DCMAKE_BUILD_TYPE`` flag to dictate which level of optimization to use. In order to ensure uniformity across packages, the ``CMakePackage`` base class adds a variant to control this:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:197
# af654b35a85843c4b2223d37822d3e32
msgid "However, not every CMake package accepts all four of these options. Grep the ``CMakeLists.txt`` file to see if the default values are missing or replaced. For example, the `dealii <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/dealii/package.py>`_ package overrides the default variant with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:209
# 15918e159d4a4f7c9b11a7f3a3a19828
msgid "For more information on ``CMAKE_BUILD_TYPE``, see: https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:214
# 62da8efaefc744e09abafac728e11cbf
msgid "CMakeLists.txt in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:216
# bd8557dd0e5d4db6b7ec098f8e6c7985
msgid "Occasionally, developers will hide their source code and ``CMakeLists.txt`` in a subdirectory like ``src``. If this happens, Spack won't be able to automatically detect the build system properly when running ``spack create``. You will have to manually change the package base class and tell Spack where ``CMakeLists.txt`` resides. You can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:228
# 3f67264adbf546e39b41636d514848df
msgid "Note that this path is relative to the root of the extracted tarball, not to the ``build_directory``. It defaults to the current directory."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:235
# 2cead70efe43469d8792b6dbe38404cf
msgid "By default, Spack builds every ``CMakePackage`` in a ``spack-build`` sub-directory. If, for whatever reason, you would like to build in a different sub-directory, simply override ``build_directory`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:247
# 6304142cb5544473a875a80791a530b9
msgid "For most CMake packages, the usual:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:268
# 682ef9e30f444396971e0db3b002baf3
msgid "CMake-based packages typically provide unit testing via the ``test`` target. If you build your software with ``--test=root``, Spack will check for the presence of a ``test`` target in the Makefile and run ``make test`` for you. If you want to run a different test instead, simply override the ``check`` method."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cmakepackage.rst:278
# 801af5e73400469a87b83ff6bef64ac3
msgid "For more information on the CMake build system, see: https://cmake.org/cmake/help/latest/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:10
# 57ad2d61cc414142ba1a2514cc73106c
msgid "CudaPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:12
# f86a02e3848b4e61adc12537c4381450
msgid "Different from other packages, ``CudaPackage`` does not represent a build system. Instead its goal is to simplify and unify usage of ``CUDA`` in other packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:18
# 66edfe0f744b4741860f85aa967f303b
msgid "Provided variants and dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:20
# 37721ea548db484d9273c427ca6b29bd
msgid "``CudaPackage`` provides ``cuda`` variant (default to ``off``) to enable/disable ``CUDA``, and ``cuda_arch`` variant to optionally specify the architecture. It also declares dependencies on the ``CUDA`` package ``depends_on('cuda@...')`` based on the architecture as well as specifies conflicts for certain compiler versions."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:27
# 27e516d9d36b4001b2567a8bd80530fd
msgid "Usage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/cudapackage.rst:29
# 704c0aca24e746478a717a159fd35a76
msgid "In order to use it, just add another base class to your package, for example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:10
# 52a73fcf58d441429fd53aa30f92b221
msgid "Custom Build Systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:12
# 1166cbd8c82242e2bbf03afb3e34bbb2
msgid "While the build systems listed above should meet your needs for the vast majority of packages, some packages provide custom build scripts. This guide is intended for the following use cases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:16
# 29423ccc256f4f02bb77b96c7f062145
msgid "Packaging software with its own custom build system"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:17
# 06fc3769a0dd4b35b7240bd831722eb6
msgid "Adding support for new build systems"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:19
# fb21e1ba14244dc680e4ecf27e0cb09c
msgid "If you want to add support for a new build system, a good place to start is to look at the definitions of other build systems. This guide focuses mostly on how Spack's build systems work."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:23
# 083371db686c498ca6f1f1be26ba7133
msgid "In this guide, we will be using the `perl <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/perl/package.py>`_ and `cmake <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cmake/package.py>`_ packages as examples. ``perl``'s build system is a hand-written ``Configure`` shell script, while ``cmake`` bootstraps itself during installation. Both of these packages require custom build systems."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:32
# 318b9ce747a249f08284a397f61e74c5
msgid "Base class"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:34
# 8e53c7f4bb59425d9bf14978da9efdac
msgid "If your package does not belong to any of the aforementioned build systems that Spack already supports, you should inherit from the ``Package`` base class. ``Package`` is a simple base class with a single phase: ``install``. If your package is simple, you may be able to simply write an ``install`` method that gets the job done. However, if your package is more complex and installation involves multiple steps, you should add separate phases as mentioned in the next section."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:42
# cb90177da3d24ccfaf1cd4dce87d84ac
msgid "If you are creating a new build system base class, you should inherit from ``PackageBase``. This is the superclass for all build systems in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:50
# 51a9a17977f4475fabf4cf53a7fdeb2c
msgid "The most important concept in Spack's build system support is the idea of phases. Each build system defines a set of phases that are necessary to install the package. They usually follow some sort of \"configure\", \"build\", \"install\" guideline, but any of those phases may be missing or combined with another phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:56
# fa86c196456346eb82a0ef86145e5053
msgid "If you look at the ``perl`` package, you'll see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:62
# 8583678e70764cba820e813eb26d82df
msgid "Similarly, ``cmake`` defines:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:68
# c52eb48ec5d4451c8a363947c942d0b5
msgid "If we look at the ``cmake`` example, this tells Spack's ``PackageBase`` class to run the ``bootstrap``, ``build``, and ``install`` functions in that order. It is now up to you to define these methods."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:74
# 5ad06061a96649a68c1ca2ef2901dffe
msgid "Phase and phase_args functions"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:76
# ccf8d9f58f8245f2875e230625536916
msgid "If we look at ``perl``, we see that it defines a ``configure`` method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:84
# b0cdec6583484b6bbd894e542200f17f
msgid "There is also a corresponding ``configure_args`` function that handles all of the arguments to pass to ``Configure``, just like in ``AutotoolsPackage``. Comparatively, the ``build`` and ``install`` phases are pretty simple:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:97
# 2fa05f3fa2df4d189b15ea3e36124cfb
msgid "The ``cmake`` package looks very similar, but with a ``bootstrap`` function instead of ``configure``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:112
# 66974ad316ba4a8492a5cfd5b1bba911
msgid "Again, there is a ``boostrap_args`` function that determines the correct bootstrap flags to use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:117
# 2ebf488edc89488eacbbb2429e76d4dc
msgid "run_before/run_after"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:119
# bbb5029964494501b9bd19947e7bb49a
msgid "Occasionally, you may want to run extra steps either before or after a given phase. This applies not just to custom build systems, but to existing build systems as well. You may need to patch a file that is generated by configure, or install extra files in addition to what ``make install`` copies to the installation prefix. This is where ``@run_before`` and ``@run_after`` come in."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:126
# 6f153dee11ff4f6a94c2b0f41930ad05
msgid "These Python decorators allow you to write functions that are called before or after a particular phase. For example, in ``perl``, we see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:142
# e832dcec00634c8da4d92ab1755c630b
msgid "This extra step automatically installs ``cpanm`` in addition to the base Perl installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:147
# dff43a80a266415592a1d3aedb74eb7d
msgid "on_package_attributes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:149
# 049b219473ee47c399ba117e5f51ab7a
msgid "The ``run_before``/``run_after`` logic discussed above becomes particularly powerful when combined with the ``@on_package_attributes`` decorator. This decorator allows you to conditionally run certain functions depending on the attributes of that package. The most common example is conditional testing. Many unit tests are prone to failure, even when there is nothing wrong with the installation. Unfortunately, non-portable unit tests and tests that are \"supposed to fail\" are more common than we would like. Instead of always running unit tests on installation, Spack lets users conditionally run tests with the ``--test=root`` flag."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:160
# fb8d0b666fd64a53b2a659ec9264e747
msgid "If we wanted to define a function that would conditionally run if and only if this flag is set, we would use the following line:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:171
# dcb840902fe04ade83e5b89899796eb7
msgid "Let's put everything together and add unit tests to our package. In the ``perl`` package, we can see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:181
# dc861fbaaa47400b89e0c8cd6c10992a
msgid "As you can guess, this runs ``make test`` *after* building the package, if and only if testing is requested. Again, this is not specific to custom build systems, it can be added to existing build systems as well."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:185
# 992a2df8a5c14cabad2931604ddfaaaa
msgid "Ideally, every package in Spack will have some sort of test to ensure that it was built correctly. It is up to the package authors to make sure this happens. If you are adding a package for some software and the developers list commands to test the installation, please add these tests to your ``package.py``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:193
# 156fda14cb114d8a9fe0ddab92b80347
msgid "The order of decorators matters. The following ordering:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:200
# 32b1220acbfc44a79746d85c135bd219
msgid "works as expected. However, if you reverse the ordering:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/custompackage.rst:207
# e9d86ff87e254f249aba6430a67f35cb
msgid "the tests will always be run regardless of whether or not ``--test=root`` is requested. See https://github.com/spack/spack/issues/3833 for more information"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:10
# 101866927e2747f8905c9893361fdb4a
msgid "IntelPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:12
# 7d90f2698e474ce9b1033075bed42c70
msgid "Contents"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:16
# 0d229448b98546028005a9f0bc4e0ed4
msgid "Intel packages in Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:18
# dabb303b3f8b4ddd88b8dc8003fac076
msgid "Spack can install and use several software development products offered by Intel. Some of these are available under no-cost terms, others require a paid license. All share the same basic steps for configuration, installation, and, where applicable, license management. The Spack Python class ``IntelPackage`` implements these steps."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:24
# 7ea34fa4a6494432b7a160b791f8b043
msgid "Spack interacts with Intel tools in several routes, like it does for any other package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:29
# 00334be8f0b44b56a0454ca432f754e1
msgid "Accept system-provided tools after you declare them to Spack as *external packages*."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:33
# d4613271f4f14532b9473b90c3a1e5ed
msgid "Install the products for you as *internal packages* in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:37
# e27df07a21f54905a6b4355fba4f61fc
msgid "*Use* the packages, regardless of installation route, to install what we'll call *client packages* for you, this being Spack's primary purpose."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:40
# fc650b067d014f529a09b3304c2ee0f0
msgid "An auxiliary route follows from route 2, as it would for most Spack packages, namely:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:45
# dd9bfa265ea74d34bfb9d556a0acc84e
msgid "Make Spack-installed Intel tools available outside of Spack for ad-hoc use, typically through Spack-managed modulefiles."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:48
# 9e2e5b8e52d54e7baab028ad9996ff30
msgid "This document covers routes 1 through 3."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:53
# 9ea9211cbee34fcd81e587c22df66437
msgid "Packages under no-cost license"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:55
# e2aff0e96cfc4f828b10d2818ae5c6aa
msgid "Intel's standalone performance library products, notably MKL and MPI, are available for use under a `simplified license <https://software.intel.com/en-us/license/intel-simplified-software-license>`_ since 2017 [fn1]_. They are packaged in Spack as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:60
# c6e52c1ba5c64cb0ac3922b111d1d5c6
msgid "``intel-mkl`` -- Math Kernel Library (linear algebra and FFT),"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:61
# 95a7b1d801c348f3b1c6db72a90e35bc
msgid "``intel-mpi`` -- The Intel-MPI implementation (derived from MPICH),"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:62
# 1d85324f87704928a0fdd12acab7deaa
msgid "``intel-ipp`` -- Primitives for image-, signal-, and data-processing,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:63
# 355134c4a78d4a96bffc0b1b09ab981a
msgid "``intel-daal`` -- Machine learning and data analytics."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:65
# 0405bef08c7c40bbbe2d84f678901a01
msgid "Some earlier versions of these libraries were released under a paid license. For these older versions, the license must be available at installation time of the products and during compilation of client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:69
# b24b680084204094b85278164e51683d
msgid "The library packages work well with the Intel compilers but do not require them -- those packages can just as well be used with other compilers.  The Intel compiler invocation commands offer custom options to simplify linking Intel libraries (sometimes considerably), but Spack always uses fairly explicit linkage anyway."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:78
# 6d75918e71964e688fe2aa121ffe1af2
msgid "Licensed packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:80
# c9e2d663e7a64b609245849f22ee179d
msgid "Intel's core software development products that provide compilers, analyzers, and optimizers do require a paid license.  In Spack, they are packaged as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:83
# 3ab9a62324f1427aaf834dc32e5fec77
msgid "``intel-parallel-studio`` -- the entire suite of compilers and libraries,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:84
# 0537ce8217d940a2904b1d59aee403c6
msgid "``intel`` -- a subset containing just the compilers and the Intel-MPI runtime [fn2]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:97
# 778c3377f49644beaf5e92f76e6dc158
msgid "The license is needed at installation time and to compile client packages, but never to merely run any resulting binaries. The license status for a given Spack package is normally specified in the *package code* through directives like `license_required` (see :ref:`Licensed software <license>`). For the Intel packages, however, the *class code* provides these directives (in exchange of forfeiting a measure of OOP purity) and takes care of idiosyncasies like historic version dependence."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:105
# 966c14e831804a329feef5ccf8d6af8c
msgid "The libraries that are provided in the standalone packages are also included in the all-encompassing ``intel-parallel-studio``. To complicate matters a bit, that package is sold in 3 \"editions\", of which only the upper-tier ``cluster`` edition supports *compiling* MPI applications, and hence only that edition can provide the ``mpi`` virtual package.  (As mentioned [fn2]_, all editions provide support for *running* MPI applications.)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:112
# 0f472bf842a14d0fa0f7854683127324
msgid "The edition forms the leading part of the version number for Spack's ``intel*`` packages discussed here. This differs from the primarily numeric version numbers seen with most other Spack packages. For example, we have:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:133
# 04caea242d774ea0bbfc5900f09d9b68
msgid "The full studio suite, capable of compiling MPI applications, currently requires about 12 GB of disk space when installed (see section `Install steps for packages with compilers and libraries`_ for detailed instructions). If you need to save disk space or installation time, you could install the ``intel`` compilers-only subset (0.6 GB) and just the library packages you need, for example ``intel-mpi`` (0.5 GB) and ``intel-mkl`` (2.5 GB)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:143
# 0973610de15f4dfc9f95dc2008086bdf
msgid "Unrelated packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:145
# 691d736363d74578bc09c7fb9ea49721
msgid "The following packages do not use the Intel installer and are not in class ``IntelPackage`` that is discussed here:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:148
# 7589d9d8054b4012b694312a7450089f
msgid "``intel-gpu-tools`` -- Test suite and low-level tools for the Linux `Direct Rendering Manager <https://en.wikipedia.org/wiki/Direct_Rendering_Manager>`_"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:150
# 2cc1a09fc1f84dba97416bf6531efe0b
msgid "``intel-mkl-dnn`` -- Math Kernel Library for Deep Neural Networks (``CMakePackage``)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:151
# 5faf4aa17bff48f99eaa1ff2d90a3c38
msgid "``intel-xed`` -- X86 machine instructions encoder/decoder"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:152
# 89f1d1c22cf04ddcbbf33b7ba9dda91e
msgid "``intel-tbb`` -- Standalone version of Intel Threading Building Blocks. Note that a TBB runtime version is included with ``intel-mkl``, and development versions are provided by the packages ``intel-parallel-studio`` (all editions) and its ``intel`` subset."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:159
# fd5723ff13ed4c1b9afe0c8e359dc21f
msgid "Configuring Spack to use Intel licenses"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:161
# 8ad63201fa4d4e10a1d9d6ddebe263b7
msgid "If you wish to integrate licensed Intel products into Spack as external packages (`route 1`_ above) we assume that their license configuration is in place and is working [fn3]_. In this case, skip to section `Integration of Intel tools installed external to Spack`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:166
# 260477a00eef4a6c8f09e05d26f8ff06
msgid "If you plan to have Spack install licensed products for you (`route 2`_ above), the Intel product installer that Spack will run underneath must have access to a license that is either provided by a *license server* or as a *license file*. The installer may be able to locate a license that is already configured on your system.  If it cannot, you must configure Spack to provide either the server location or the license file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:173
# 280d83b59e5042a9859dab5b6964b619
msgid "For authoritative information on Intel licensing, see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:175
# 01bea0289b32448282d617c7384a3356
msgid "https://software.intel.com/en-us/faq/licensing"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:176
# ba20f843742a44cd919f8584f2b78121
msgid "https://software.intel.com/en-us/articles/how-do-i-manage-my-licenses"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:180
# 7854f66e12e84e168270dc2ff6647e88
msgid "Pointing to an existing license server"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:182
# a7e7383697ea46a495f640769887636f
msgid "Installing and configuring a license server is outside the scope of Spack. We assume that:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:185
# 7cfcb38efab741a7818955cd3f10b834
msgid "Your system administrator has a license server running."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:186
# 1693b040cb0042a584180b7b14535611
msgid "The license server offers valid licenses for the Intel packages of interest."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:187
# a87798898eef4cb68c799bae772d465c
msgid "You can access these licenses under the user id running Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:189
# c5ca32e22458418fb3388c2a280989d0
msgid "Be aware of the difference between (a) installing and configuring a license server, and (b) configuring client software to *use* a server's so-called floating licenses.  We are concerned here with (b) only. The process of obtaining a license from a server for temporary use is called \"checking out a license\".  For that, a client application such as the Intel package installer or a compiler needs to know the host name and port number of one or more license servers that it may query [fn4]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:197
# 96ec23a527d94277b4e3ea713ff94cb7
msgid "Follow one of three methods to `point client software to a floating license server <https://software.intel.com/en-us/articles/licensing-setting-up-the-client-floating-license>`_. Ideally, your license administrator will already have implemented one that can be used unchanged in Spack: Look for the environment variable ``INTEL_LICENSE_FILE`` or for files ``/opt/intel/licenses/*.lic`` that contain::"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:207
# 9db2ecaeca5344a089433ede1f2427d5
msgid "The relevant tokens, among possibly others, are the ``USE_SERVER`` line, intended specifically for clients, and one or more ``SERVER`` lines above it which give the network address."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:211
# f7c3eb8e698e42aea76518cb61e2996f
msgid "If you cannot find pre-existing ``/opt/intel/licenses/*.lic`` files and the ``INTEL_LICENSE_FILE`` environment variable is not set (even after you loaded any relevant modulefiles), ask your license administrator for the server address(es) and place them in a \"global\" license file within your Spack directory tree `as shown below <Spack-managed file_>`_)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:220
# f984d885bdb04d95af0fc576f180577d
msgid "Installing a standalone license file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:222
# 01866b03b76a4349af5775273dad2ef8
msgid "If you purchased a user-specific license, follow `Intel's instructions <https://software.intel.com/en-us/faq/licensing#license-management>`_ to \"activate\" it for your serial number, then download the resulting license file. If needed, `request to have the file re-sent <https://software.intel.com/en-us/articles/resend-license-file>`_ to you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:228
# b761caffd4064f6986032a637e41bb74
msgid "Intel's license files are text files that contain tokens in the proprietary \"FLEXlm\" format and whose name ends in ``.lic``. Intel installers and compilers look for license files in several locations when they run. Place your license by one of the following means, in order of decreasing preference:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:233
# 7ac0bd2cd8da4fabaa9a0bb60b0d8297
msgid "Default directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:235
# d7354027392745189bf09ca4cb0bca93
msgid "Install your license file in the directory ``/opt/intel/licenses/`` if you have write permission to it. This directory is inspected by all Intel tools and is therefore preferred, as no further configuration will be needed. Create the directory if it does not yet exist.  For the file name, either keep the downloaded name or use another suitably plain yet descriptive name that ends in ``.lic``. Adjust file permissions for access by licensed users."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:244
# 32db649a60e648d5b071fdef56a40ff2
msgid "Directory given in environment variable"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:246
# fc8f0764c2a74884a15a25cff66aa57f
msgid "If you cannot use the default directory, but your system already has set the environment variable ``INTEL_LICENSE_FILE`` independent from Spack [fn5]_, then, if you have the necessary write permissions, place your license file in one of the directories mentioned in this environment variable.  Adjust file permissions to match licensed users."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:254
# d621e3968699427ea2c1d87370645451
msgid "If your system has not yet set and used the environment variable ``INTEL_LICENSE_FILE``, you could start using it with the ``spack install`` stage of licensed tools and subsequent client packages. You would, however, be in a bind to always set that variable in the same manner, across updates and re-installations, and perhaps accommodate additions to it. As this may be difficult in the long run, we recommend that you do *not* attempt to start using the variable solely for Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:264
# 2d7b069d6ca145b0ac2aa2c0b2d082c3
msgid "Spack-managed file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:266
# d1651e68c7a1479aa5c6faf0f85ccd84
msgid "The first time Spack encounters an Intel package that requires a license, it will initialize a Spack-global Intel-specific license file for you, as a template with instructional comments, and bring up an editor [fn6]_.  Spack will do this *even if you have a working license elsewhere* on the system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:271
# 069f48149d08418fafdb701b63c6889a
msgid "To proceed with an externally configured license, leave the newly templated file as is (containing comments only) and close the editor. You do not need to touch the file again."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:275
# 3dbdb946226d4d85a884be9a290e9164
msgid "To configure your own standalone license, copy the contents of your downloaded license file into the opened file, save it, and close the editor."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:278
# 010848556eef4ee1ad25855dfd40c30f
msgid "To use a license server (i.e., a floating network license) that is not already configured elsewhere on the system, supply your license server address(es) in the form of ``SERVER`` and ``USE_SERVER`` lines at the *beginning of the file* [fn7]_, in the format shown in section `Pointing to an existing license server`_. Save the file and close the editor."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:284
# 637259b0e61244a6be5a87f6d7c04392
msgid "To revisit and manually edit this file, such as prior to a subsequent installation attempt, find it at ``$SPACK_ROOT/etc/spack/licenses/intel/intel.lic`` ."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:288
# 63b64a37c5cd4e22aa48a7bd391bded3
msgid "Spack will place symbolic links to this file in each directory where licensed Intel binaries were installed.  If you kept the template unchanged, Intel tools will simply ignore it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:297
# d6e47096f92f4858b70aa3147281a7eb
msgid "Integration of Intel tools installed *external* to Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:299
# 7300b718e7764aafb3adf5bef53e6cdf
msgid "This section discusses `route 1`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:301
# acda15aae15d40be99e1e57c1f01614f
msgid "A site that already uses Intel tools, especially licensed ones, will likely have some versions already installed on the system, especially at a time when Spack is just being introduced. It will be useful to make such previously installed tools available for use by Spack as they are. How to do this varies depending on the type of the tools:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:309
# 9accd21f297d48d7b2fcbcbc07c0f4d7
msgid "Integrating external compilers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:311
# f8294a41444646858f40a0693cf84883
msgid "For Spack to use external Intel compilers, you must tell it both *where* to find them and *when* to use them.  The present section documents the \"where\" aspect, involving ``compilers.yaml`` and, in most cases, long absolute paths. The \"when\" aspect actually relates to `route 3`_ and requires explicitly stating the compiler as a spec component (in the form ``foo %intel`` or ``foo %intel@compilerversion``) when installing client packages or altering Spack's compiler default in ``packages.yaml``. See section `Selecting Intel compilers <Selecting Intel compilers_>`_ for details."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:320
# bcec4bb9d3ca4685a1ab8ee054835ff1
msgid "To integrate a new set of externally installed Intel compilers into Spack follow section :ref:`Compiler configuration <compiler-config>`. Briefly, prepare your shell environment like you would if you were to use these compilers normally, i.e., typically by a ``module load ...`` or a shell ``source ...`` command, then use ``spack compiler find`` to make Spack aware of these compilers.  This will create a new entry in a suitably scoped and possibly new ``compilers.yaml`` file. You could certainly create such a compiler entry manually, but this is error-prone due to the indentation and different data types involved."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:331
# bdf6d7f7d8ab40c4a9880a091407df60
msgid "The Intel compilers need and use the system's native GCC compiler (``gcc`` on most systems, ``clang`` on macOS) to provide certain functionality, notably to support C++. To provide a different GCC compiler for the Intel tools, or more generally set persistent flags for all invocations of the Intel compilers, locate the ``compilers.yaml`` entry that defines your Intel compiler, and, using a text editor, change one or both of the following:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:338
# ff72f2e9eedf4ae0a47f8e61456b5273
msgid "At the ``modules:`` tag, add a ``gcc`` module to the list."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:339
# fad8530b67c1404c90271aa4ea391289
msgid "At the ``flags:`` tag, add ``cflags:``, ``cxxflags:``, and ``fflags:`` key-value entries."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:341
# 588dc6f83a9e4998be522afa767ca2bf
msgid "Consult the examples under :ref:`Compiler configuration <compiler-config>` and :ref:`Vendor-Specific Compiler Configuration <vendor-specific-compiler-configuration>` in the Spack documentation. When done, validate your compiler definition by running ``spack compiler info intel@compilerversion`` (replacing ``compilerversion`` by the version that you defined)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:350
# 6e81179e3a244a39b8229f32dcac8fee
msgid "Be aware that both the GCC integration and persistent compiler flags can also be affected by an advanced third method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:353
# 6d4553b9334a46eda561bf11d8cd1d57
msgid "A modulefile that provides the Intel compilers for you could, for the benefit of users outside of Spack, implicitly integrate a specific ``gcc`` version via compiler flag environment variables or (hopefully not) via a sneaky extra ``PATH`` addition."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:358
# edd9e89fc997432eba4763aeb6e7e7d0
msgid "Next, visit section `Selecting Intel Compilers`_ to learn how to tell Spack to use the newly configured compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:363
# 1776593d157d44eb90e032466aa7d9f6
msgid "Integrating external libraries"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:365
# c965c81cbf364116ae16572ff215ce34
msgid "Configure external library-type packages (as opposed to compilers) in the files ``$SPACK_ROOT/etc/spack/packages.yaml`` or ``~/.spack/packages.yaml``, following the Spack documentation under :ref:`External Packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:370
# 1fc9289735b4426fa601183b3a064cfd
msgid "Similar to ``compilers.yaml``, the ``packages.yaml`` files define a package external to Spack in terms of a Spack spec and resolve each such spec via either the ``paths`` or ``modules`` tokens to a specific pre-installed package version on the system.  Since Intel tools generally need environment variables to interoperate, which cannot be conveyed in a mere ``paths`` specification, the ``modules`` token will be more sensible to use. It resolves the Spack-side spec to a modulefile generated and managed outside of Spack's purview, which Spack will load internally and transiently when the corresponding spec is called upon to compile client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:380
# c1cb0df80a9144f2b0fd251e4033b4f2
msgid "Unlike for compilers, where ``spack find compilers [spec]`` generates an entry in an existing or new ``compilers.yaml`` file, Spack does not offer a command to generate an entirely new ``packages.yaml`` entry.  You must create new entries yourself in a text editor, though the command ``spack config [--scope=...] edit packages`` can help with selecting the proper file. See section :ref:`Configuration Scopes <configuration-scopes>` for an explanation about the different files and section :ref:`Build customization <build-settings>` for specifics and examples for ``packages.yaml`` files."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:400
# 676c6b7da5d045a5af03467da43d8b75
msgid "The following example integrates packages embodied by hypothetical external modulefiles ``intel-mkl/18/...`` into Spack as packages ``intel-mkl@...``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:408
# 59f8b2d4c0d7470080ceb04307c7cf3a
msgid "Make sure the file begins with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:414
# 9593b041f32e4b2b83a9f16337ad7ce7
msgid "Adapt the following example. Be sure to maintain the indentation:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:425
# 7006f0a9cb154f14b9fa3b772e04c15d
msgid "The version numbers for the ``intel-mkl`` specs defined here correspond to file and directory names that Intel uses for its products because they were adopted and declared as such within Spack's package repository. You can inspect the versions known to your current Spack installation by:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:434
# 815281c35e6c4faa9b83f2800cf25dd8
msgid "Using the same version numbers for external packages as for packages known internally is useful for clarity, but not strictly necessary.  Moreover, with a ``packages.yaml`` entry, you can go beyond internally known versions."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:440
# 5df8d9756dc74201b1aea1269f3a3cbf
msgid "Note that the Spack spec in the example does not contain a compiler specification. This is intentional, as the Intel library packages can be used unmodified with different compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:444
# 7f948e3921664ad7b295e8bbbf0c8a8f
msgid "A slightly more advanced example illustrates how to provide :ref:`variants <basic-variants>` and how to use the ``buildable: False`` directive to prevent Spack from installing other versions or variants of the named package through its normal internal mechanism."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:459
# cf44ef12d1754414baa8a3f338c8f3bf
msgid "One additional example illustrates the use of ``paths:`` instead of ``modules:``, useful when external modulefiles are not available or not suitable:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:472
# 09c300bb3b104e93ba24a5f5b8e3f662
msgid "Note that for the Intel packages discussed here, the directory values in the ``paths:`` entries must be the high-level and typically version-less \"installation directory\" that has been used by Intel's product installer. Such a directory will typically accumulate various product versions.  Amongst them, Spack will select the correct version-specific product directory based on the ``@version`` spec component that each path is being defined for."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:479
# 25754a2aeba24ab6a0460313e8fe386b
msgid "For further background and details, see :ref:`External Packages <sec-external-packages>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:485
# 99cb0590dd9f410a8169518d0811e5e0
msgid "Installing Intel tools *within* Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:487
# 84f686dbdd3f416197a5cc953e44ee3b
msgid "This section discusses `route 2`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:489
# 85cc81740b0646a8b8696dd4ad00fee3
msgid "When a system does not yet have Intel tools installed already, or the installed versions are undesirable, Spack can install these tools like any regular Spack package for you and, with appropriate pre- and post-install configuration, use its compilers and/or libraries to install client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:498
# 3b36911d28d9418687ce141a77315669
msgid "Install steps for packages with compilers and libraries"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:500
# e3e731c57208425ba33d94b6c95d312e
msgid "The packages ``intel-parallel-studio`` and ``intel`` (which is a subset of the former) are many-in-one products that contain both compilers and a set of library packages whose scope depends on the edition. Because they are general products geared towards shell environments, it can be somewhat involved to integrate these packages at their full extent into Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:507
# e949e2b45e2042db9e86129234c18d2a
msgid "Note: To install library-only packages like ``intel-mkl``, ``intel-mpi``, and ``intel-daal`` follow `the next section <intel-install-libs_>`_ instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:510
# 270c8f560a0a40bdb7dd6de077fd6944
msgid "Review the section `Configuring spack to use intel licenses`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:514
# 6e9cd66d2797401da9363793442a891a
msgid "To install a version of ``intel-parallel-studio`` that provides Intel compilers at a version that you have *not yet declared in Spack*, the following preparatory steps are recommended:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:518
# 437f1718eeb6461e972654b4b1ca3ab0
msgid "Determine the compiler spec that the new ``intel-parallel-studio`` package will provide, as follows: From the package version, combine the last two digits of the version year, a literal \"0\" (zero), and the version component that immediately follows the year."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:524
# 783744988649495180c7cb5b87702e45
msgid "Package version"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:524
# 7552dd7a87394255a2fe8c5487307ad5
msgid "Compiler spec provided"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:526
# 25ffdc45fec240e79ca0ccdc911ade7e
msgid "``intel-parallel-studio@edition.YYyy.u``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:526
# 81b6428b4e004d2380c928b2a0f16339
msgid "``intel@yy.0.u``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:529
# 94088b8f3eb14130bb7a09f96876a73e
msgid "Example: The package ``intel-parallel-studio@cluster.2018.3`` will provide the compiler with spec ``intel@18.0.3``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:534
# cbb5cd37ffc84442871552408b444a41
msgid "Add a new compiler section with the newly anticipated version at the end of a ``compilers.yaml`` file in a suitable scope.  For example, run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:541
# 21678c72466a4f67ae18b5d2a1c8d299
msgid "and append a stub entry:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:556
# ac3f4bbb820749f0a25fb42dd54e8713
msgid "Replace ``18.0.3`` with the version that you determined in the preceeding step. The contents under ``paths:`` do not matter yet."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:559
# 18f8099626a54d0180d868d41dd1e8a5
msgid "You are right to ask: \"Why on earth is that necessary?\" [fn8]_. The answer lies in Spack striving for strict compiler consistency. Consider what happens without such a pre-declared compiler stub: Say, you ask Spack to install a particular version ``intel-parallel-studio@edition.V``.  Spack will apply an unrelated compiler spec to concretize and install your request, resulting in ``intel-parallel-studio@edition.V %X``. That compiler ``%X`` is not going to be the version that this new package itself provides. Rather, it would typically be ``%gcc@...`` in a default Spack installation or possibly indeed ``%intel@...``, but at a version that precedes ``V``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:570
# 42924b98a8104c6db8cc9c4840424245
msgid "The problem comes to the fore as soon as you try to use any virtual ``mkl`` or ``mpi`` packages that you would expect to now be provided by ``intel-parallel-studio@edition.V``.  Spack will indeed see those virtual packages, but only as being tied to the compiler that the package ``intel-parallel-studio@edition.V`` was concretized with *at installation*. If you were to install a client package with the new compilers now available to you, you would naturally run ``spack install foo +mkl %intel@V``, yet Spack will either complain about ``mkl%intel@V`` being missing (because it only knows about ``mkl%X``) or it will go and attempt to install *another instance* of ``intel-parallel-studio@edition.V %intel@V`` so as to match the compiler spec ``%intel@V`` that you gave for your client package ``foo``. This will be unexpected and will quickly get annoying because each reinstallation takes up time and extra disk space."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:584
# 0d3935e39a914ec38f8c711a872908e7
msgid "To escape this trap, put the compiler stub declaration shown here in place, then use that pre-declared compiler spec to install the actual package, as shown next.  This approach works because during installation only the package's own self-sufficient installer will be used, not any compiler."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:591
# 037caaa00b334734b6bd6e6329ac6da0
msgid "Verify that the compiler version provided by the new ``studio`` version would be used as expected if you were to compile a client package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:598
# 1d29ec03d3de4c8ca87b782c35396339
msgid "If the version does not match, explicitly state the anticipated compiler version, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:604
# ba84b383b2ae47c3b09d5363d325ed64
msgid "if there are problems, review and correct the compiler's ``compilers.yaml`` entry, be it still in stub form or already complete (as it would be for a re-installation)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:608
# 482aa7b87bf44270b3e2d95e3d01457e
msgid "Install the new ``studio`` package using Spack's regular ``install`` command. It may be wise to provide the anticipated compiler (`see above <verify-compiler-anticipated_>`_) as an explicit concretization element:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:618
# c065135ac4d444c8827f2178f8499422
msgid "Follow the same steps as under `Integrating external compilers`_ to tell Spack the minutiae for actually using those compilers with client packages. If you placed a stub entry in a ``compilers.yaml`` file, now is the time to edit it and fill in the particulars."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:623
# d4868e832e2c41f7947bc8d234adb2b6
msgid "Under ``paths:``, give the full paths to the actual compiler binaries (``icc``, ``ifort``, etc.) located within the Spack installation tree, in all their unsightly length [fn9]_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:627
# b031b4cbfde44c91ab461df906acfa44
msgid "To determine the full path to the C compiler, adapt and run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:634
# 3741bb4de8e24a8db8f162e6c902863f
msgid "If you get hits for both ``intel64`` and ``ia32``, you almost certainly will want to use the ``intel64`` variant.  The ``icpc`` and ``ifort`` compilers will be located in the same directory as ``icc``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:638
# c99a962a37bd45adadb16e5479a694df
msgid "Use the ``modules:`` and/or ``cflags:`` tokens to specify a suitable accompanying ``gcc`` version to help pacify picky client packages that ask for C++ standards more recent than supported by your system-provided ``gcc`` and its ``libstdc++.so``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:643
# 1c35a4abb6674e75b695d884ca65304e
msgid "To set the Intel compilers for default use in Spack, instead of the usual ``%gcc``, follow section `Selecting Intel compilers`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:648
# 4e8144c031af44a0918b1dc18598174f
msgid "Compiler packages like ``intel-parallel-studio`` can easily be above 10 GB in size, which can tax the disk space available for temporary files on small, busy, or restricted systems (like virtual machines). The Intel installer will stop and report insufficient space as::"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:658
# a4993362981944c0a7ef596f89009ce0
msgid "As first remedy, clean Spack's existing staging area:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:664
# 6d8d411ed87c4673ae970ec1d5818ad4
msgid "then retry installing the large package. Spack normally cleans staging directories but certain failures may prevent it from doing so."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:667
# 91fbc8e9213b4ac28b78b14c1aa68814
msgid "If the error persists, tell Spack to use an alternative location for temporary files:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:670
# 3d7b5aa248c2490d80d78882a4e85216
msgid "Run ``df -h`` to identify an alternative location on your system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:672
# 45087d63b5f24f93892558f2d0f192cc
msgid "Tell Spack to use that location for staging. Do **one** of the following:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:674
# 6ccb8398f38f49a9aebd230108b7f64e
msgid "Run Spack with the environment variable ``TMPDIR`` altered for just a single command. For example, to use your ``$HOME`` directory:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:681
# 59e15c03d93944b494d92fcaa8c4a9fa
msgid "This example uses Bourne shell syntax. Adapt for other shells as needed."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:683
# 39b1e8d758ca4d84b45e679cec07e1c3
msgid "Alternatively, customize Spack's ``build_stage`` :ref:`configuration setting <config-overrides>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:690
# ed6cce0acea242d493aac0e8f56a7a20
msgid "Append:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:698
# 0ff112591d714b97a8e9422aab219d9e
msgid "Do not duplicate the ``config:`` line if it already is present. Adapt the location, which here is the same as in the preceeding example."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:701
# 79b41ae9d3e44db380e4609138e7cb6f
msgid "Retry installing the large package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:708
# a982cbf5479f4f1b9e709d95f4b8dece
msgid "Install steps for library-only packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:710
# 480b5cc3cfd842e08a5c67a432e3c157
msgid "To install library-only packages like ``intel-mkl``, ``intel-mpi``, and ``intel-daal`` follow the steps given here. For packages that contain a compiler, follow `the previous section <intel-install-studio_>`_ instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:715
# fa4f4dd9fad340e4abda17c6ce260e40
msgid "For pre-2017 product releases, review the section `Configuring Spack to use Intel licenses`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:717
# 04e2a9f1b100479ea1a829b30fc5bcd0
msgid "Inspect the package spec. Specify an explicit compiler if necessary, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:724
# 9684575d930c40a0884218a9b3cf698d
msgid "Check that the package will use the compiler flavor and version that you expect."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:726
# 8e5c910d68e649e189abb272aa4799ec
msgid "Install the package normally within Spack. Use the same spec as in the previous command, i.e., as general or as specific as needed:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:734
# 35ac9b7a60c84dcab5dde9bfe2e118d3
msgid "To prepare the new packages for use with client packages, follow `Selecting libraries to satisfy virtual packages`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:740
# c7cb9a26896c42c48f56226d5743d427
msgid "Debug notes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:742
# e9eb03b452074963b2491174a77fa71b
msgid "You can trigger a wall of additional diagnostics using Spack options, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:748
# eef5d39567a040bcaa3066a7a6630843
msgid "The ``--debug`` option can also be useful while installing client packages `(see below) <Using Intel tools in Spack to install client packages_>`_ to confirm the integration of the Intel tools in Spack, notably MKL and MPI."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:753
# 6c54c85893434c048407101230493e2b
msgid "The ``.spack/`` subdirectory of an installed ``IntelPackage`` will contain, besides Spack's usual archival items, a copy of the ``silent.cfg`` file that was passed to the Intel installer:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:762
# 5c9c3eb4eb964fd39be80a24ca602607
msgid "If an installation error occurs, Spack will normally clean up and remove a partially installed target directory. You can direct Spack to keep it using ``--keep-prefix``, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:770
# d9a3fb271fda4dd6a7a06693c7520806
msgid "You must, however, *remove such partial installations* prior to subsequent installation attempts. Otherwise, the Intel installer will behave incorrectly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:777
# 90b63027645a4502907c9ee961a7d945
msgid "Using Intel tools in Spack to install client packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:779
# fc896b62f02849e887718f9077d2bfe2
msgid "Finally, this section pertains to `route 3`_ from the introduction."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:781
# 722619330fc0417eb057b262cb246e97
msgid "Once Intel tools are installed within Spack as external or internal packages they can be used as intended for installing client packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:789
# 8f08bebfd2b143e38514bf8f4800c5c8
msgid "Selecting Intel compilers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:791
# f3b0872b0015483f9a8c38036f6e9f1a
msgid "Select Intel compilers to compile client packages, like any compiler in Spack, by one of the following means:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:794
# 0bbd9079883e4ebca89ccdabcfc08411
msgid "Request the Intel compilers explicitly in the client spec, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:801
# 655ed6a9333a4d3ab2e2021fc68e2ac0
msgid "Alternatively, request Intel compilers implicitly by concretization preferences. Configure the order of compilers in the appropriate ``packages.yaml`` file, under either an ``all:`` or client-package-specific entry, in a ``compiler:`` list. Consult the Spack documentation for :ref:`Configuring Package Preferences <configs-tutorial-package-prefs>` and :ref:`Concretization Preferences <concretization-preferences>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:809
# 9eef2bddabcf4f6abe3316cd8430e709
msgid "Example: ``etc/spack/packages.yaml`` might simply contain:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:817
# 676cdbacf84b4551be64ea27ed5833ec
msgid "To be more specific, you can state partial or full compiler version numbers, for example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:830
# ac43d2c8cba742798d3fb88a9ed3bd45
msgid "Selecting libraries to satisfy virtual packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:832
# a05395d1581c42bfbf9d1b150518d4a5
msgid "Intel packages, whether integrated into Spack as external packages or installed within Spack, can be called upon to satisfy the requirement of a client package for a library that is available from different providers. The relevant virtual packages for Intel are ``blas``, ``lapack``, ``scalapack``, and ``mpi``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:838
# 14866541a7e344b7b46d25cfe90b824f
msgid "In both integration routes, Intel packages can have optional :ref:`variants <basic-variants>` which alter the list of virtual packages they can satisfy.  For Spack-external packages, the active variants are a combination of the defaults declared in Spack's package repository and the spec it is declared as in ``packages.yaml``. Needless to say, those should match the components that are actually present in the external product installation. Likewise, for Spack-internal packages, the active variants are determined, persistently at installation time, from the defaults in the repository and the spec selected to be installed."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:848
# 21cadfdc38d24c438395c72e82b58f0c
msgid "To have Intel packages satisfy virtual package requests for all or selected client packages, edit the ``packages.yaml`` file.  Customize, either in the ``all:`` or a more specific entry, a ``providers:`` dictionary whose keys are the virtual packages and whose values are the Spack specs that satisfy the virtual package, in order of decreasing preference.  To learn more about the ``providers:`` settings, see the Spack tutorial for :ref:`Configuring Package Preferences <configs-tutorial-package-prefs>` and the section :ref:`Concretization Preferences <concretization-preferences>`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:858
# 4c99820fbba44d95adbf5c3057d7618c
msgid "Example: The following fairly minimal example for ``packages.yaml`` shows how to exclusively use the standalone ``intel-mkl`` package for all the linear algebra virtual packages in Spack, and ``intel-mpi`` as the preferred MPI implementation. Other providers can still be chosen on a per-package basis."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:873
# d979df9f1f4e4a89bb73f029fe2afc45
msgid "If you have access to the ``intel-parallel-studio@cluster`` edition, you can use instead:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:886
# 0d058053191f436196d2bad57c671ffb
msgid "If you installed ``intel-parallel-studio`` within Spack (\"`route 2`_\"), make sure you followed the `special installation step <intel-compiler-anticipation_>`_ to ensure that its virtual packages match the compilers it provides."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:894
# c92034581e104924a2126321d4d777ea
msgid "Using Intel tools as explicit dependency"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:896
# 74dd0e77daa941b08a28e260df1789ad
msgid "With the proper installation as detailed above, no special steps should be required when a client package specifically (and thus deliberately) requests an Intel package as dependency, this being one of the target use cases for Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:903
# 79baaff8f5e941e7bbbb72ba3fe6b42a
msgid "Tips for configuring client packages to use MKL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:905
# 8907bf287b5443b2a3b058aecec670c4
msgid "The Math Kernel Library (MKL) is provided by several Intel packages, currently ``intel-parallel-studio`` when variant ``+mkl`` is active (it is by default) and the standalone ``intel-mkl``. Because of these different provider packages, a *virtual* ``mkl`` package is declared in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:910
# b40f26a292284f4093f23420c8323fa9
msgid "To use MKL-specific APIs in a client package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:912
# 4147e3382bdb496b90736b7771c36fcc
msgid "Declare a dependency on ``mkl``, rather than a specific provider like ``intel-mkl``.  Declare the dependency either absolutely or conditionally based on variants that your package might have declared:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:923
# 3aa2aabf0144473bb83fe5e2e986ebb1
msgid "The ``MKLROOT`` environment variable (part of the documented API) will be set during all stages of client package installation, and is available to both the Spack packaging code and the client code."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:927
# 5a0a1e2620a448dc914b94e7577eecf3
msgid "To use MKL as provider for BLAS, LAPACK, or ScaLAPACK:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:929
# af5a9698160a473b83489569c916559e
msgid "The packages that provide ``mkl`` also provide the narrower virtual ``blas``, ``lapack``, and ``scalapack`` packages. See the relevant :ref:`Packaging Guide section <blas_lapack_scalapack>` for an introduction. To portably use these virtual packages, construct preprocessor and linker option strings in your package configuration code using the package functions ``.headers`` and ``.libs`` in conjunction with utility functions from the following classes:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:938
# 8929cb9a6cd84d1ebf0a5d971ea07e74
msgid ":py:class:`llnl.util.filesystem.FileList`,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:939
# e2df0bb7ee02455680676fc8fe756a9e
msgid ":py:class:`llnl.util.filesystem.HeaderList`,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:940
# 6a9a0726b69345d89c2ecc9bc52ed533
msgid ":py:class:`llnl.util.filesystem.LibraryList`."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:943
# 932eb3874e784d42ad6bb135bfe8b536
msgid "*Do not* use constructs like ``.prefix.include`` or ``.prefix.lib``, with Intel or any other implementation of ``blas``, ``lapack``, and ``scalapack``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:947
# b031b320462e4328b4a29decc5a7a0ed
msgid "For example, for an :ref:`AutotoolsPackage <autotoolspackage>` use ``.libs.ld_flags`` to transform the library file list into linker options passed to ``./configure``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:962
# e2db40f40d504530b2c1202f9523a9e9
msgid "Even though ``.ld_flags`` will return a string of multiple words, *do not* use quotes for options like ``--with-blas=...`` because Spack passes them to ``./configure`` without invoking a shell."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:966
# f81f43a1ba294aa1b3ea1826cdcc50f4
msgid "Likewise, in a :ref:`MakefilePackage <makefilepackage>` or similiar package that does not use AutoTools you may need to provide include and link options for use on command lines or in environment variables. For example, to generate an option string of the form ``-I<dir>``, use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:976
# 3159c6fb38834eeaa4859f4ed10e3ec7
msgid "and to generate linker options (``-L<dir> -llibname ...``), use the same as above,"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:982
# cbca05b856e24c0782dcb7d47a029c10
msgid "See :ref:`MakefilePackage <makefilepackage>` and more generally the :ref:`Packaging Guide <blas_lapack_scalapack>` for background and further examples."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:991
# b6231e9ccdbb44deb6ab66a8f5d6c7a8
msgid "Footnotes"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:993
# 39ee0714a4a649bcac117b1109931f5c
msgid "Strictly speaking, versions from ``2017.2`` onward."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:995
# 4ba9b003a80d45eeb1f4f7d38ee07f26
msgid "The package ``intel`` intentionally does not have a ``+mpi`` variant since it is meant to be small. The native installer will always add MPI *runtime* components because it follows defaults defined in the download package, even when ``intel-parallel-studio ~mpi`` has been requested."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1000
# 226ef1924c37445f8c0625eec5499c9b
msgid "For ``intel-parallel-studio +mpi``, the class function :py:func:``.IntelPackage.pset_components`` will include ``\"intel-mpi intel-imb\"`` in a list of component patterns passed to the Intel installer. The installer will extend each pattern word with an implied glob-like ``*`` to resolve it to package names that are *actually present in the product BOM*. As a side effect, this pattern approach accommodates occasional package name changes, e.g., capturing both ``intel-mpirt`` and ``intel-mpi-rt`` ."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1009
# 6b077a0a29844acbb2cdce5d2df73851
msgid "How could the external installation have succeeded otherwise?"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1011
# 19ae06833ebe4bc2b1503f64214a60bf
msgid "According to Intel's documentation, there is supposedly a way to install a product using a network license even `when a FLEXlm server is not running <https://software.intel.com/en-us/articles/licensing-setting-up-the-client-floating-license>`_: Specify the license in the form ``port@serverhost`` in the ``INTEL_LICENSE_FILE`` environment variable. All other means of specifying a network license require that the license server be up."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1018
# 3a41b8fd20fc48e38de5c28a62096096
msgid "Despite the name, ``INTEL_LICENSE_FILE`` can hold several and diverse entries. They  can be either directories (presumed to contain ``*.lic`` files), file names, or network locations in the form ``port@host`` (on Linux and Mac), with all items separated by \":\" (on Linux and Mac)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1023
# 84fe56f97618401dafe96a709866686e
msgid "Should said editor turn out to be ``vi``, you better be in a position to know how to use it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1026
# 1c787ce2aaf448148335aa291805fec5
msgid "Comment lines in FLEXlm files, indicated by ``#`` as the first non-whitespace character on the line, are generally allowed anywhere in the file. There `have been reports <https://github.com/spack/spack/issues/6534>`_, however, that as of 2018, ``SERVER`` and ``USE_SERVER`` lines must precede any comment lines."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1037
# 943b7301ec3c4a1aa88dda3cde83099f
msgid "Spack's close coupling of installed packages to compilers, which both necessitates the detour for installing ``intel-parallel-studio``, and largely limits any of its provided virtual packages to a single compiler, heavily favors `recommending to install Intel Parallel Studio outside of Spack <integrate-external-intel_>`_ and declare it for Spack in ``packages.yaml`` by a `compiler-less spec <compiler-neutral-package_>`_."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1044
# e8936648e36741eda1ea75271c8f5d9f
msgid "With some effort, you can convince Spack to use shorter paths."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1046
# 8620e283186a411294b12ffeb4d260f2
msgid "Altering the naming scheme means that Spack will lose track of all packages it has installed for you so far. That said, the time is right for this kind of customization when you are defining a new set of compilers."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1051
# f1a12d511fa9465387a428b85971bc46
msgid "The relevant tunables are:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1053
# 60639be7ab2f4f1ca6021dfbcb560f0c
msgid "Set the ``install_tree`` location in ``config.yaml`` (:ref:`see doc <config-yaml>`)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1055
# 51d11e9c62274ddf8531d1c814d506a5
msgid "Set the hash length in ``install-path-scheme``, also in ``config.yaml`` (:ref:`q.v. <config-yaml>`)."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/intelpackage.rst:1057
# 6dad6d2ae0e842eca07c6fbad9beff1c
msgid "You will want to set the *same* hash length for :ref:`tcl module files <modules-naming-scheme>` if you have Spack produce them for you, under ``naming_scheme`` in ``modules.yaml``.  Other module dialects cannot be altered in this manner."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:10
# 9d3476ed2917411ea97568d9dbca26fb
msgid "MakefilePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:12
# 30a39e4e4549412aa23f51dadc6b6bec
msgid "The most primitive build system a package can use is a plain Makefile. Makefiles are simple to write for small projects, but they usually require you to edit the Makefile to set platform and compiler-specific variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:21
# 46dbb42d47cf4fd5b8dcb41ea7c37b12
msgid "The ``MakefilePackage`` base class comes with 3 phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:23
# bcad63b9bdee42fdbafb5aa82b69ec6e
msgid "``edit`` - edit the Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:24
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:23
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:35
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:22
# 1acd7392227541ed9b372456dd110262
# c0485140b35844a297200a8755539c3e
# 9e03ad7dc4b54f72b3230761a7fb720f
# ab0d1c5f9b314c4eb52c69ce0028748f
msgid "``build`` - build the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:25
#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:24
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:36
#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:23
# 46f1f5cb81a44fd8b4cc545e8295441e
# 9c692a13f2f2438f8406976c69bb4e1b
# d77c133a284c459e9e36c54480af70cd
# 1cb1bf617a1d4768949c9cc5089332e5
msgid "``install`` - install the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:27
# d3a751ef10d14291914abfc547ecf74e
msgid "By default, ``edit`` does nothing, but you can override it to replace hard-coded Makefile variables. The ``build`` and ``install`` phases run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:41
# 830895bc2fef44889c8e1251e3a7d367
msgid "The main file that matters for a ``MakefilePackage`` is the Makefile. This file will be named one of the following ways:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:44
# 634d4ef8aa8e4815889d703bc62ce49c
msgid "GNUmakefile (only works with GNU Make)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:45
# ad620435964e4af4bb3ce5e307c9aeef
msgid "Makefile (most common)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:46
# 2540221801c14d88bfe02f77a43ad96f
msgid "makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:48
# d4d0340199c844429c6c74aab38aedad
msgid "Some Makefiles also *include* other configuration files. Check for an ``include`` directive in the Makefile."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:55
# a61a5ee973cd435194f57d5b14f65fa7
msgid "Spack assumes that the operating system will have a valid ``make`` utility installed already, so you don't need to add a dependency on ``make``. However, if the package uses a ``GNUmakefile`` or the developers recommend using GNU Make, you should add a dependency on ``gmake``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:67
# 9ed1e6d2d1d947d48abccbecd689004b
msgid "Types of Makefile packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:69
# ae9075103bd04d47a7f1ec123cc65141
msgid "Most of the work involved in packaging software that uses Makefiles involves overriding or replacing hard-coded variables. Many packages make the mistake of hard-coding compilers, usually for GCC or Intel. This is fine if you happen to be using that particular compiler, but Spack is designed to work with *any* compiler, and you need to ensure that this is the case."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:76
# 13b6ee9cc5c048c98654e06500d8fe0b
msgid "Depending on how the Makefile is designed, there are 4 common strategies that can be used to set or override the appropriate variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:81
# 611a03e61a00423ea9db20177c75fbd4
msgid "Environment variables"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:83
# bd63efa6a6ec41c1b6810cbb0b8e21db
msgid "Make has multiple types of `assignment operators <https://www.gnu.org/software/make/manual/make.html#Setting>`_. Some Makefiles use ``=`` to assign variables. The only way to override these variables is to edit the Makefile or override them on the command-line. However, Makefiles that use ``?=`` for assignment honor environment variables. Since Spack already sets ``CC``, ``CXX``, ``F77``, and ``FC``, you won't need to worry about setting these variables. If there are any other variables you need to set, you can do this in the ``edit`` method:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:100
# 6f5d1f34666c4cc6afafd84081203f4a
msgid "`cbench <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cbench/package.py>`_ is a good example of a simple package that does this, while `esmf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/esmf/package.py>`_ is a good example of a more complex package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:107
# 2f9f1ece8f9146bf98b60cc15477676c
msgid "Command-line arguments"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:109
# c036c9e92a79432dafef6cd455249f31
msgid "If the Makefile ignores environment variables, the next thing to try is command-line arguments. You can do this by overriding the ``build_targets`` attribute. If you don't need access to the spec, you can do this like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:119
# a03a1cf56660422b95e299e66e887682
msgid "If you do need access to the spec, you can create a property like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:133
# 71b6eeb3b5f0446e9438d1ce254db7fc
msgid "`cloverleaf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cloverleaf/package.py>`_ is a good example of a package that uses this strategy."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:138
# 28dc3d4676204aa8b37eab8cd8741b2e
msgid "Edit Makefile"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:140
# 8745fea4c53641d2b0cc8fddea99cc5c
msgid "Some Makefiles are just plain stubborn and will ignore command-line variables. The only way to ensure that these packages build correctly is to directly edit the Makefile. Spack provides a ``FileFilter`` class and a ``filter_file`` method to help with this. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:154
# 308a83643f844fe6baf0681655384806
msgid "`stream <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/stream/package.py>`_ is a good example of a package that involves editing a Makefile to set the appropriate variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:160
# d98b73b2c149481db92863a4caa857e3
msgid "Config file"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:162
# a23c06c7a8684a0c97a5fc59b85c20a6
msgid "More complex packages often involve Makefiles that *include* a configuration file. These configuration files are primarily composed of variables relating to the compiler, platform, and the location of dependencies or names of libraries. Since these config files are dependent on the compiler and platform, you will often see entire directories of examples for common compilers and architectures. Use these examples to help determine what possible values to use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:170
# 54d18db3747f4f86be11e7d9f03a0adb
msgid "If the config file is long and only contains one or two variables that need to be modified, you can use the technique above to edit the config file. However, if you end up needing to modify most of the variables, it may be easier to write a new file from scratch."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:175
# b38031608bcd45ef916842f29cb89351
msgid "If each variable is independent of each other, a dictionary works well for storing variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:194
# 7b09159033b546c2b9d24619ca5dc95b
msgid "`elk <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/elk/package.py>`_ is a good example of a package that uses a dictionary to store configuration variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:198
# b5a1bd4cbb1646838ebb24ffb525dd80
msgid "If the order of variables is important, it may be easier to store them in a list:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:215
# 13bbd62effba4e1488459edb98b12e65
msgid "`hpl <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/hpl/package.py>`_ is a good example of a package that uses a list to store configuration variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:221
# e41263915a6a4446bd79445afb84a762
msgid "Variables to watch out for"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:223
# db29f1a3c9c342ad927b4192b1c4d212
msgid "The following is a list of common variables to watch out for. The first two sections are `implicit variables <https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html>`_ defined by Make and will always use the same name, while the rest are user-defined variables and may vary from package to package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:229
# 183b0da5793b41f69cc0bbabc8fe378e
msgid "**Compilers**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:231
# 51ab0c7db18d4877ba28ae19b65a6ad8
msgid "This includes variables such as ``CC``, ``CXX``, ``F77``, ``F90``, and ``FC``, as well as variables related to MPI compiler wrappers, like ``MPICC`` and friends."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:235
# 7cb5268e2a244997b924605688437378
msgid "**Compiler flags**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:237
# 2aa8248ad59b45f7861c38ac837d3b8c
msgid "This includes variables for specific compilers, like ``CFLAGS``, ``CXXFLAGS``, ``F77FLAGS``, ``F90FLAGS``, ``FCFLAGS``, and ``CPPFLAGS``. These variables are often hard-coded to contain flags specific to a certain compiler. If these flags don't work for every compiler, you may want to consider filtering them."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:243
# e4ae6e0ad6a541c09fba22c4a2042f8a
msgid "**Variables that enable or disable features**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:245
# b034068a83e74eb5add893d2b050e157
msgid "This includes variables like ``MPI``, ``OPENMP``, ``PIC``, and ``DEBUG``. These flags often require you to create a variant so that you can either build with or without MPI support, for example. These flags are often compiler-dependent. You should replace them with the appropriate compiler flags, such as ``self.compiler.openmp_flag`` or ``self.compiler.pic_flag``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:252
# 3fda1e9e2d6047389fbaec3ceec64c56
msgid "**Platform flags**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:254
# 2399c358e01f4f299de7b6b668c8ca86
msgid "These flags control the type of architecture that the executable is compiler for. Watch out for variables like ``PLAT`` or ``ARCH``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:257
# 45eb50d0a5f9411da6a6e35a76175c9a
msgid "**Dependencies**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:259
# 3a855f09c0ce4174b9e64bde68ad9f16
msgid "Look out for variables that sound like they could be used to locate dependencies, such as ``JAVA_HOME``, ``JPEG_ROOT``, or ``ZLIBDIR``. Also watch out for variables that control linking, such as ``LIBS``, ``LDFLAGS``, and ``INCLUDES``. These variables need to be set to the installation prefix of a dependency, or to the correct linker flags to link to that dependency."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:266
# 5a05dbbccf22465480e8e439005e5324
msgid "**Installation prefix**"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:268
# ef8caa0e669144cbadf7537cf9df0571
msgid "If your Makefile has an ``install`` target, it needs some way of knowing where to install. By default, many packages install to ``/usr`` or ``/usr/local``. Since many Spack users won't have sudo privileges, it is imperative that each package is installed to the proper prefix. Look for variables like ``PREFIX`` or ``INSTALL``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:277
# 7f9b169653dc4507bae44684df12d4ac
msgid "Makefiles in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:279
# 83abfd204bff4042911b01d6457c2edf
msgid "Not every package places their Makefile in the root of the package tarball. If the Makefile is in a sub-directory like ``src``, you can tell Spack where to locate it like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:290
# 264734670a4a47b38eeab96018c44799
msgid "Manual installation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:292
# 650f48c602874db3b00693af0f1ff373
msgid "Not every Makefile includes an ``install`` target. If this is the case, you can override the default ``install`` method to manually install the package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/makefilepackage.rst:308
# 9135be32f4e045c281fbfc26ac8b5c20
msgid "For more information on reading and writing Makefiles, see: https://www.gnu.org/software/make/manual/make.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:10
# 1a8cf07c9712426b978ee5facb5ef0db
msgid "MesonPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:12
# 42958a23277a48338b3c643354494074
msgid "Much like Autotools and CMake, Meson is a build system.  But it is meant to be both fast and as user friendly as possible.  GNOME's goal is to port modules to use the Meson build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:20
# 057e74b3cde64cf7aa9d7cbb18d5448b
msgid "The ``MesonPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:22
# 47a864d8b2744ef3b1fbaa8cd6828f21
msgid "``meson`` - generate ninja files"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:38
# 1b6872e07a584f968c0e062831c9e901
msgid "Any of these phases can be overridden in your package as necessary. There is also a ``check`` method that looks for a ``test`` target in the build file. If a ``test`` target exists and the user runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:47
# 5dac319d466d4d1ea65857e92a28e9e4
msgid "Spack will run ``ninja test`` after the build phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:53
# 30351a697c914cd6a5efd04551b40881
msgid "Packages that use the Meson build system can be identified by the presence of a ``meson.build`` file. This file declares things like build instructions and dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:57
# cfe155044ed14dafa3ea97c6d2a4b444
msgid "One thing to look for is the ``meson_version`` key that gets passed to the ``project`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:76
# 8737f3945ed74d75af0b979ea37f289b
msgid "This means that Meson 0.43.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:83
# 2aa0835469e54efb8a1bf4af7c9dccb5
msgid "At the bare minimum, packages that use the Meson build system need ``meson`` and ```ninja``` dependencies. Since this is always the case, the ``MesonPackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:104
# 37f0885e1d444f5eacf996a8dbaa59ac
msgid "Finding meson flags"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:106
# c191d359838a401bbaaec52c84dce818
msgid "To get a list of valid flags that can be passed to ``meson``, run the following command in the directory that contains ``meson.build``:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:116
# 2551cfcb8404456ba540e7098c92570b
msgid "Passing arguments to meson"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:118
# cd42d32f504e48a38ffd419b6d9a600c
msgid "If you need to pass any arguments to the ``meson`` call, you can override the ``meson_args`` method like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:127
#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:109
# c8d712555a51473ba0b093606d60ce41
# c7d9220640924b039d3ee67dd45e609b
msgid "This method can be used to pass flags as well as variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/mesonpackage.rst:133
# 2753b505c7d64950965c6f057b626748
msgid "For more information on the Meson build system, see: https://mesonbuild.com/index.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:10
# d59888daab6642b192fb444b5046d140
msgid "OctavePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:12
# f7de279bc5e24ceaaedd593e9ff7edc1
msgid "Octave has its own build system for installing packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:18
# 1c983158b9db4fb6a30f5a312e4a71a9
msgid "The ``OctavePackage`` base class has a single phase:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:22
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:26
# b96c2bf903d84be4b9217eee208abbf5
# 5d3abd302feb4d2f98e3d3aebdfc3799
msgid "By default, this phase runs the following command:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:29
# 44f96b23a8ce4aaa81382419368d2376
msgid "Beware that uninstallation is not implemented at the moment. After uninstalling a package via Spack, you also need to manually uninstall it from Octave via ``pkg uninstall <package_name>``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:35
# 67f890c85155407fb80d2a4064412396
msgid "Finding Octave packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:37
# 2152b88a8e95469f980133c62f6002f8
msgid "Most Octave packages are listed at https://octave.sourceforge.io/packages.php."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:41
# e0e4033561d04349bd237d596519af32
msgid "Dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:43
# af0639d16fe0421ba3741d5e2320abed
msgid "Usually, the homepage of a package will list dependencies, i.e. ``Dependencies: Octave >= 3.6.0 struct >= 1.0.12``. The same information should be available in the ``DESCRIPTION`` file in the root of each archive."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:49
# 2bd5198b9a544f5780acdcbbb830bb9f
msgid "External Documentation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/octavepackage.rst:51
# 948624ee60354112bb6f3d84ef24a9e5
msgid "For more information on the Octave build system, see: https://octave.org/doc/v4.4.0/Installing-and-Removing-Packages.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:10
# b423422a73904769964cf64a18b7b7fb
msgid "PerlPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:12
# 5a629e619393447a90df74af69824627
msgid "Much like Octave, Perl has its own language-specific build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:19
# f1294a3da5164ce39f51167d2093ea7b
msgid "The ``PerlPackage`` base class comes with 3 phases that can be overridden:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:21
# cdf5f79cedf240fe81567e8396ea8c5a
msgid "``configure`` - configure the package"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:25
# b1557a72a0a74cb8bb09bba0eaa2fe08
msgid "Perl packages have 2 common modules used for module installation:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:29
# 9e9e838c655d42c6acff34a9e842ee59
msgid "``ExtUtils::MakeMaker``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:31
# 50b74352828e434187fed43c0fcd5d94
msgid "The ``ExtUtils::MakeMaker`` module is just what it sounds like, a module designed to generate Makefiles. It can be identified by the presence of a ``Makefile.PL`` file, and has the following installation steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:45
# edca3d0342bf4fd4b99a6ae2884e9bb7
msgid "``Module::Build``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:47
# bc1a72e557fa4809b8cd8971870a2b3a
msgid "The ``Module::Build`` module is a pure-Perl build system, and can be identified by the presence of a ``Build.PL`` file. It has the following installation steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:59
# 9127393f909344c2b6b975dfcd96eec6
msgid "If both ``Makefile.PL`` and ``Build.PL`` files exist in the package, Spack will use ``Makefile.PL`` by default. If your package uses a different module, ``PerlPackage`` will need to be extended to support it."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:64
# c2ab7108337642c599176dc9c0f6fbaf
msgid "``PerlPackage`` automatically detects which build steps to use, so there shouldn't be much work on the package developer's side to get things working."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:70
# 0f418517ec0b42cc87056c1c4d07f74c
msgid "Finding Perl packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:72
# 994849d5b9794a63bf2126f83b00b896
msgid "Most Perl modules are hosted on CPAN - The Comprehensive Perl Archive Network. If you need to find a package for ``XML::Parser``, for example, you should search for \"CPAN XML::Parser\"."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:76
# aa029c8acb1041ba8607b6373bb28918
msgid "Some CPAN pages are versioned. Check for a link to the \"Latest Release\" to make sure you have the latest version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:81
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:52
# 563770b7627844f983f857db74a8829c
# be5f99b95fd048719794bda73af4499a
msgid "Package name"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:83
# 34012902e1b141fe9200f411affd3e64
msgid "When you use ``spack create`` to create a new Perl package, Spack will automatically prepend ``perl-`` to the front of the package name. This helps to keep Perl modules separate from other packages. The same naming scheme is used for other language extensions, like Python and R."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:90
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:113
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:73
# 2f3f5b848ae54549a101c6857e604da4
# 397538ca2a024bdb8fa8ef7af79c41c1
# f4691e8b857045dda1a096684df1101b
msgid "Description"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:92
# 9a86379b53394d068c550da3619188d0
msgid "Most CPAN pages have a short description under \"NAME\" and a longer description under \"DESCRIPTION\". Use whichever you think is more useful while still being succinct."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:98
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:129
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:87
# a7fddfa5a2c0427bb834cfd90546a102
# 0b6675868f9d4f759ec4df48985e015c
# 45a5c1baee024391b1102461b211d23c
msgid "Homepage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:100
# 49f0bfa627ab45ddb63d41ba6f90bc84
msgid "In the top-right corner of the CPAN page, you'll find a \"permalink\" for the package. This should be used instead of the current URL, as it doesn't contain the version number and will always link to the latest release."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:107
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:145
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:102
# 3695a113d7b44fbdb7ccf41c3a7a4663
# 4170d4e001d4407284e205d6e7be31d8
# e1e4a539db994d1eb1412cc5d83ab668
msgid "URL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:109
# eb69f99f0c984b1c88c637baceb85482
msgid "If you haven't found it already, the download URL is on the right side of the page below the permalink. Search for \"Download\"."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:116
# 6dbdbc93c464446d82e1a3120657b981
msgid "Every ``PerlPackage`` obviously depends on Perl at build and run-time, so ``PerlPackage`` contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:126
# 832ad01e762b4769be1b0dcc261f3dd6
msgid "If your package requires a specific version of Perl, you should specify this."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:129
# 82ffa817c8404b79966a9856e6cc2a8a
msgid "Although newer versions of Perl include ``ExtUtils::MakeMaker`` and ``Module::Build`` as \"core\" modules, you may want to add dependencies on ``perl-extutils-makemaker`` and ``perl-module-build`` anyway. Many people add Perl as an external package, and we want the build to work properly. If your package uses ``Makefile.PL`` to build, add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:140
# 2bdf11ad7bea4e5b894d6f89262c08f4
msgid "If your package uses ``Build.PL`` to build, add:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:149
# e824f8cf8f1c4b5a8b8be7eb8920dff8
msgid "Perl dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:151
# 60bc96effdfc4b8a9385f75f1b9fab7e
msgid "Below the download URL, you will find a \"Dependencies\" link, which takes you to a page listing all of the dependencies of the package. Packages listed as \"Core module\" don't need to be added as dependencies, but all direct dependencies should be added. Don't add dependencies of dependencies. These should be added as dependencies to the dependency, not to your package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:160
# 79d72dee7d0949b38a8e4e03c8fa53bf
msgid "Passing arguments to configure"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:162
# f2e18dc959c04b578f9f8ce4a52fb3df
msgid "Packages that have non-Perl dependencies often use command-line variables to specify their installation directory. You can pass arguments to ``Makefile.PL`` or ``Build.PL`` by overriding ``configure_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:180
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:720
#: ../spack/lib/spack/docs/build_systems/rpackage.rst:312
# 03dce90f94aa41e8bfb785af16393133
# 73fea8cd5b374804970b6665c2e4b7de
# 7ae631c069044e1c8ae7c2b74f4af938
msgid "Alternatives to Spack"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:182
# b6156c4deaaf4de2a1563df38a4c2306
msgid "If you need to maintain a stack of Perl modules for a user and don't want to add all of them to Spack, a good alternative is ``cpanm``. If Perl is already installed on your system, it should come with a ``cpan`` executable. To install ``cpanm``, run the following command:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:192
# 2f0d86bb5c0f403eacafc4788e1377ae
msgid "Now, you can install any Perl module you want by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:199
# 7e7c81c4c4654dba985b3429866b706c
msgid "Obviously, these commands can only be run if you have root privileges. Furthermore, ``cpanm`` is not capable of installing non-Perl dependencies. If you need to install to your home directory or need to install a module with non-Perl dependencies, Spack is a better option."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:208
# 4e86357f491e40368da19f173af13ae7
msgid "You can find more information on installing Perl modules from source at: http://www.perlmonks.org/?node_id=128077"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/perlpackage.rst:211
# 769dfc689218450c8d05797d79142892
msgid "More generic Perl module installation instructions can be found at: http://www.cpan.org/modules/INSTALL.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:10
# bbd4700c6caf4135888260d62a7f5fb9
msgid "PythonPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:12
# c640957d997f461cb3cbd854e9ff00ce
msgid "Python packages and modules have their own special build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:18
# 4035a20b9b024e52a73d7315614d58ef
msgid "The ``PythonPackage`` base class provides the following phases that can be overridden:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:21
# bcfdeaaa2e4746ceb7e9878bf8192f86
msgid "``build``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:22
# 75facccfbe5c41de9d0d6a6f8a3753de
msgid "``build_py``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:23
# 465c8360d858476fb6aeb16931f339ea
msgid "``build_ext``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:24
# a561c1f699714ad2ba05118a55b41806
msgid "``build_clib``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:25
# 480a9e128c6d4696a9a330a768210304
msgid "``build_scripts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:26
# b77bee319dc846fc8db4245d0dde6829
msgid "``clean``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:27
# fa21e791b72340b3b94843fe9520c5e5
msgid "``install``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:28
# fbde510c31e544b0a32adf158b5d794a
msgid "``install_lib``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:29
# 78568ad988d34467b002f6759c9095ae
msgid "``install_headers``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:30
# 0f4011e83af945ac9b2037f4d7748e34
msgid "``install_scripts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:31
# a54f058c6cd44752af62157002388260
msgid "``install_data``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:32
# 96cd2bce874a45aeb8a9cc087373f56c
msgid "``sdist``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:33
# 554a28bd192f4afc9ce5acdc66ae1d32
msgid "``register``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:34
# 92a71355275341b29f17ed6024747716
msgid "``bdist``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:35
# 8d7ba8a971f1467f956be612246bc77b
msgid "``bdist_dumb``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:36
# bfe826eebc764f6fb4443fd128cd3616
msgid "``bdist_rpm``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:37
# b9d09943ab784b338383e15bd86a2a88
msgid "``bdist_wininst``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:38
# 66c2f0bbff9c4525a49a82fd8322e4b7
msgid "``upload``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:39
# 2d03220a8854464fad7aeffd52077898
msgid "``check``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:41
# b6f0f2084052427ab7192f1c18420ed3
msgid "These are all standard ``setup.py`` commands and can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:48
# 5e58ebfcdece40528acf2803f31d8305
msgid "By default, only the ``build`` and ``install`` phases are run:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:50
# ae3738b21432435d8c75b11ef6cb23f4
msgid "``build`` - build everything needed to install"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:51
# 4b5f6528289c401fa9d3094d5623e6c4
msgid "``install`` - install everything from build directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:53
# 7c8803cdc94842479c63eda2f84502a9
msgid "If for whatever reason you need to run more phases, simply modify your ``phases`` list like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:61
# 5903093e0e3344df8b4daf9f689ffede
msgid "Each phase provides a function ``<phase>`` that runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:68
# 42e85a22df1041ce9ba7c60a304eb5f8
msgid "Each phase also has a ``<phase_args>`` function that can pass arguments to this call. All of these functions are empty except for the ``install_args`` function, which passes ``--prefix=/path/to/installation/prefix``. There is also some additional logic specific to setuptools and eggs."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:73
# 632a7e35decd4cab94a1ed3cca9b2278
msgid "If you need to run a phase that is not a standard ``setup.py`` command, you'll need to define a function for it like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:88
# caf9d79c4d994a55934ce46df5a72e1d
msgid "Python packages can be identified by the presence of a ``setup.py`` file. This file is used by package managers like ``pip`` to determine a package's dependencies and the version of dependencies required, so if the ``setup.py`` file is not accurate, the package will not build properly. For this reason, the ``setup.py`` file should be fairly reliable. If the documentation and ``setup.py`` disagree on something, the ``setup.py`` file should be considered to be the truth. As dependencies are added or removed, the documentation is much more likely to become outdated than the ``setup.py``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:100
# 2f84c362786e416aa0ce89a28109adc1
msgid "Finding Python packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:102
# 89165e22590a4ca2bbcd0238bf48e943
msgid "The vast majority of Python packages are hosted on PyPI - The Python Package Index. ``pip`` only supports packages hosted on PyPI, making it the only option for developers who want a simple installation. Search for \"PyPI <package-name>\" to find the download page. Note that some pages are versioned, and the first result may not be the newest version. Click on the \"Latest Version\" button to the top right to see if a newer version is available. The download page is usually at: https://pypi.org/project/<package-name>"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:115
# 7c128f32052746a2a0ea8a32f699e914
msgid "The top of the PyPI downloads page contains a description of the package. The first line is usually a short description, while there may be a several line \"Project Description\" that follows. Choose whichever is more useful. You can also get these descriptions on the command-line using:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:131
# 6fe63698642e44789caff6bfe8812fad
msgid "Package developers use ``setup.py`` to upload new versions to PyPI. The ``setup`` method often passes metadata like ``homepage`` to PyPI. This metadata is displayed on the left side of the download page. Search for the text \"Homepage\" under \"Project links\" to find it. You should use this page instead of the PyPI page if they differ. You can also get the homepage on the command-line by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:147
# 9986a1cb26d44fab9aa6119220937245
msgid "You may have noticed that Spack allows you to add multiple versions of the same package without adding multiple versions of the download URL. It does this by guessing what the version string in the URL is and replacing this with the requested version. Obviously, if Spack cannot guess the version correctly, or if non-version-related things change in the URL, Spack cannot substitute the version properly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:154
# 125d405429364c73a4bcb10f352973f9
msgid "Once upon a time, PyPI offered nice, simple download URLs like: https://pypi.python.org/packages/source/n/numpy/numpy-1.13.1.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:157
# bc875490cca94ab280f3c4f6c169d00c
msgid "As you can see, the version is 1.13.1. It probably isn't hard to guess what URL to use to download version 1.12.0, and Spack was perfectly capable of performing this calculation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:161
# 59b07dc6193c46bea01355c37fac79db
msgid "However, PyPI switched to a new download URL format: https://pypi.python.org/packages/c0/3a/40967d9f5675fbb097ffec170f59c2ba19fc96373e73ad47c2cae9a30aed/numpy-1.13.1.zip#md5=2c3c0f4edf720c3a7b525dacc825b9ae"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:164
# 1bd66888672341b2b934b130384b8556
msgid "and more recently: https://files.pythonhosted.org/packages/b0/2b/497c2bb7c660b2606d4a96e2035e92554429e139c6c71cdff67af66b58d2/numpy-1.14.3.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:167
# b77b9519ca5b42fc9a50d4fd85cf4b2a
msgid "As you can imagine, it is impossible for Spack to guess what URL to use to download version 1.12.0 given this URL. There is a solution, however. PyPI offers a new hidden interface for downloading Python packages that does not include a hash in the URL: https://pypi.io/packages/source/n/numpy/numpy-1.13.1.zip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:173
# 15ea373c55e4407982eaae5c5164aa0d
msgid "This URL redirects to the files.pythonhosted.org URL. The general syntax for this pypi.io URL is: https://pypi.io/packages/source/<first-letter-of-name>/<name>/<name>-<version>.<extension>"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:177
# 2731a3b636b44d56b3af912dfc61fd13
msgid "Please use the pypi.io URL instead of the pypi.python.org URL. If both ``.tar.gz`` and ``.zip`` versions are available, ``.tar.gz`` is preferred. If some releases offer both ``.tar.gz`` and ``.zip`` versions, but some only offer ``.zip`` versions, use ``.zip``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:184
# cf921604fee14003a9ce6d035638885a
msgid "PyPI vs. GitHub"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:186
# 74083beea7474b2ba77da84eb351475e
msgid "Many packages are hosted on PyPI, but are developed on GitHub and other version control systems. The tarball can be downloaded from either location, but PyPI is preferred for the following reasons:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:190
# b0069c82b93d41adab868aa807ae7d18
msgid "PyPI contains the bare minimum of files to install the package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:192
# e93875def282437ab8e248b9f63f0413
msgid "You may notice that the tarball you download from PyPI does not have the same checksum as the tarball you download from GitHub. When a developer uploads a new release to PyPI, it doesn't contain every file in the repository, only the files necessary to install the package. PyPI tarballs are therefore smaller."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:198
# d4f2a76f226b46ea8c020b270d0af8fa
msgid "PyPI is the official source for package managers like ``pip``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:200
# a57f85a39a1347049883e4a3b11d9792
msgid "Let's be honest, ``pip`` is much more popular than Spack. If the GitHub tarball contains a file not present in the PyPI tarball that causes a bug, the developers may not realize this for quite some time. If the bug was in a file contained in the PyPI tarball, users would notice the bug much more quickly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:206
# 3c93dad56c60400ba7c6f34f240cd301
msgid "GitHub release may be a beta version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:208
# e48f2256a5394a059598cfa6a476a9d5
msgid "When a developer releases a new version of a package on GitHub, it may not be intended for most users. Until that release also makes its way to PyPI, it should be assumed that the release is not yet ready for general use."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:213
# 2c64554565fb4a82990f73886877274e
msgid "The checksum for a GitHub release may change."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:215
# 2c86603db68d4649be86c20952c1504d
msgid "Unfortunately, some developers have a habit of patching releases without incrementing the version number. This results in a change in tarball checksum. Package managers like Spack that use checksums to verify the integrity of a download tarball grind to a halt when the checksum for a known version changes. Most of the time, the change is intentional, and contains a needed bug fix. However, sometimes the change indicates a download source that has been compromised, and a tarball that contains a virus. If this happens, you must contact the developers to determine which is the case. PyPI is nice because it makes it physically impossible to re-release the same version of a package with a different checksum."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:227
# 139c1f370d28499e8b148ac6409a8735
msgid "There are some reasons to prefer downloading from GitHub:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:229
# 125632f4887a4153b2b1023d421de65f
msgid "The GitHub tarball may contain unit tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:231
# 2b85334ac5644d8c8ebf5831737326de
msgid "As previously mentioned, the PyPI tarball contains the bare minimum of files to install the package. Unless explicitly specified by the developers, it will not contain development files like unit tests. If you desire to run the unit tests during installation, you should use the GitHub tarball instead."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:237
# de02116b66084a9eacc7ae0dbe267339
msgid "Spack does not yet support ``spack versions`` and ``spack checksum`` with PyPI URLs"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:240
# c08d1d5807be4035acc96b531021d033
msgid "These commands work just fine with GitHub URLs. This is a minor annoyance, not a reason to prefer GitHub over PyPI."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:243
# 165b3cf5376d4d74b0790e7f0af607e7
msgid "If you really want to run these unit tests, no one will stop you from submitting a PR for a new package that downloads from GitHub."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:250
# 6eb0a161c11a48998ccb4877aee6b7a1
msgid "There are a few dependencies common to the ``PythonPackage`` build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:254
# d569a029a73d4e6bac2b41ea2bca8717
msgid "Python"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:256
# f2f71b460efe40b090f054e27c506b94
msgid "Obviously, every ``PythonPackage`` needs Python at build-time to run ``python setup.py build && python setup.py install``. Python is also needed at run-time if you want to import the module. Due to backwards incompatible changes between Python 2 and 3, it is very important to specify which versions of Python are supported. If the documentation mentions that Python 3 is required, this can be specified as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:268
# 53a1f9f73cb048e99f731f34e6b5ac91
msgid "If Python 2 is required, this would look like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:275
# d35d499601fd4337b56b1b72b85647f6
msgid "If Python 2.7 is the only version that works, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:282
# 172a2080fba846a59b1c9f26fdbb378e
msgid "The documentation may not always specify supported Python versions. Another place to check is in the ``setup.py`` file. Look for a line containing ``python_requires``. An example from `py-numpy <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-numpy/package.py>`_ looks like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:293
# 603c959e29b946c7bc99623eb33d5892
msgid "More commonly, you will find a version check at the top of the file:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:301
# 248ca8020b0c4b66ae6145f50d14e561
msgid "This can be converted to Spack's spec notation like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:310
#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:466
# e9aaef80180c4170b8a8d3e1b2f4ab85
# 0bd0c5777f724425be29e862839df5d6
msgid "setuptools"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:312
# d229151822034c0c8228f7032d78947e
msgid "Originally, the Python language had a single build system called distutils, which is built into Python. Distutils provided a common framework for package authors to describe their project and how it should be built. However, distutils was not without limitations. Most notably, there was no way to list a project's dependencies with distutils. Along came setuptools, a non-builtin build system designed to overcome the limitations of distutils. Both projects use a similar API, making the transition easy while adding much needed functionality. Today, setuptools is used in around 75% of the Python packages in Spack."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:323
# c99a402aa24241b4804e2f82c948c704
msgid "Since setuptools isn't built-in to Python, you need to add it as a dependency. To determine whether or not a package uses setuptools, search the file for an import statement like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:332
# 3dc670f5f0e544febb5b424206be4a7e
msgid "or:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:339
# 0f02444032994142a68e03820a32d20d
msgid "Some packages are designed to work with both setuptools and distutils, so you may find something like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:350
# 6360504c169f419b87722108ed4f698e
msgid "This uses setuptools if available, and falls back to distutils if not. In this case, you would still want to add a setuptools dependency, as it offers us more control over the installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:354
# bb793ba259a24be28989ebaf3ab4e679
msgid "Unless specified otherwise, setuptools is usually a build-only dependency. That is, it is needed to install the software, but is not needed at run-time. This can be specified as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:365
# e88b670444594378bc9ff25dd076559a
msgid "cython"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:367
# 174541d8ee9a4411b6044e4db82754d4
msgid "Compared to compiled languages, interpreted languages like Python can be quite a bit slower. To work around this, some Python developers rewrite computationally demanding sections of code in C, a process referred to as \"cythonizing\". In order to build these package, you need to add a build dependency on cython:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:378
# d627b0504a9d4f35b92edd79e4688968
msgid "Look for references to \"cython\" in the ``setup.py`` to determine whether or not this is necessary. Cython may be optional, but even then you should list it as a required dependency. Spack is designed to compile software, and is meant for HPC facilities where speed is crucial. There is no reason why someone would not want an optimized version of a library instead of the pure-Python version."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:388
# 15e9a95587a04c469ebc9c790bb0db2a
msgid "Python dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:390
# 56c00572d06041c79d9f45d62e021ef5
msgid "When you install a package with ``pip``, it reads the ``setup.py`` file in order to determine the dependencies of the package. If the dependencies are not yet installed, ``pip`` downloads them and installs them for you. This may sound convenient, but Spack cannot rely on this behavior for two reasons:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:396
# cd8d94d5b4104a6db5ce9f5c50ddb501
msgid "Spack needs to be able to install packages on air-gapped networks."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:398
# 0642d284776645b0aacb5aa4500bc37e
msgid "If there is no internet connection, ``pip`` can't download the package dependencies. By explicitly listing every dependency in the ``package.py``, Spack knows what to download ahead of time."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:402
# 1fe76462bcc149d1a85ae3a5875d85eb
msgid "Duplicate installations of the same dependency may occur."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:404
# 988476aa4c12436791b8a4ed021b4516
msgid "Spack supports *activation* of Python extensions, which involves symlinking the package installation prefix to the Python installation prefix. If your package is missing a dependency, that dependency will be installed to the installation directory of the same package. If you try to activate the package + dependency, it may cause a problem if that package has already been activated."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:411
# cfde30600ca24da488dda55eb7a5fcdf
msgid "For these reasons, you must always explicitly list all dependencies. Although the documentation may list the package's dependencies, often the developers assume people will use ``pip`` and won't have to worry about it. Always check the ``setup.py`` to find the true dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:417
# 6f87b6e734bf488e911dfb5bbbd8f5f1
msgid "If the package relies on ``distutils``, it may not explicitly list its dependencies. Check for statements like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:428
# 42ce4f8091eb42d0ab1f91420bd2445f
msgid "Obviously, this means that ``py-numpy`` is a dependency."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:430
# b1f748839e674d0087cdabe95230b488
msgid "If the package uses ``setuptools``, check for the following clues:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:432
# 800732d979334234900fdaf76df63342
msgid "``install_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:434
# dd60b7c022e14864a92f677cc987ee69
msgid "These packages are required for installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:436
# c9680a5b438041b3bbdb9295365ef828
msgid "``extra_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:438
# bf7a361a9bb14ec7b36df92f70ef3534
msgid "These packages are optional dependencies that enable additional functionality. You should add a variant that optionally adds these dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:442
# cab78fe62a124b58bb535a0fb2aea2bf
msgid "``test_requires``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:444
# 8745c550d3ea4f34b2dc774ccfa54bb2
msgid "These are packages that are required to run the unit tests for the package. These dependencies can be specified using the ``type='test'`` dependency type."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:448
# 41a5b86fceb542149a321af50f251f2a
msgid "In the root directory of the package, you may notice a ``requirements.txt`` file. It may look like this file contains a list of all of the package's dependencies. Don't be fooled. This file is used by tools like Travis to install the pre-requisites for the package... and a whole bunch of other things. It often contains dependencies only needed for unit tests, like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:455
# 6e7baf0964004a74add5d006b1f21217
msgid "mock"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:456
# d2da18b73e8645b6aeedcad3e6604d0b
msgid "nose"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:457
# d365cc4c5c5b41228918ee7f42b71d63
msgid "pytest"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:459
# 98405e4b2310414eb31bc34751af1e78
msgid "It can also contain dependencies for building the documentation, like sphinx. If you can't find any information about the package's dependencies, you can take a look in ``requirements.txt``, but be sure not to add test or documentation dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:468
# 390107309fc84aa39237630da8cbeb1e
msgid "Setuptools is a bit of a special case. If a package requires setuptools at run-time, how do they express this? They could add it to ``install_requires``, but setuptools is imported long before this and needed to read this line. And since you can't install the package without setuptools, the developers assume that setuptools will already be there, so they never mention when it is required. We don't want to add run-time dependencies if they aren't needed, so you need to determine whether or not setuptools is needed. Grep the installation directory for any files containing a reference to ``setuptools`` or ``pkg_resources``. Both modules come from ``py-setuptools``. ``pkg_resources`` is particularly common in scripts in ``prefix/bin``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:482
# 6cee922f515947a9a2ba219b71fe3de4
msgid "Passing arguments to setup.py"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:484
# b4a37822d5144e0e87f4b934c8404387
msgid "The default build and install phases should be sufficient to install most packages. However, you may want to pass additional flags to either phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:488
# 289702a3948a4a8f8a3169f06a6974a4
msgid "You can view the available options for a particular phase with:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:495
# cbc21c0e12da436eb1fbd9d51bb0d714
msgid "Each phase provides a ``<phase_args>`` function that can be used to pass arguments to that phase. For example, `py-numpy <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-numpy/package.py>`_ adds:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:520
# 11a2bd677c7e4064bc5301a625d9439a
msgid "``PythonPackage`` provides a couple of options for testing packages."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:524
# e1881e9d685141a69027870371484881
msgid "Import tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:526
# 12e0b19ef5a4481283cb59f00c5fb016
msgid "Just because a package successfully built does not mean that it built correctly. The most reliable test of whether or not the package was correctly installed is to attempt to import all of the modules that get installed. To get a list of modules, run the following command in the source directory:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:540
# b46931e44e5341acaaf46db11a61770e
msgid "Large, complex packages like ``numpy`` will return a long list of packages, while other packages like ``six`` will return an empty list. ``py-six`` installs a single ``six.py`` file. In Python packaging lingo, a \"package\" is a directory containing files like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:552
# 5564e7f7571847ada265733b63274023
msgid "whereas a \"module\" is a single Python file. Since ``find_packages`` only returns packages, you'll have to determine the correct module names yourself. You can now add these packages and modules to the package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:562
# 79ac9121e9984ca58259d0d979b2dc1f
msgid "When you run ``spack install --test=root py-six``, Spack will attempt to import the ``six`` module after installation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:565
# dd650e3b667a41c68fb45c62443aac06
msgid "These tests most often catch missing dependencies and non-RPATHed libraries. Make sure not to add modules/packages containing the word \"test\", as these likely won't end up in installation directory."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:571
# d83012620feb43a1a22b6255670552fb
msgid "Unit tests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:573
# d5a38b0d53754f31b236133a3cfb8f1e
msgid "The package you want to install may come with additional unit tests. By default, Spack runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:581
# fc41bc1679ae4b5183cf069b81c19229
msgid "if it detects that the ``setup.py`` file supports a ``test`` phase. You can add additional build-time or install-time tests by overriding ``test`` and ``installtest``, respectively. For example, ``py-numpy`` adds:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:595
# 127591d75f9d40b7ab9b95edf0b62ef9
msgid "Setup file in a sub-directory"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:597
# 10f045413cf44542a9bd83b69a0f9561
msgid "In order to be compatible with package managers like ``pip``, the package is required to place its ``setup.py`` in the root of the tarball. However, not every Python package cares about ``pip`` or PyPI. If you are installing a package that is not hosted on PyPI, you may find that it places its ``setup.py`` in a sub-directory. To handle this, add the directory containing ``setup.py`` to the package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:611
# 2dfeb272211943ba849cf2bee80b7586
msgid "Alternate names for setup.py"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:613
# 06d1f5bc17b84b1987624df854a48bb9
msgid "As previously mentioned, packages need to call their setup script ``setup.py`` in order to be compatible with package managers like ``pip``. However, some packages like `py-meep <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-meep/package.py>`_  and `py-adios <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-adios/package.py>`_ come with multiple setup scripts, one for a serial build and another for a parallel build. You can override the default name to use like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:629
# 28190942481549ffbfbe273b83e86d37
msgid "PythonPackage vs. packages that use Python"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:631
# e8e4d42071184a1daee5a9b40ee07dc3
msgid "There are many packages that make use of Python, but packages that depend on Python are not necessarily ``PythonPackages``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:636
# 401a9e015013460da47ee0b8b6bc8180
msgid "Choosing a build system"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:638
# dbe17d749530477d8ad459bbe02d4cfe
msgid "First of all, you need to select a build system. ``spack create`` usually does this for you, but if for whatever reason you need to do this manually, choose ``PythonPackage`` if and only if the package contains a ``setup.py`` file."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:645
# e48183509b5c46b2a2c427d492f1df46
msgid "Choosing a package name"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:647
# c2a5a66dbeea4ba7b59785a4e60feb97
msgid "Selecting the appropriate package name is a little more complicated than choosing the build system. By default, ``spack create`` will prepend ``py-`` to the beginning of the package name if it detects that the package uses the ``PythonPackage`` build system. However, there are occasionally packages that use ``PythonPackage`` that shouldn't start with ``py-``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:654
# f06066f1a2b54cad8a14f74cc93bc3a0
msgid "busco"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:655
# 8af5c6c5519845cbb71b1d7a853ffd10
msgid "easybuild"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:656
# 9a1d87441e644ddbb2d238fd5ecd61b0
msgid "httpie"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:657
# ccdc0e2c886745ac84df6dcd67cf62ae
msgid "mercurial"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:658
# 84a6cee0786b44a28d72218017c8e804
msgid "scons"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:659
# 3e680eae94904e6da89c7193f815bb6f
msgid "snakemake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:661
# 7e91c41fdf1e4888a16eee8b25445c73
msgid "The thing these packages have in common is that they are command-line tools that just so happen to be written in Python. Someone who wants to install ``mercurial`` with Spack isn't going to realize that it is written in Python, and they certainly aren't going to assume the package is called ``py-mercurial``. For this reason, we manually renamed the package to ``mercurial``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:668
# 1c8525cccfe44eb6902498b92eb6458b
msgid "Likewise, there are occasionally packages that don't use the ``PythonPackage`` build system but should still be prepended with ``py-``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:672
# c7fcbceab66446d39d4c1ea8f2e23887
msgid "py-genders"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:673
# eb4eaf5751d3494aa072bf3cea6f5e35
msgid "py-py2cairo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:674
# 357f2ff814344276a9db32a01b0539a7
msgid "py-pygobject"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:675
# 492c9a105ebb4a81b1f3861b5af5b44d
msgid "py-pygtk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:676
# e7ffb3eb7d3746c48afbfbd522c62e1a
msgid "py-pyqt"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:677
# 8d13e0234d6641d38c9017dc3d3d4271
msgid "py-pyserial"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:678
# 05b08dd3e633415aba6d805023aed88f
msgid "py-sip"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:679
# 6ffe76b2f2a34ac5850071b6cabdc44e
msgid "py-xpyb"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:681
# 3c313608fb1a439ca3dd73e9c67e1c7d
msgid "These packages are primarily used as Python libraries, not as command-line tools. You may see C/C++ packages that have optional Python language-bindings, such as:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:685
# 652b631c3a2846edaf5ba55a98754719
msgid "antlr"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:686
# 4fcf1beadde04ca396d8324bd9e04180
msgid "cantera"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:687
# 8a9ca33855ca4583933a7504a39f6179
msgid "conduit"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:688
# ff858fd4cdf644e5881c515c63d8103f
msgid "pagmo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:689
# 35c239bcb16e47b98989065addd7ee0e
msgid "vtk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:691
# 82d14f8498ba42bea57bc551115d2fed
msgid "Don't prepend these kind of packages with ``py-``. When in doubt, think about how this package will be used. Is it primarily a Python library that will be imported in other Python scripts? Or is it a command-line tool, or C/C++/Fortran program with optional Python modules? The former should be prepended with ``py-``, while the latter should not."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:700
# 0b026d6cc10a472e9292e48dce412f12
msgid "extends vs. depends_on"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:702
# 458fa97ebe6f417489f09cefc3ba2dfd
msgid "This is very similar to the naming dilemma above, with a slight twist. As mentioned in the :ref:`Packaging Guide <packaging_extensions>`, ``extends`` and ``depends_on`` are very similar, but ``extends`` adds the ability to *activate* the package. Activation involves symlinking everything in the installation prefix of the package to the installation prefix of Python. This allows the user to import a Python module without having to add that module to ``PYTHONPATH``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:710
# 50f2626cfb704c36bfbe6e98843928a1
msgid "When deciding between ``extends`` and ``depends_on``, the best rule of thumb is to check the installation prefix. If Python libraries are installed to ``prefix/lib/python2.7/site-packages`` (where 2.7 is the MAJOR.MINOR version of Python you used to install the package), then you should use ``extends``. If Python libraries are installed elsewhere or the only files that get installed reside in ``prefix/bin``, then don't use ``extends``, as symlinking the package wouldn't be useful."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:722
# 2a40d1d4f96443d6bb436891240cf10c
msgid "PyPI has hundreds of thousands of packages that are not yet in Spack, and ``pip`` may be a perfectly valid alternative to using Spack. The main advantage of Spack over ``pip`` is its ability to compile non-Python dependencies. It can also build cythonized versions of a package or link to an optimized BLAS/LAPACK library like MKL, resulting in calculations that run orders of magnitude faster. Spack does not offer a significant advantage to other python-management systems for installing and using tools like flake8 and sphinx. But if you need packages with non-Python dependencies like numpy and scipy, Spack will be very valuable to you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:733
# 2f1c74664c9e49848b7cba262851e3d0
msgid "Anaconda is another great alternative to Spack, and comes with its own ``conda`` package manager. Like Spack, Anaconda is capable of compiling non-Python dependencies. Anaconda contains many Python packages that are not yet in Spack, and Spack contains many Python packages that are not yet in Anaconda. The main advantage of Spack over Anaconda is its ability to choose a specific compiler and BLAS/LAPACK or MPI library. Spack also has better platform support for supercomputers. On the other hand, Anaconda offers Windows support."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/pythonpackage.rst:746
# 4c8ff4120ea64158a03330a28dd9615b
msgid "For more information on Python packaging, see: https://packaging.python.org/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:10
# 38b1e2eb7b2f4bbfb30978797902062b
msgid "QMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:12
# dd7c054c99d74ceb847ad2ff52c94190
msgid "Much like Autotools and CMake, QMake is a build-script generator designed by the developers of Qt. In its simplest form, Spack's ``QMakePackage`` runs the following steps:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:24
# 46d7208bea3c4b0f9271a9475e33902d
msgid "QMake does not appear to have a standardized way of specifying the installation directory, so you may have to set environment variables or edit ``*.pro`` files to get things working properly."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:32
# f0449589a08e46959c0f8ec46930c843
msgid "The ``QMakePackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:34
# 4f4f8571424349d282ff3a60094c6be5
msgid "``qmake`` - generate Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:47
# 2b6de0a3c009486ab0defe96076976b2
msgid "Any of these phases can be overridden in your package as necessary. There is also a ``check`` method that looks for a ``check`` target in the Makefile. If a ``check`` target exists and the user runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:56
# 61dbf71b3ef84e9ca4b70e338efbc67d
msgid "Spack will run ``make check`` after the build phase."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:62
# 81696b59b5354391b9fcd091763d270d
msgid "Packages that use the QMake build system can be identified by the presence of a ``<project-name>.pro`` file. This file declares things like build instructions and dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:66
# 158d6b87643c45c59569117cb17a8865
msgid "One thing to look for is the ``minQtVersion`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:73
# 7e0fd010f9d14d0291fd20023caa006a
msgid "This means that Qt 5.6.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:80
# 62210c3aab5a4d4f9e913e64080644c5
msgid "At the bare minimum, packages that use the QMake build system need a ``qt`` dependency. Since this is always the case, the ``QMakePackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:89
# b93f61fa50404252b56bf46028b0bf72
msgid "If you want to specify a particular version requirement, or need to link to the ``qt`` libraries, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:98
# 99e82b749e7546fdbf6581e7a334c620
msgid "Passing arguments to qmake"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:100
# 9ce2fccaf60646648e40bc5fd5a4bda0
msgid "If you need to pass any arguments to the ``qmake`` call, you can override the ``qmake_args`` method like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/qmakepackage.rst:115
# b38721d1c31b49c788ce67c1099b9d51
msgid "For more information on the QMake build system, see: http://doc.qt.io/qt-5/qmake-manual.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:10
# e28e05d5e214459fab5cb1a9679b14c5
msgid "RPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:12
# 278698d233244c1da557b3ad3553f969
msgid "Like Python, R has its own built-in build system."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:14
# 83dcfd8b34054cbea42235b24cc03cbf
msgid "The R build system is remarkably uniform and well-tested. This makes it one of the easiest build systems to create new Spack packages for."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:22
# e5cb3499fd7f4052977535f4fea6a805
msgid "The ``RPackage`` base class has a single phase:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:35
# fa0380be1340444986adfcc22764e785
msgid "Finding R packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:37
# c9a696e3bb834467b1111c61b5011c58
msgid "The vast majority of R packages are hosted on CRAN - The Comprehensive R Archive Network. If you are looking for a particular R package, search for \"CRAN <package-name>\" and you should quickly find what you want. If it isn't on CRAN, try Bioconductor, another common R repository."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:42
# 208424f6087349eeae4f81eb148e262a
msgid "For the purposes of this tutorial, we will be walking through `r-caret <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-caret/package.py>`_ as an example. If you search for \"CRAN caret\", you will quickly find what you are looking for at https://cran.r-project.org/web/packages/caret/index.html. If you search for \"Package source\", you will find the download URL for the latest release. Use this URL with ``spack create`` to create a new package."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:54
# 3cf0d4b4cd684abfa6203a38c2166304
msgid "The first thing you'll notice is that Spack prepends ``r-`` to the front of the package name. This is how Spack separates R package extensions from the rest of the packages in Spack. Without this, we would end up with package name collisions more frequently than we would like. For instance, there are already packages for both:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:60
# 51c5b99d721f455ebf016eeba60cbb59
msgid "``ape`` and ``r-ape``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:61
# 13cb1c520e204887a83ad8748b20e5c9
msgid "``curl`` and ``r-curl``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:62
# f35936b932204bf7916aa43e83aa4264
msgid "``gmp`` and ``r-gmp``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:63
# 5bf9e14915dc4a04a54fff20446c9389
msgid "``jpeg`` and ``r-jpeg``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:64
# 44242211f12f4c7e961ab56060bd64dc
msgid "``openssl`` and ``r-openssl``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:65
# e7431a48849c4ddd9097e2294350d8f5
msgid "``uuid`` and ``r-uuid``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:66
# 90cc958b7c1146e6a57a9a32de7dc83b
msgid "``xts`` and ``r-xts``"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:68
# 05e3c03e46cf4beb831fab3777f431eb
msgid "Many popular programs written in C/C++ are later ported to R as a separate project."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:75
# d48c52a0a2f14c72bed8e36dc6840cda
msgid "The first thing you'll need to add to your new package is a description. The top of the homepage for ``caret`` lists the following description:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:78
# 1389ff7819e54b248f067fce9b644608
msgid "caret: Classification and Regression Training"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:80
# c1c908a8c85c4b2cadc86e19e57b3908
msgid "Misc functions for training and plotting classification and regression models."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:82
# 3b393a684abc4520a9f81cf9f05fc318
msgid "You can either use the short description (first line), long description (second line), or both depending on what you feel is most appropriate."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:89
# 63559f938b3b4b25ba592696db02933f
msgid "If you look at the bottom of the page, you'll see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:91
# 02595015b8174b08847f5a724e9b38bb
msgid "Linking:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:93
# 09321b10041a45a088181c53d50b8218
msgid "Please use the canonical form https://CRAN.R-project.org/package=caret to link to this page."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:95
# dbda68407e2e466cbcfd04e213ebb794
msgid "Please uphold the wishes of the CRAN admins and use https://CRAN.R-project.org/package=caret as the homepage instead of https://cran.r-project.org/web/packages/caret/index.html. The latter may change without notice."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:104
# 0d1a9572c66c46e8988d71ba06476926
msgid "As previously mentioned, the download URL for the latest release can be found by searching \"Package source\" on the homepage."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:109
# 1d3202810a574a96a302db401b6b99a9
msgid "List URL"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:111
# bed80d51af774200b9b0f8b081d9267b
msgid "CRAN maintains a single webpage containing the latest release of every single package: https://cran.r-project.org/src/contrib/"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:114
# 11c1845d9a95416292a049ebe478ccdd
msgid "Of course, as soon as a new release comes out, the version you were using in your package is no longer available at that URL. It is moved to an archive directory. If you search for \"Old sources\", you will find: https://cran.r-project.org/src/contrib/Archive/caret"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:119
# 000d137b48cc4d60a82a75823d669ee2
msgid "If you only specify the URL for the latest release, your package will no longer be able to fetch that version as soon as a new release comes out. To get around this, add the archive directory as a ``list_url``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:127
# 664ac02556934f8c8a5213f8cacab31b
msgid "As an extension of the R ecosystem, your package will obviously depend on R to build and run. Normally, we would use ``depends_on`` to express this, but for R packages, we use ``extends``. ``extends`` is similar to ``depends_on``, but adds an additional feature: the ability to \"activate\" the package by symlinking it to the R installation directory. Since every R package needs this, the ``RPackage`` base class contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:140
# 7578a82bb17e4a70b180fc0ca4c9c1be
msgid "Take a close look at the homepage for ``caret``. If you look at the \"Depends\" section, you'll notice that ``caret`` depends on \"R (≥ 2.10)\". You should add this to your package like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:151
# a779a6f18519463dbcc5787d9d5599bf
msgid "R dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:153
# 4394929cc82246a8a423afaa59a52fcc
msgid "R packages are often small and follow the classic Unix philosophy of doing one thing well. They are modular and usually depend on several other packages. You may find a single package with over a hundred dependencies. Luckily, CRAN packages are well-documented and list all of their dependencies in the following sections:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:159
# 751e4d74923242c99387c3d7b6dc8294
msgid "Depends"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:160
# cb118d3055114a639afa18514ec2cbfb
msgid "Imports"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:161
# cc9c3a4ed6194855aed155b446f6cd2f
msgid "LinkingTo"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:163
# 12cca2be2e7146c78b567450b6ef0872
msgid "As far as Spack is concerned, all 3 of these dependency types correspond to ``type=('build', 'run')``, so you don't have to worry about them. If you are curious what they mean, https://github.com/spack/spack/issues/2951 has a pretty good summary:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:168
# 8060c3c3bb8c4ffb8b8dbb14380ba8e9
msgid "``Depends`` is required and will cause those R packages to be *attached*, that is, their APIs are exposed to the user. ``Imports`` *loads* packages so that *the package* importing these packages can access their APIs, while *not* being exposed to the user. When a user calls ``library(foo)`` s/he *attaches* package ``foo`` and all of the packages under ``Depends``. Any function in one of these package can be called directly as ``bar()``. If there are conflicts, user can also specify ``pkgA::bar()`` and ``pkgB::bar()`` to distinguish between them. Historically, there was only ``Depends`` and ``Suggests``, hence the confusing names. Today, maybe ``Depends`` would have been named ``Attaches``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:179
# 77ff7196aad14b269e4f9818f9e7f25a
msgid "The ``LinkingTo`` is not perfect and there was recently an extensive discussion about API/ABI among other things on the R-devel mailing list among very skilled R developers:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:183
# bb398c02eca34b02801ae16c4587c0b3
msgid "https://stat.ethz.ch/pipermail/r-devel/2016-December/073505.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:184
# 9883c1c6f37044d7a46697176308c746
msgid "https://stat.ethz.ch/pipermail/r-devel/2017-January/073647.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:186
# 3b8c9cc4e59c4102a8d2d4d6663c68db
msgid "Some packages also have a fourth section:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:188
# cb2028ec204144aa9a6199bdeb8857db
msgid "Suggests"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:190
# 48bcb73ac10443ffbcca6f7ff258779d
msgid "These are optional, rarely-used dependencies that a user might find useful. You should **NOT** add these dependencies to your package. R packages already have enough dependencies as it is, and adding optional dependencies can really slow down the concretization process. They can also introduce circular dependencies."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:198
# 7f6eaeda7bf34eb38faa3cae6bdfffa3
msgid "Core, recommended, and non-core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:200
# 9f40bd156a8f4e3db70d285bbc3feec6
msgid "If you look at \"Depends\", \"Imports\", and \"LinkingTo\", you will notice 3 different types of packages:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:205
# 151e8bd005024267a34ac758d582aa6b
msgid "Core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:207
# 7bfa7e619135485da10a2fb7d226854b
msgid "If you look at the ``caret`` homepage, you'll notice a few dependencies that don't have a link to the package, like ``methods``, ``stats``, and ``utils``. These packages are part of the core R distribution and are tied to the R version installed. You can basically consider these to be \"R itself\". These are so essential to R so it would not make sense that they could be updated via CRAN. If so, you would basically get a different version of R. Thus, they're updated when R is updated."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:215
# 7e6cbe57f035463bbc606376ac8370dc
msgid "You can find a list of these core libraries at: https://github.com/wch/r-source/tree/trunk/src/library"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:220
# e3ecf2523612454e9c076e95dbf64220
msgid "Recommended packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:222
# ce87eb12a46a412a8bd6d496f077f6c0
msgid "When you install R, there is an option called ``--with-recommended-packages``. This flag causes the R installation to include a few \"Recommended\" packages (legacy term). They are for historical reasons quite tied to the core R distribution, developed by the R core team or people closely related to it. The R core distribution \"knows\" about these package, but they are indeed distributed via CRAN. Because they're distributed via CRAN, they can also be updated between R version releases."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:230
# 3316f4d0ab944c7d96788e0ed06ec720
msgid "Spack explicitly adds the ``--without-recommended-packages`` flag to prevent the installation of these packages. Due to the way Spack handles package activation (symlinking packages to the R installation directory), pre-existing recommended packages will cause conflicts for already-existing files. We could either not include these recommended packages in Spack and require them to be installed through ``--with-recommended-packages``, or we could not install them with R and let users choose the version of the package they want to install. We chose the latter."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:239
# 01ec7ab346e349579635d5438755972f
msgid "Since these packages are so commonly distributed with the R system, many developers may assume these packages exist and fail to list them as dependencies. Watch out for this."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:243
# 6b578b5807854707bf1c78cbe489bb95
msgid "You can find a list of these recommended packages at: https://github.com/wch/r-source/blob/trunk/share/make/vars.mk"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:248
# 246991fb80ab4bd5a787a3f394908161
msgid "Non-core packages"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:250
# 869a96358298402588263d760c60d1a2
msgid "These are packages that are neither \"core\" nor \"recommended\". There are more than 10,000 of these packages hosted on CRAN alone."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:253
# 9a2ab0b55d8b4be7bf92a058f8b0576c
msgid "For each of these package types, if you see that a specific version is required, for example, \"lattice (≥ 0.20)\", please add this information to the dependency:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:264
# ef7016b2d3d04a3baf700a4155efbb9b
msgid "Non-R dependencies"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:266
# ff9e2288f00741eda9a089fe8b887230
msgid "Some packages depend on non-R libraries for linking. Check out the `r-stringi <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-stringi/package.py>`_ package for an example: https://CRAN.R-project.org/package=stringi. If you search for the text \"SystemRequirements\", you will see:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:271
# 76179c89e5ea4d62a67e1929276a69b8
msgid "ICU4C (>= 52, optional)"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:273
# ead5a79f0c444e0baafa99753a4191c8
msgid "This is how non-R dependencies are listed. Make sure to add these dependencies. The default dependency type should suffice."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:278
# 0f06884ae0b74b76b17d8e166771e582
msgid "Passing arguments to the installation"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:280
# 5794a56c37214467ad006f7da2620132
msgid "Some R packages provide additional flags that can be passed to ``R CMD INSTALL``, often to locate non-R dependencies. `r-rmpi <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/r-rmpi/package.py>`_ is an example of this, and flags for linking to an MPI library. To pass these to the installation command, you can override ``configure_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:307
# dadd2f137a0b443cacc3ad1d1cfea469
msgid "There is a similar ``configure_vars`` function that can be overridden to pass variables to the build."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:314
# fb5b86313acd441583005426fd91fdd7
msgid "CRAN hosts over 10,000 R packages, most of which are not in Spack. Many users may not need the advanced features of Spack, and may prefer to install R packages the normal way:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:324
# 2146a177435949539a15b6ef37ca722c
msgid "R will search CRAN for the ``ggplot2`` package and install all necessary dependencies for you. If you want to update all installed R packages to the latest release, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:333
# ff846d47299c4ccb831be4d7257dec47
msgid "This works great for users who have internet access, but those on an air-gapped cluster will find it easier to let Spack build a download mirror and install these packages for you."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:337
# 979614c12c094572ad0c7fd15358d952
msgid "Where Spack really shines is its ability to install non-R dependencies and link to them properly, something the R installation mechanism cannot handle."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rpackage.rst:345
# 2dbd184146eb45f6a2bb91d416669cfe
msgid "For more information on installing R packages, see: https://stat.ethz.ch/R-manual/R-devel/library/utils/html/INSTALL.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:10
# 60f0ee0d190f4f159c1bca12da824330
msgid "RubyPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:12
# 364e973b02b141fab15833f80fec15a6
msgid "Like Perl, Python, and R, Ruby has its own build system for installing Ruby gems."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/rubypackage.rst:15
# 2d7e16b0d2f046179ef8bb4add6e3183
msgid "This build system is a work-in-progress. See https://github.com/spack/spack/pull/3127 for more information."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:10
# 8e7e5f0f0bca4fc098665371b23b63da
msgid "SConsPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:12
# 5772988e05674e8fb4dffdd6414e4541
msgid "SCons is a general-purpose build system that does not rely on Makefiles to build software. SCons is written in Python, and handles all building and linking itself."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:16
# 62ca3d28b0eb4f19b613dd9531ae17ce
msgid "As far as build systems go, SCons is very non-uniform. It provides a common framework for developers to write build scripts, but the build scripts themselves can vary drastically. Some developers add subcommands like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:29
# 23b3afdacff44eaf806d09e6108a88c3
msgid "Others don't add any subcommands. Some have configuration options that can be specified through variables on the command line. Others don't."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:36
# 6e8065d1ae8647f49fac9a8cb20f016b
msgid "As previously mentioned, SCons allows developers to add subcommands like ``build`` and ``install``, but by default, installation usually looks like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:45
# cde1309b724940ae9a4558f7e34cbe5a
msgid "To facilitate this, the ``SConsPackage`` base class provides the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:51
# 24014338eb514821ac1a07fb70217563
msgid "Package developers often add unit tests that can be invoked with ``scons test`` or ``scons check``. Spack provides a ``test`` method to handle this. Since we don't know which one the package developer chose, the ``test`` method does nothing by default, but can be easily overridden like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:67
# 37308b13bc7f4d468e23a4d81415837c
msgid "SCons packages can be identified by their ``SConstruct`` files. These files handle everything from setting up subcommands and command-line options to linking and compiling."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:71
# c16114c739dd4521828d460f6c2fa5e3
msgid "One thing to look for is the ``EnsureSConsVersion`` function:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:78
# 0485983f54f042ceb9fa8eacf5fe0284
msgid "This means that SCons 2.3.0 is the earliest release that will work. You should specify this in a ``depends_on`` statement."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:85
# 3f32195624784f099e59826b31231c4f
msgid "At the bare minimum, packages that use the SCons build system need a ``scons`` dependency. Since this is always the case, the ``SConsPackage`` base class already contains:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:94
# e01694c840024df9ba36a9d3fb6a7bea
msgid "If you want to specify a particular version requirement, you can override this in your package:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:104
# ae62cb597e574ef9a462ffea4328393d
msgid "Finding available options"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:106
# 7dbe9fbdfdac43c9b7a2a348bdc46b54
msgid "The first place to start when looking for a list of valid options to build a package is ``scons --help``. Some packages like `kahip <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/kahip/package.py>`_ don't bother overwriting the default SCons help message, so this isn't very useful, but other packages like `serf <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/serf/package.py>`_ print a list of valid command-line variables:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:180
# 5dbfd8ee84504d609eb8d85ef97aab9b
msgid "More advanced packages like `cantera <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/cantera/package.py>`_ use ``scons --help`` to print a list of subcommands:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:227
# b55c5ef3151c4ab58a4c63abfb78d253
msgid "You'll notice that cantera provides a ``scons help`` subcommand. Running ``scons help`` prints a list of valid command-line variables."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:232
# e232faf299d445bfb729e0856cc7861b
msgid "Passing arguments to scons"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:234
# a31e979e6e1b4baeaab4fedfa7168036
msgid "Now that you know what arguments the project accepts, you can add them to the package build phase. This is done by overriding ``build_args`` like so:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:253
# 07463b3619364b2189f2155de830129e
msgid "``SConsPackage`` also provides an ``install_args`` function that you can override to pass additional arguments to ``scons install``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:258
# 96bf317fa8b24d48815faa290b7e27a0
msgid "Compiler wrappers"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:260
# 7dbdc986fbec40a9992a10026fb84cf9
msgid "By default, SCons builds all packages in a separate execution environment, and doesn't pass any environment variables from the user environment. Even changes to ``PATH`` are not propagated unless the package developer does so."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:265
# 128ded1908854bd8b69bfa469ba42e77
msgid "This is particularly troublesome for Spack's compiler wrappers, which depend on environment variables to manage dependencies and linking flags. In many cases, SCons packages are not compatible with Spack's compiler wrappers, and linking must be done manually."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:270
# 123c858f061a43eeac06774c2911fd5d
msgid "First of all, check the list of valid options for anything relating to environment variables. For example, cantera has the following option:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:282
# c013e195044e47059105cf5ebf116bb7
msgid "In the case of cantera, using ``env_vars=all`` allows us to use Spack's compiler wrappers. If you don't see an option related to environment variables, try using Spack's compiler wrappers by passing ``spack_cc``, ``spack_cxx``, and ``spack_fc`` via the ``CC``, ``CXX``, and ``FC`` arguments, respectively. If you pass them to the build and you see an error message like:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:294
# 161339d53548419cbe163886cf2d01ad
msgid "you'll know that the package isn't compatible with Spack's compiler wrappers. In this case, you'll have to use the path to the actual compilers, which are stored in ``self.compiler.cc`` and friends. Note that this may involve passing additional flags to the build to locate dependencies, a task normally done by the compiler wrappers. serf is an example of a package with this limitation."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/sconspackage.rst:305
# ff0d792047024eb0bd5c413e2a3b5aa1
msgid "For more information on the SCons build system, see: http://scons.org/documentation.html"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:10
# 6a37394bd76341069445593d4a6d8735
msgid "WafPackage"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:12
# 01d931c6242c46d19848f33c5d1c95ad
msgid "Like SCons, Waf is a general-purpose build system that does not rely on Makefiles to build software."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:19
# 9906541fac194336a0bea1f6e16b2e0d
msgid "The ``WafPackage`` base class comes with the following phases:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:21
# a394cad295e44fc4850b4d09562e1923
msgid "``configure`` - configure the project"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:34
# 95affab4a52044aabcef7348613f0315
msgid "Each of these are standard Waf commands and can be found by running:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:41
# c290e152c15a4a70876a33cd7ee2bfb6
msgid "Each phase provides a ``<phase>`` function that runs:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:48
# 954f4588b25444f4b0ee71973b1fba35
msgid "where ``<jobs>`` is the number of parallel jobs to build with. Each phase also has a ``<phase_args>`` function that can pass arguments to this call. All of these functions are empty except for the ``configure_args`` function, which passes ``--prefix=/path/to/installation/prefix``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:57
# 8bf86a5042f84ef0be0ccb61efabaffc
msgid "``WafPackage`` also provides ``test`` and ``installtest`` methods, which are run after the ``build`` and ``install`` phases, respectively. By default, these phases do nothing, but you can override them to run package-specific unit tests. For example, the `py-py2cairo <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-py2cairo/package.py>`_ package uses:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:76
# 07b36e6d8f1a4115a6641e282d5ce712
msgid "Each Waf package comes with a custom ``waf`` build script, written in Python. This script contains instructions to build the project."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:79
# 89a59bcbfc7b4f2e8e25635151ec3a21
msgid "The package also comes with a ``wscript`` file. This file is used to override the default ``configure``, ``build``, and ``install`` phases to customize the Waf project. It also allows developers to override the default ``./waf --help`` message. Check this file to find useful information about dependencies and the minimum versions that are supported."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:90
# c6370cdfef6b4becbcce1f15d756d0f6
msgid "``WafPackage`` does not require ``waf`` to build. ``waf`` is only needed to create the ``./waf`` script. Since ``./waf`` is a Python script, Python is needed to build the project. ``WafPackage`` adds the following dependency automatically:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:100
# d3c12c4039b94858abb176070f1aa791
msgid "Waf only supports Python 2.5 and up."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:104
# 2bd20e7ba4cd4584b3cbcdf4f0c58a7a
msgid "Passing arguments to waf"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:106
# d43fc417ba454d52b210048aed35ca39
msgid "As previously mentioned, each phase comes with a ``<phase_args>`` function that can be used to pass arguments to that particular phase. For example, if you need to pass arguments to the build phase, you can use:"
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:122
# fd1fa87689034a0986bf02f6cfe40aab
msgid "A list of valid options can be found by running ``./waf --help``."
msgstr ""

#: ../spack/lib/spack/docs/build_systems/wafpackage.rst:128
# 5ea20eeeebd54fa7897c11f294bcd0d1
msgid "For more information on the Waf build system, see: https://waf.io/book/"
msgstr ""

