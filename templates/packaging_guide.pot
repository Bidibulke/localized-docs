# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2019, Lawrence Livermore National Laboratory.
# This file is distributed under the same license as the Spack package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Spack 0.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-23 00:42-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../spack/lib/spack/docs/packaging_guide.rst:10
# 71839e1beea94bdaaf876ab77a303098
msgid "Packaging Guide"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:12
# 41f57189d0934e53873b255f93aebca4
msgid "This guide is intended for developers or administrators who want to package software so that Spack can install it.  It assumes that you have at least some familiarity with Python, and that you've read the :ref:`basic usage guide <basic-usage>`, especially the part about :ref:`specs <sec-specs>`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:18
# 045cf544066046859c34dd61d587dd0f
msgid "There are two key parts of Spack:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:20
# d5e3068be30f433691959592297bbb64
msgid "**Specs**: expressions for describing builds of software, and"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:21
# 77bd1c7c52754a3abed843ce5f3ed960
msgid "**Packages**: Python modules that describe how to build software according to a spec."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:24
# a40958c3fc4d4c46b453a383c32850bd
msgid "Specs allow a user to describe a *particular* build in a way that a package author can understand.  Packages allow the packager to encapsulate the build logic for different versions, compilers, options, platforms, and dependency combinations in one place. Essentially, a package translates a spec into build logic."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:30
# d7c4b429aeed4f8eb7005ffaf1eb023b
msgid "Packages in Spack are written in pure Python, so you can do anything in Spack that you can do in Python.  Python was chosen as the implementation language for two reasons.  First, Python is becoming ubiquitous in the scientific software community. Second, it's a modern language and has many powerful features to help make package writing easy."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:39
# 3c436aa25d60468298db8297aff007b3
msgid "Creating & editing packages"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:45
# 5eb04a0a59f343349ec2c0ac54d2ee1a
msgid "``spack create``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:47
# 83acbdcf9c7441fe8cab142885a978b1
msgid "The ``spack create`` command creates a directory with the package name and generates a ``package.py`` file with a boilerplate package template. If given a URL pointing to a tarball or other software archive, ``spack create`` is smart enough to determine basic information about the package, including its name and build system. In most cases, ``spack create`` plus a few modifications is all you need to get a package working."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:54
# fe31f8f40dca49c79614ea0d79397fd1
msgid "Here's an example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:60
# 738fdca7045a47dcab08e7a43f8655fb
msgid "Spack examines the tarball URL and tries to figure out the name of the package to be created. If the name contains uppercase letters, these are automatically converted to lowercase. If the name contains underscores or periods, these are automatically converted to dashes."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:65
# c03c308d8e03415382c57ba289124864
msgid "Spack also searches for *additional* versions located in the same directory of the website. Spack prompts you to tell you how many versions it found and asks you how many you would like to download and checksum:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:83
# ff84495cf0fa4796acb0d2b66b337ff1
msgid "Spack will automatically download the number of tarballs you specify (starting with the most recent) and checksum each of them."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:86
# 01d360f4f7684fc281d3c0cea5dc4cc5
msgid "You do not *have* to download all of the versions up front. You can always choose to download just one tarball initially, and run :ref:`cmd-spack-checksum` later if you need more versions."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:90
# 89f602420d5647eb82dcade1bc7cc9ba
msgid "Let's say you download 3 tarballs:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:107
# d0934da954f74dc99325a474ed73139f
msgid "Spack automatically creates a directory in the appropriate repository, generates a boilerplate template for your package, and opens up the new ``package.py`` in your favorite ``$EDITOR``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:152
# d09c61ba36e84e7d9259ef0dd05c3777
msgid "The tedious stuff (creating the class, checksumming archives) has been done for you. You'll notice that ``spack create`` correctly detected that ``gmp`` uses the Autotools build system. It created a new ``Gmp`` package that subclasses the ``AutotoolsPackage`` base class. This base class provides basic installation methods common to all Autotools packages:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:166
# 470a9d2896f34507b94d7a721cebdc1d
msgid "For most Autotools packages, this is sufficient. If you need to add additional arguments to the ``./configure`` call, add them via the ``configure_args`` function."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:170
# af409bd18f1e44939322154070abb9e9
msgid "In the generated package, the download ``url`` attribute is already set. All the things you still need to change are marked with ``FIXME`` labels. You can delete the commented instructions between the license and the first import statement after reading them. The rest of the tasks you need to do are as follows:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:176
# 45a2713218ce4772b09e5556b167e302
msgid "Add a description."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:178
# 89f3eff61fc54bbba5d44de6fd6f1555
msgid "Immediately inside the package class is a *docstring* in triple-quotes (``\"\"\"``).  It is used to generate the description shown when users run ``spack info``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:182
# 35eba2d32ef04157a5ee39f2ec31a109
msgid "Change the ``homepage`` to a useful URL."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:184
# 8d13a5fa509f4c8983d244bf46b106c6
msgid "The ``homepage`` is displayed when users run ``spack info`` so that they can learn more about your package."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:187
# 408a589d883e4ec788f576663b5577b8
msgid "Add ``depends_on()`` calls for the package's dependencies."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:189
# 7fb2669b6b4f41e9b4a473fc375d8902
msgid "``depends_on`` tells Spack that other packages need to be built and installed before this one. See :ref:`dependencies`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:192
# 040eea0f53694898bdb76bf37be81350
msgid "Get the installation working."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:194
# 456618b83b224e51ba0b3438e0a01bd5
msgid "Your new package may require specific flags during ``configure``. These can be added via ``configure_args``. Specifics will differ depending on the package and its build system. :ref:`Implementing the install method <install-method>` is covered in detail later."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:200
# 6af70dc5ea204a1ba9ee343a181f2d01
msgid "Passing a URL to ``spack create`` is a convenient and easy way to get a basic package template, but what if your software is licensed and cannot be downloaded from a URL? You can still create a boilerplate ``package.py`` by telling ``spack create`` what name you want to use:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:209
# 73472f958c7b48c8adb1b368dad44c05
msgid "This will create a simple ``intel`` package with an ``install()`` method that you can craft to install your package."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:212
# a0cc62159d0a4bb79ced25926bd481a2
msgid "What if ``spack create <url>`` guessed the wrong name or build system? For example, if your package uses the Autotools build system but does not come with a ``configure`` script, Spack won't realize it uses Autotools. You can overwrite the old package with ``--force`` and specify a name with ``--name`` or a build system template to use with ``--template``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:225
# e6c3127ca5bb4676b55be7cfa61c3715
msgid "If you are creating a package that uses the Autotools build system but does not come with a ``configure`` script, you'll need to add an ``autoreconf`` method to your package that explains how to generate the ``configure`` script. You may also need the following dependencies:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:237
# 62e703ff2d044229af702a8a3bbc408c
msgid "A complete list of available build system templates can be found by running ``spack create --help``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:244
# 9276c031d5374bad9507379e0fa5a9ee
msgid "``spack edit``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:246
# d8e0c305e1cd409a8d00f69c1dd2945f
msgid "One of the easiest ways to learn how to write packages is to look at existing ones.  You can edit a package file by name with the ``spack edit`` command:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:254
# ea4247d1fe034fd7a1cafbc7acb0fbf5
msgid "So, if you used ``spack create`` to create a package, then saved and closed the resulting file, you can get back to it with ``spack edit``. The ``gmp`` package actually lives in ``$SPACK_ROOT/var/spack/repos/builtin/packages/gmp/package.py``, but ``spack edit`` provides a much simpler shortcut and saves you the trouble of typing the full path."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:263
# 53b55825f89e46298096743dc43d5db3
msgid "Naming & directory structure"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:265
# fb78d493ee0242e58c44dc9159225626
msgid "This section describes how packages need to be named, and where they live in Spack's directory structure.  In general, :ref:`cmd-spack-create` handles creating package files for you, so you can skip most of the details here."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:272
# 229ee2e5f2a8435f8f1a41ed39051b2a
msgid "``var/spack/repos/builtin/packages``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:274
# 98fa7ab8872f48abb1ed5b697a12b65a
msgid "A Spack installation directory is structured like a standard UNIX install prefix (``bin``, ``lib``, ``include``, ``var``, ``opt``, etc.).  Most of the code for Spack lives in ``$SPACK_ROOT/lib/spack``. Packages themselves live in ``$SPACK_ROOT/var/spack/repos/builtin/packages``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:279
# 432065327d8849938dd2fc1904b2d2b9
msgid "If you ``cd`` to that directory, you will see directories for each package:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:286
# 2c7545f2bd264840a0300e70e3b5ce24
msgid "Each directory contains a file called ``package.py``, which is where all the python code for the package goes.  For example, the ``libelf`` package lives in:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:294
# 87366699465f43848aee534c4931b2c6
msgid "Alongside the ``package.py`` file, a package may contain extra directories or files (like patches) that it needs to build."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:299
# 1ff6869caba24b68a80cf7a13053027a
msgid "Package Names"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:301
# 72adac6e873a42cf886a2dd15ad45f63
msgid "Packages are named after the directory containing ``package.py``. So, ``libelf``'s ``package.py`` lives in a directory called ``libelf``. The ``package.py`` file defines a class called ``Libelf``, which extends Spack's ``Package`` class.  For example, here is ``$SPACK_ROOT/var/spack/repos/builtin/packages/libelf/package.py``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:322
# 76619e9ed6bb4de5856279a11166b6a6
msgid "The **directory name** (``libelf``) determines the package name that users should provide on the command line. e.g., if you type any of these:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:332
# f7a801e6447747d1883618ff314a022f
msgid "Spack sees the package name in the spec and looks for ``libelf/package.py`` in ``var/spack/repos/builtin/packages``. Likewise, if you run ``spack install py-numpy``, Spack looks for ``py-numpy/package.py``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:337
# 31dad042aa0b4251a9f8e5991da6cb7c
msgid "Spack uses the directory name as the package name in order to give packagers more freedom in naming their packages. Package names can contain letters, numbers, and dashes. Using a Python identifier (e.g., a class name or a module name) would make it difficult to support these options.  So, you can name a package ``3proxy`` or ``foo-bar`` and Spack won't care. It just needs to see that name in the packages directory."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:347
# 754a4e00a7084b76bf8c982679ad218a
msgid "Package class names"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:349
# 51269b5db6fe491e9400fd3734efb7e2
msgid "Spack loads ``package.py`` files dynamically, and it needs to find a special class name in the file for the load to succeed.  The **class name** (``Libelf`` in our example) is formed by converting words separated by ``-`` in the file name to CamelCase. If the name starts with a number, we prefix the class name with ``_``. Here are some examples:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:357
# 47e49a04e7f54a528ff78cc1155ef5bf
msgid "Module Name"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:357
# b6d89327d76e411db07a6750a0ccd7ac
msgid "Class Name"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:359
# 7468a7f616354164a4bd5e71ac1c9313
msgid "``foo-bar``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:359
# 0604c1409aa64e24857f05831c7f9fa9
msgid "``FooBar``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:360
# 7ed153e27cde48b29dcf6a6242f2adc3
msgid "``3proxy``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:360
# bd1469e1289c4bd082ef914bcc662663
msgid "``_3proxy``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:363
# 757b688164fe4571b8ce959da56db99b
msgid "In general, you won't have to remember this naming convention because :ref:`cmd-spack-create` and :ref:`cmd-spack-edit` handle the details for you."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:368
# b4305fba80094b929ee9273647611cb0
msgid "Trusted Downloads"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:370
# ba9ea884697345518752b1c91e1c61d9
msgid "Spack verifies that the source code it downloads is not corrupted or compromised; or at least, that it is the same version the author of the Spack package saw when the package was created.  If Spack uses a download method it can verify, we say the download method is *trusted*.  Trust is important for *all downloads*: Spack has no control over the security of the various sites from which it downloads source code, and can never assume that any particular site hasn't been compromised."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:379
# a063cb7a60f84247bb38a399a5315810
msgid "Trust is established in different ways for different download methods. For the most common download method --- a single-file tarball --- the tarball is checksummed.  Git downloads using ``commit=`` are trusted implicitly, as long as a hash is specified."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:384
# 89e73c65d376487b9c7ce3a857dcbdf6
msgid "Spack also provides untrusted download methods: tarball URLs may be supplied without a checksum, or Git downloads may specify a branch or tag instead of a hash.  If the user does not control or trust the source of an untrusted download, it is a security risk.  Unless otherwise specified by the user for special cases, Spack should by default use *only* trusted download methods."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:391
# 2bdffd0afba2474b9027d651fa2356bb
msgid "Unfortunately, Spack does not currently provide that guarantee.  It does provide the following mechanisms for safety:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:394
# 50e090c0ee19466390e053110b293945
msgid "By default, Spack will only install a tarball package if it has a checksum and that checksum matches.  You can override this with ``spack install --no-checksum``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:398
# 6b2b790eb3064f20bfdcbe0de8c9ede0
msgid "Numeric versions are almost always tarball downloads, whereas non-numeric versions not named ``develop`` frequently download untrusted branches or tags from a version control system.  As long as a package has at least one numeric version, and no non-numeric version named ``develop``, Spack will prefer it over any non-numeric versions."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:407
# 0af7c0254e734808b66db21949d67980
msgid "Checksums"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:409
# a07fa7892d0a42a094d99da505c05c3d
msgid "For tarball downloads, Spack can currently support checksums using the MD5, SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 algorithms.  It determines the algorithm to use based on the hash length."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:415
# 17078892e1fd477f876bd80e1488a774
msgid "Versions and fetching"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:417
# c38541951d984eff9ba0cabdd560a277
msgid "The most straightforward way to add new versions to your package is to add a line like this in the package class:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:430
# 930c5a2624cd49d4bb51825b329286a0
msgid "Versions should be listed in descending order, from newest to oldest."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:434
# 6b1e5f454b744c09b7b86493b814a300
msgid "Date Versions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:436
# 090578c9f2564d5191b4ae2b0569c8eb
msgid "If you wish to use dates as versions, it is best to use the format ``@yyyy-mm-dd``.  This will ensure they sort in the correct order."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:439
# 5f42e859a6674d52bf81d053b8e26d62
msgid "Alternately, you might use a hybrid release-version / date scheme. For example, ``@1.3_2016-08-31`` would mean the version from the ``1.3`` branch, as of August 31, 2016."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:445
# ac78c8544d4b4aca83358c4826de3a5f
msgid "Version URLs"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:447
# 1980765139bd49e196f705000e9feb20
msgid "By default, each version's URL is extrapolated from the ``url`` field in the package.  For example, Spack is smart enough to download version ``8.2.1`` of the ``Foo`` package above from http://example.com/foo-8.2.1.tar.gz."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:452
# f69920a6ecfb4162bbbbd4b37e618815
msgid "If the URL is particularly complicated or changes based on the release, you can override the default URL generation algorithm by defining your own ``url_for_version()`` function. For example, the download URL for OpenMPI contains the major.minor version in one spot and the major.minor.patch version in another:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:458
# 680bb2a0fe53482385fb97b9b9ccaab6
msgid "https://www.open-mpi.org/software/ompi/v2.1/downloads/openmpi-2.1.1.tar.bz2"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:460
# 31d4c7dfef7843d187718220a079bc79
msgid "In order to handle this, you can define a ``url_for_version()`` function like so:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:466
# 79d77f58e72e46438140d43d581f1ac7
msgid "With the use of this ``url_for_version()``, Spack knows to download OpenMPI ``2.1.1`` from http://www.open-mpi.org/software/ompi/v2.1/downloads/openmpi-2.1.1.tar.bz2 but download OpenMPI ``1.10.7`` from http://www.open-mpi.org/software/ompi/v1.10/downloads/openmpi-1.10.7.tar.bz2."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:470
# 945cf069221d4d9a9c65d94578870488
msgid "You'll notice that OpenMPI's ``url_for_version()`` function makes use of a special ``Version`` function called ``up_to()``. When you call ``version.up_to(2)`` on a version like ``1.10.0``, it returns ``1.10``. ``version.up_to(1)`` would return ``1``. This can be very useful for packages that place all ``X.Y.*`` versions in a single directory and then places all ``X.Y.Z`` versions in a sub-directory."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:476
# dfbe639176d14f6291aa5d1356d69dee
msgid "There are a few ``Version`` properties you should be aware of. We generally prefer numeric versions to be separated by dots for uniformity, but not all tarballs are named that way. For example, ``icu4c`` separates its major and minor versions with underscores, like ``icu4c-57_1-src.tgz``. The value ``57_1`` can be obtained with the use of the ``version.underscored`` property. Note that Python properties don't need parentheses. There are other separator properties as well:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:484
# b820dd7faa4a48ebae51f72f5f846768
msgid "Property"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:484
# 984247c126e1473d9e40b110fe1cba32
msgid "Result"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:486
# 7f1472d4a83244d8ab2b3b5f491a9623
msgid "version.dotted"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:486
# c698a3f472144b1ab9a56d00df5c1e46
msgid "1.2.3"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:487
# 7c71843005384ea8a5cfaae4c9b76ea0
msgid "version.dashed"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:487
# c368e7490bbe454d8cc6a07411e71186
msgid "1-2-3"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:488
# 650ce63cf1cf46d1b6ee29752834e085
msgid "version.underscored"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:488
# 4ad3e1b4788649c68bfa89add352c3f3
msgid "1_2_3"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:489
# 4c87c23ddc844eb38682a39b8157eb78
msgid "version.joined"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:489
# 066fac0b95be45b78abebdf3edabf815
msgid "123"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:494
# e4af9a07a41b407ba69c4e849e2e0755
msgid "Python properties don't need parentheses. ``version.dashed`` is correct. ``version.dashed()`` is incorrect."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:497
# e0e8b2690bb1443e957ebb08e19fed87
msgid "In addition, these version properties can be combined with ``up_to()``. For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:509
# 2c741cd24ea948ba8398146a08bde3b6
msgid "As you can see, order is not important. Just keep in mind that ``up_to()`` and the other version properties return ``Version`` objects, not strings."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:512
# f4622ae4232e4fdb8fd34a1b6effa954
msgid "If a URL cannot be derived systematically, or there is a special URL for one of its versions, you can add an explicit URL for a particular version:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:521
# b764f1b8c0df4ece8bf8c6d9daf79cd2
msgid "When you supply a custom URL for a version, Spack uses that URL *verbatim* and does not perform extrapolation. The order of precedence of these methods is:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:525
# 6a49372084f84f31930f90c68d890bad
msgid "package-level ``url``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:526
# 36c8463929af4efb87168e343d78ff21
msgid "``url_for_version()``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:527
# f36a14884cdc4ce4ad00b823e6e5daca
msgid "version-specific ``url``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:529
# e2821a9ec6b14b2ebb93a21da48dab54
msgid "so if your package contains a ``url_for_version()``, it can be overridden by a version-specific ``url``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:532
# d6a641e99b2048d087aaa4cf84848b04
msgid "If your package does not contain a package-level ``url`` or ``url_for_version()``, Spack can determine which URL to download from even if only some of the versions specify their own ``url``. Spack will use the nearest URL *before* the requested version. This is useful for packages that have an easy to extrapolate URL, but keep changing their URL format every few releases. With this method, you only need to specify the ``url`` when the URL changes."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:541
# f391c0e2c8614df7b63af9760f4e6a58
msgid "Skipping the expand step"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:543
# 96fa962a159d48e296112f2488078641
msgid "Spack normally expands archives (e.g. ``*.tar.gz`` and ``*.zip``) automatically after downloading them. If you want to skip this step (e.g., for self-extracting executables and other custom archive types), you can add ``expand=False`` to a ``version`` directive."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:553
# f35b0f08970d4195b5e537cbe5908364
msgid "When ``expand`` is set to ``False``, Spack sets the current working directory to the directory containing the downloaded archive before it calls your ``install`` method.  Within ``install``, the path to the downloaded archive is available as ``self.stage.archive_file``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:558
# 8a93a2324c1d4c9faa06c94d9f2aeec4
msgid "Here is an example snippet for packages distributed as self-extracting archives.  The example sets permissions on the downloaded file to make it executable, then runs it with some arguments."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:571
# ce9261130f8b48f6b55971b19f204048
msgid "Download caching"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:573
# 86d138c1deee42438c2de84d27558453
msgid "Spack maintains a cache (described :ref:`here <caching>`) which saves files retrieved during package installations to avoid re-downloading in the case that a package is installed with a different specification (but the same version) or reinstalled on account of a change in the hashing scheme."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:580
# 9030449bfa304dd1a80a2243483793b2
msgid "Version comparison"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:582
# 5cbfc188c64e4ae38048c4e9cf92e233
msgid "Most Spack versions are numeric, a tuple of integers; for example, ``apex@0.1``, ``ferret@6.96`` or ``py-netcdf@1.2.3.1``.  Spack knows how to compare and sort numeric versions."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:586
# 9486cd81931b4897af186ff8f702e6ef
msgid "Some Spack versions involve slight extensions of numeric syntax; for example, ``py-sphinx-rtd-theme@0.1.10a0``.  In this case, numbers are always considered to be \"newer\" than letters.  This is for consistency with `RPM <https://bugzilla.redhat.com/show_bug.cgi?id=50977>`_."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:591
# d7404ab628654d778f825e668409a0a7
msgid "Spack versions may also be arbitrary non-numeric strings; any string here will suffice; for example, ``@develop``, ``@master``, ``@local``. Versions are compared as follows. First, a version string is split into multiple fields based on delimiters such as ``.``, ``-`` etc. Then matching fields are compared using the rules below:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:597
# 9548e94ae5ea4f69af22f395b79f47f0
msgid "The following develop-like strings are greater (newer) than all numbers and are ordered as ``develop > master > head > trunk``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:600
# a3e00c22111640baabe3a0c27ce227be
msgid "Numbers are all less than the chosen develop-like strings above, and are sorted numerically."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:603
# 6d2ea3ffd7cd4bdfbc64ca50269b5241
msgid "All other non-numeric versions are less than numeric versions, and are sorted alphabetically."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:606
# a323f84446dd4276ac16f917d25a41dd
msgid "The logic behind this sort order is two-fold:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:608
# 63ff4c8c1aeb481194656399cf5fd13b
msgid "Non-numeric versions are usually used for special cases while developing or debugging a piece of software.  Keeping most of them less than numeric versions ensures that Spack chooses numeric versions by default whenever possible."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:613
# 30152c8c10574792bea524b50dbc494a
msgid "The most-recent development version of a package will usually be newer than any released numeric versions.  This allows the ``@develop`` version to satisfy dependencies like ``depends_on(abc, when=\"@x.y.z:\")``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:620
# 4dc44edf0794408291075095a9a09cfb
msgid "Version selection"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:622
# 0628990f07f84b7283fa8d42aa404a03
msgid "When concretizing, many versions might match a user-supplied spec. For example, the spec ``python`` matches all available versions of the package ``python``.  Similarly, ``python@3:`` matches all versions of Python3.  Given a set of versions that match a spec, Spack concretization uses the following priorities to decide which one to use:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:629
# 004366f908e44faba25c631618e69229
msgid "If the user provided a list of versions in ``packages.yaml``, the first matching version in that list will be used."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:632
# 679836eeb3f141dc8685660d62997052
msgid "If one or more versions is specified as ``preferred=True``, in either ``packages.yaml`` or ``package.py``, the largest matching version will be used.  (\"Latest\" is defined by the sort order above)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:637
# 5fffb4751ae04314bad9a2237df7220f
msgid "If no preferences in particular are specified in the package or in ``packages.yaml``, then the largest matching non-develop version will be used.  By avoiding ``@develop``, this prevents users from accidentally installing a ``@develop`` version."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:642
# 19f7f4ce2c584347b43fb00788751b89
msgid "If all else fails and ``@develop`` is the only matching version, it will be used."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:650
# 11a533336a28419dac17204bfe6bcbd5
msgid "``spack checksum``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:652
# 809f3e92128947b0820c425b9368ea2c
msgid "If you want to add new versions to a package you've already created, this is automated with the ``spack checksum`` command.  Here's an example for ``libelf``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:674
# 0140283ba29544a9bc292712677b8577
msgid "This does the same thing that ``spack create`` does, but it allows you to go back and add new versions easily as you need them (e.g., as they're released).  It fetches the tarballs you ask for and prints out a list of ``version`` commands ready to copy/paste into your package file:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:688
# 5de22956e46743ce9e750f9f09170e50
msgid "By default, Spack will search for new tarball downloads by scraping the parent directory of the tarball you gave it.  So, if your tarball is at ``http://example.com/downloads/foo-1.0.tar.gz``, Spack will look in ``http://example.com/downloads/`` for links to additional versions. If you need to search another path for download links, you can supply some extra attributes that control how your package finds new versions. See the documentation on :ref:`attribute_list_url` and :ref:`attribute_list_depth`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:699
# b576c5677b094049ac9454730ff28fde
msgid "This command assumes that Spack can extrapolate new URLs from an existing URL in the package, and that Spack can find similar URLs on a webpage.  If that's not possible, e.g. if the package's developers don't name their tarballs consistently, you'll need to manually add ``version`` calls yourself."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:705
# 7f1dc6c3657e4c03b683916711ec86cb
msgid "For ``spack checksum`` to work, Spack needs to be able to ``import`` your package in Python.  That means it can't have any syntax errors, or the ``import`` will fail.  Use this once you've got your package in working order."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:712
# a27ad41b39e24a6bafd1af39eaffef00
msgid "Finding new versions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:714
# 01a3a188de2b48a3b4895f26921c8e5c
msgid "You've already seen the ``homepage`` and ``url`` package attributes:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:728
# 90f09a5cdd7a46c1b63048882375163f
msgid "These are class-level attributes used by Spack to show users information about the package, and to determine where to download its source code."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:732
# e50bd89433e54ab1be1d7d2bab1f5e05
msgid "Spack uses the tarball URL to extrapolate where to find other tarballs of the same package (e.g. in :ref:`cmd-spack-checksum`, but this does not always work.  This section covers ways you can tell Spack to find tarballs elsewhere."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:741
# d3fe1a1841a348e59fc324f198dfe2c7
msgid "``list_url``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:743
# b8463c9e2ca54a289053e815f290eb4d
msgid "When spack tries to find available versions of packages (e.g. with :ref:`cmd-spack-checksum`), it spiders the parent directory of the tarball in the ``url`` attribute.  For example, for libelf, the url is:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:752
# 881634823c1048f88ef9a06f4b24409e
msgid "Here, Spack spiders ``http://www.mr511.de/software/`` to find similar tarball links and ultimately to make a list of available versions of ``libelf``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:756
# 89cd902cc83f4722bd1a6e7cdc03d1f1
msgid "For many packages, the tarball's parent directory may be unlistable, or it may not contain any links to source code archives.  In fact, many times additional package downloads aren't even available in the same directory as the download URL."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:761
# ca0f0c2a583146d4995ae936b5dd7ea5
msgid "For these, you can specify a separate ``list_url`` indicating the page to search for tarballs.  For example, ``libdwarf`` has the homepage as the ``list_url``, because that is where links to old versions are:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:777
# 3a91e0058a2346de8f52b960232eaa09
msgid "``list_depth``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:779
# c0825ced2c204881aa33301e32879251
msgid "``libdwarf`` and many other packages have a listing of available versions on a single webpage, but not all do.  For example, ``mpich`` has a tarball URL that looks like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:787
# 0945dff435784de3bc28350c775feb02
msgid "But its downloads are in many different subdirectories of ``http://www.mpich.org/static/downloads/``.  So, we need to add a ``list_url`` *and* a ``list_depth`` attribute:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:800
# 84dc46663c1c43c19a067d8169cdefda
msgid "By default, Spack only looks at the top-level page available at ``list_url``.  ``list_depth = 1`` tells it to follow up to 1 level of links from the top-level page.  Note that here, this implies 1 level of subdirectories, as the ``mpich`` website is structured much like a filesystem.  But ``list_depth`` really refers to link depth when spidering the page."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:811
# f0921fcb7eb64ac4a774aa15c9731168
msgid "Fetching from code repositories"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:813
# 65987cf907834ded90b77bb31ea46bcf
msgid "For some packages, source code is provided in a Version Control System (VCS) repository rather than in a tarball.  Spack can fetch packages from VCS repositories. Currently, Spack supports fetching with `Git <git-fetch_>`_, `Mercurial (hg) <hg-fetch_>`_, `Subversion (svn) <svn-fetch_>`_, and `Go <go-fetch_>`_."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:819
# 3e58ad74c08e4bf8a6eb26bc4ae277d3
msgid "To fetch a package from a source repository, Spack needs to know which VCS to use and where to download from. Much like with ``url``, package authors can specify a class-level ``git``, ``hg``, ``svn``, or ``go`` attribute containing the correct download location."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:824
# 2efd01a1ffb841cdb3b4b398eb1f744b
msgid "Many packages developed with Git have both a Git repository as well as release tarballs available for download. Packages can define both a class-level tarball URL and VCS. For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:842
# 7a608b1c927d4bb38bad8056f32fb027
msgid "If a package contains both a ``url`` and ``git`` class-level attribute, Spack decides which to use based on the arguments to the ``version()`` directive. Versions containing a specific branch, tag, or revision are assumed to be for VCS download methods, while versions containing a checksum are assumed to be for URL download methods."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:848
# c8a645c0c9fd4f0a906f445cd0c1fe53
msgid "Like ``url``, if a specific version downloads from a different repository than the default repo, it can be overridden with a version-specific argument."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:853
# 0578218c83f24f97b92f64ce6d51c23b
msgid "In order to reduce ambiguity, each package can only have a single VCS top-level attribute in addition to ``url``. In the rare case that a package uses multiple VCS, a fetch strategy can be specified for each version. For example, the ``rockstar`` package contains:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:872
# 08d5c69e2ab543398e6b1168e31c1b90
msgid "Git"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:874
# 75564a1749314a3c81fda72b77d4eff1
msgid "Git fetching supports the following parameters to ``version``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:876
# ac0dd1b267da4b9394c6e310dd4c1082
msgid "``git``: URL of the git repository, if different than the class-level ``git``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:877
# cb26638a63bb47a8b082d542aff19b46
msgid "``branch``: Name of a branch to fetch."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:878
# e6ccc747fab0402d829d2f9bd2ad3f54
msgid "``tag``: Name of a tag to fetch."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:879
# 42825a4599a448e3b93fadc48b9458cf
msgid "``commit``: SHA hash (or prefix) of a commit to fetch."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:880
# 5158f939d2314f1fa8fb6e647b65808c
msgid "``submodules``: Also fetch submodules recursively when checking out this repository."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:882
# 1eb0f09031e84ec68829114448c4c158
msgid "Only one of ``tag``, ``branch``, or ``commit`` can be used at a time."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:899
#: ../spack/lib/spack/docs/packaging_guide.rst:998
# 701bdb7403fb4ce78683f745bed26528
# dbbd299de7cb4304974de6a2f9ed57dc
msgid "Default branch"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:885
# a48f61f6f8874820a532c13f3a5afd1f
msgid "To fetch a repository's default branch:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:895
# eae38f30f8f14180a4a70f3bd3fa13a2
msgid "This download method is untrusted, and is not recommended. Aside from HTTPS, there is no way to verify that the repository has not been compromised, and the commit you get when you install the package likely won't be the same commit that was used when the package was first written. Additionally, the default branch may change. It is best to at least specify a branch name."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:910
# 5b048a0eb6bc4ad4b114fe22b4c1c518
msgid "Branches"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:902
# d48e923784554577bf9bd3d255fb0790
msgid "To fetch a particular branch, use the ``branch`` parameter:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:908
# 0d3c0d40be944188ab0af2439f5ac4d8
msgid "This download method is untrusted, and is not recommended. Branches are moving targets, so the commit you get when you install the package likely won't be the same commit that was used when the package was first written."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:922
# 20dbc407b70b47e188a22a14a4788dbe
msgid "Tags"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:913
# c9aed3cffa0a40fcb200792daa766175
msgid "To fetch from a particular tag, use ``tag`` instead:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:919
# 334b26bccd9346dda78d411613a8ba69
msgid "This download method is untrusted, and is not recommended. Although tags are generally more stable than branches, Git allows tags to be moved. Many developers use tags to denote rolling releases, and may move the tag when a bug is patched."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:946
# 3bb28aa28793421e81a58054e07243ac
msgid "Commits"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:925
# 8081f02cf49c483a9c0e6df016e39ffa
msgid "Finally, to fetch a particular commit, use ``commit``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:931
# 4eb045e0bad442528add842c517e0745
msgid "This doesn't have to be a full hash; you can abbreviate it as you'd expect with git:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:938
# d723d7ccb4ba4b68aa6c07450ecf20e8
msgid "This download method *is trusted*.  It is the recommended way to securely download from a Git repository."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:941
# af9ca9864892473d93546a818cb37c87
msgid "It may be useful to provide a saner version for commits like this, e.g. you might use the date as the version, as done above. Or, if you know the commit at which a release was cut, you can use the release version. It's up to the package author to decide what makes the most sense. Although you can use the commit hash as the version number, this is not recommended, as it won't sort properly."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:956
# 206318d6db744332b821f70a200b4b97
msgid "Submodules"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:949
# ccf5454cec6a4a8dbd547943ac66eca4
msgid "You can supply ``submodules=True`` to cause Spack to fetch submodules recursively along with the repository at fetch time. For more information about git submodules see the manpage of git: ``man git-submodule``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:962
# 4ea825fb9daf4bb297fa0d7dab52ed8e
msgid "GitHub"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:964
# 2235a6de8cad41e785e0ac239a44193b
msgid "If a project is hosted on GitHub, *any* valid Git branch, tag, or hash may be downloaded as a tarball.  This is accomplished simply by constructing an appropriate URL.  Spack can checksum any package downloaded this way, thereby producing a trusted download.  For example, the following downloads a particular hash, and then applies a checksum."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:980
# 9512f8b1debd4f64ba50d14e18954ed0
msgid "Mercurial"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:982
# 757a761f46f441a9a656029632768547
msgid "Fetching with Mercurial works much like `Git <git-fetch>`_, but you use the ``hg`` parameter."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:986
# 9268510717b445a7b9ae92df1941084e
msgid "Add the ``hg`` attribute with no ``revision`` passed to ``version``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:996
# 7dc70404ead6443990450c015809ef98
msgid "This download method is untrusted, and is not recommended. As with Git's default fetching strategy, there is no way to verify the integrity of the download."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1013
# 82bbac36b52347a883c15aea51715bd9
msgid "Revisions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1001
# 14eb9679fb5c489fb79b29c9addf8cb8
msgid "To fetch a particular revision, use the ``revision`` parameter:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1007
# 506cecad47f64e9d8c0aec1b5fcd6c95
msgid "Unlike ``git``, which has special parameters for different types of revisions, you can use ``revision`` for branches, tags, and commits when you fetch with Mercurial. Like Git, fetching specific branches or tags is an untrusted download method, and is not recommended. The recommended fetch strategy is to specify a particular commit hash as the revision."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1019
# 799923cc2a304d748e4a408e9e8c5a79
msgid "Subversion"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1021
# 756064aa516c425fa9d9f9776544aaa1
msgid "To fetch with subversion, use the ``svn`` and ``revision`` parameters."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1035
# b0a864ce75f04a92b6219331b46bd17b
msgid "Fetching the head"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1024
# 04ea107e2e884c9f928b2c7b41d662b8
msgid "Simply add an ``svn`` parameter to the package:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1034
# e3e94b6764774575963bdda057a0c548
msgid "This download method is untrusted, and is not recommended for the same reasons as mentioned above."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1050
# 665d5534002844ddb7a6b04f170abe7e
msgid "Fetching a revision"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1038
# 60f98da0cefb4c44a6b2658b52bb5886
msgid "To fetch a particular revision, add a ``revision`` argument to the version directive:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1045
# ae24c5c6e3ca4f6da4221b1140ff312c
msgid "This download method is untrusted, and is not recommended."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1047
# 5767640ce7fc4a009d94059dd21bb3f7
msgid "Unfortunately, Subversion has no commit hashing scheme like Git and Mercurial do, so there is no way to guarantee that the download you get is the same as the download used when the package was created. Use at your own risk."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1052
# 356dc6da54714729b4aadc189b6a9860
msgid "Subversion branches are handled as part of the directory structure, so you can check out a branch or tag by changing the URL. If you want to package multiple branches, simply add a ``svn`` argument to each version directive."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1061
# 96f33fee5b004aceae076a2f624a8ab3
msgid "Go"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1063
# 0c8934c27aba4f349c534c71409041c8
msgid "Go isn't a VCS, it is a programming language with a builtin command, `go get <https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies>`_, that fetches packages and their dependencies automatically. It can clone a Git repository, or download from another source location. For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1078
# 87fe8bb5628e42f490105a33342baf26
msgid "Go cannot be used to fetch a particular commit or branch, it always downloads the head of the repository. This download method is untrusted, and is not recommended. Use another fetch strategy whenever possible."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1080
# 5350951f77344c25aca36eec334b2f50
msgid "and is not recommended. Use another fetch strategy whenever possible."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1084
# f3c4cea06d024c9b91c1948da89853e7
msgid "Variants"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1086
# 103e4ecd8a0c4ad2ba2432f713bd8c64
msgid "Many software packages can be configured to enable optional features, which often come at the expense of additional dependencies or longer build-times. To be flexible enough and support a wide variety of use cases, Spack permits to expose to the end-user the ability to choose which features should be activated in a package at the time it is installed. The mechanism to be employed is the :py:func:`spack.directives.variant` directive."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1095
# 7e412f7f000f470a94ac24f4cb5aab30
msgid "Boolean variants"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1097
# d0e2de2b87814c7f9b3ba6a936be2016
msgid "In their simplest form variants are boolean options specified at the package level:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1108
# 927dffe01ed34b8fae1294cd63cc6ce3
msgid "with a default value and a description of their meaning / use in the package. *Variants can be tested in any context where a spec constraint is expected.* In the example above the ``shared`` variant is tied to the build of shared dynamic libraries. To pass the right option at configure time we can branch depending on its value:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1124
# 88b32f558216403587da19815d792190
msgid "As explained in :ref:`basic-variants` the constraint ``+shared`` means that the boolean variant is set to ``True``, while ``~shared`` means it is set to ``False``. Another common example is the optional activation of an extra dependency which requires to use the variant in the ``when`` argument of :py:func:`spack.directives.depends_on`:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1138
# 4b60247153164753b3a76da69ef9d49e
msgid "as shown in the snippet above where ``szip`` is modeled to be an optional dependency of ``hdf5``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1143
# cb3b4079752541539e6df68b72221ec8
msgid "Multi-valued variants"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1145
# 4e123e9e657b42408bbc5b61696044e3
msgid "If need be, Spack can go beyond Boolean variants and permit an arbitrary number of allowed values. This might be useful when modeling options that are tightly related to each other. The values in this case are passed to the :py:func:`spack.directives.variant` directive as a tuple:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1160
# 420f7456b0e948c9b0ab3fd0d5ac481a
msgid "In the example above the argument ``multi`` is set to ``False`` to indicate that only one among all the variant values can be active at any time. This constraint is enforced by the parser and an error is emitted if a user specifies two or more values at the same time:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1176
# 7370f4a8270e4ae296647d2a7405b07b
msgid "Another useful note is that *Python's* ``None`` *is not allowed as a default value* and therefore it should not be used to denote that no feature was selected. Users should instead select another value, like ``'none'``, and handle it explicitly within the package recipe if need be:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1186
# 9f569953b7534d84935db012385ce89f
msgid "In cases where multiple values can be selected at the same time ``multi`` should be set to ``True``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1201
# e638d3db20494f14b3f207464982a397
msgid "Within a package recipe a multi-valued variant is tested using a ``key=value`` syntax:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1210
# 597b670949eb4ac0b29508a33622262c
msgid "Complex validation logic for variant values"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1211
# eb91f1c93bfa43239d2b4c5a323c39d9
msgid "To cover complex use cases, the :py:func:`spack.directives.variant` directive could accept as the ``values`` argument a full-fledged object which has ``default`` and other arguments of the directive embedded as attributes."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1215
# 9f4733304a3c44febad2c1317883a5d2
msgid "An example, already implemented in Spack's core, is :py:class:`spack.variant.DisjointSetsOfValues`. This class is used to implement a few convenience functions, like :py:func:`spack.variant.any_combination_of`:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1229
# afbc6574c9e3478a92464aef0c7f09fb
msgid "that allows any combination of the specified values, and also allows the user to specify ``'none'`` (as a string) to choose none of them. The objects returned by these functions can be modified at will by chaining method calls to change the default value, customize the error message or other similar operations:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1252
# e1832f2a53d5434b90fb795f6167853c
msgid "Resources (expanding extra tarballs)"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1254
# aea6912337cd4d2893e57027db72a398
msgid "Some packages (most notably compilers) provide optional features if additional resources are expanded within their source tree before building. In Spack it is possible to describe such a need with the ``resource`` directive :"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1267
# 3ff8bba70acd443898a702e29bb593d1
msgid "Based on the keywords present among the arguments the appropriate ``FetchStrategy`` will be used for the resource. The keyword ``destination`` is relative to the source root of the package and should point to where the resource is to be expanded."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1275
# 8f921d6fba8e474282ab747f0f3b854a
msgid "Licensed software"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1277
# 60a9c6f6ec87496d8e6acb93adb0dbd3
msgid "In order to install licensed software, Spack needs to know a few more details about a package. The following class attributes should be defined."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1282
# 73c8b3a6c45d42f4a3cf3e17d3bc0af7
msgid "``license_required``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1284
# c1344075d5b94dd0bff8b2ca94f34e8d
msgid "Boolean. If set to ``True``, this software requires a license. If set to ``False``, all of the following attributes will be ignored. Defaults to ``False``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1290
# 2ea3234b22644ff1af3155022fa64689
msgid "``license_comment``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1292
# 3a808c1a2d094391a2b35be6fc4bb74f
msgid "String. Contains the symbol used by the license manager to denote a comment. Defaults to ``#``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1297
# 0f732a1b39374e5f92433543280198b4
msgid "``license_files``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1299
# 30ccfec721bc4205967aa58d936a2700
msgid "List of strings. These are files that the software searches for when looking for a license. All file paths must be relative to the installation directory. More complex packages like Intel may require multiple licenses for individual components. Defaults to the empty list."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1306
# 23e73eea96474ace9603d3e059fb13be
msgid "``license_vars``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1308
# 4e1ca7f6fb3b47c19425ee95af215849
msgid "List of strings. Environment variables that can be set to tell the software where to look for a license if it is not in the usual location. Defaults to the empty list."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1314
# 8e9d2297c17e4291b00b014f822bb3ff
msgid "``license_url``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1316
# aa895cc8cd134a9ab23d987f0093faf2
msgid "String. A URL pointing to license setup instructions for the software. Defaults to the empty string."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1319
# 296c8b33f6df4d66bd9d7c593d061bf5
msgid "For example, let's take a look at the package for the PGI compilers."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1330
# b45dd0c581174ccb9066b165706aa640
msgid "As you can see, PGI requires a license. Its license manager, FlexNet, uses the ``#`` symbol to denote a comment. It expects the license file to be named ``license.dat`` and to be located directly in the installation prefix. If you would like the installation file to be located elsewhere, simply set ``PGROUPD_LICENSE_FILE`` or ``LM_LICENSE_FILE`` after installation. For further instructions on installation and licensing, see the URL provided."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1337
# bcfd0df9dd7544dcbeacd88952783faa
msgid "Let's walk through a sample PGI installation to see exactly what Spack is and isn't capable of. Since PGI does not provide a download URL, it must be downloaded manually. It can either be added to a mirror or located in the current directory when ``spack install pgi`` is run. See :ref:`mirrors` for instructions on setting up a mirror."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1343
# a688ca65387e41538f757078b70832f3
msgid "After running ``spack install pgi``, the first thing that will happen is Spack will create a global license file located at ``$SPACK_ROOT/etc/spack/licenses/pgi/license.dat``. It will then open up the file using the editor set in ``$EDITOR``, or vi if unset. It will look like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1376
# e4180e93284942e295b4a56ec7eb99e8
msgid "You can add your license directly to this file, or tell FlexNet to use a license stored on a separate license server. Here is an example that points to a license server called licman1:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1385
# 5ba414d2826c453296b40a434451341c
msgid "If your package requires the license to install, you can reference the location of this global license using ``self.global_license_file``. After installation, symlinks for all of the files given in ``license_files`` will be created, pointing to this global license. If you install a different version or variant of the package, Spack will automatically detect and reuse the already existing global license."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1392
# 5d9ff3772cae4c8d97c28ce0e54e7abe
msgid "If the software you are trying to package doesn't rely on license files, Spack will print a warning message, letting the user know that they need to set an environment variable or pointing them to installation documentation."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1401
# 7b1f7a64a391436e9fbda62ddf2310f8
msgid "Patches"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1403
# 853327d9809244ed8ad1fd347fd5e406
msgid "Depending on the host architecture, package version, known bugs, or other issues, you may need to patch your software to get it to build correctly.  Like many other package systems, spack allows you to store patches alongside your package files and apply them to source code after it's downloaded."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1411
# 4adbb4de8d7049479b15bc4c8f372ed4
msgid "``patch``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1413
# ae160914ee2247c280bb2ce1d8405e65
msgid "You can specify patches in your package file with the ``patch()`` directive.  ``patch`` looks like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1422
# 99cec69fa3a842709549d8bab3feb468
msgid "The first argument can be either a URL or a filename.  It specifies a patch file that should be applied to your source.  If the patch you supply is a filename, then the patch needs to live within the spack source tree.  For example, the patch above lives in a directory structure like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1435
# db25194f0bb044b787e6bcf9fce190dd
msgid "If you supply a URL instead of a filename, you need to supply a ``sha256`` checksum, like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1443
# c1a4fa7c7a80474bbfc4cc8292cc9ba9
msgid "Spack includes the hashes of patches in its versioning information, so that the same package with different patches applied will have different hash identifiers.  To ensure that the hashing scheme is consistent, you must use a ``sha256`` checksum for the patch.  Patches will be fetched from their URLs, checked, and applied to your source code.  You can use the ``spack sha256`` command to generate a checksum for a patch file or URL."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1451
# fccbc5349a3e4faaa298dff88d603ae7
msgid "Spack can also handle compressed patches.  If you use these, Spack needs a little more help.  Specifically, it needs *two* checksums: the ``sha256`` of the patch and ``archive_sha256`` for the compressed archive.  ``archive_sha256`` helps Spack ensure that the downloaded file is not corrupted or malicious, before running it through a tool like ``tar`` or ``zip``.  The ``sha256`` of the patch is still required so that it can be included in specs.  Providing it in the package file ensures that Spack won't have to download and decompress patches it won't end up using at install time.  Both the archive and patch checksum are checked when patch archives are downloaded."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1468
# fcaa3b87428644cca1dede5681ba5c8c
msgid "``patch`` keyword arguments are described below."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1472
# 7c06dd7c0a7a43a28f991521fe2b02f9
msgid "``sha256``, ``archive_sha256``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1474
# aac2dc9c72f941d7b7ae31746803a93b
msgid "Hashes of downloaded patch and compressed archive, respectively.  Only needed for patches fetched from URLs."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1479
# e5bdb5a994f44b0e9e68dafbc6294c86
msgid "``when``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1481
# afb93b6e17314586ba51d63830990efb
msgid "If supplied, this is a spec that tells spack when to apply the patch.  If the installed package spec matches this spec, the patch will be applied.  In our example above, the patch is applied when mvapich is at version ``1.9`` or higher."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1488
# bfb475aa79aa40788dbe0cf474330d52
msgid "``level``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1490
# b8ab961eccb94aad8c69895c3e7a39b2
msgid "This tells spack how to run the ``patch`` command.  By default, the level is 1 and spack runs ``patch -p 1``.  If level is 2, spack will run ``patch -p 2``, and so on."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1494
# ff9fd10655ba45e9aeabe8e32b33981e
msgid "A lot of people are confused by level, so here's a primer.  If you look in your patch file, you may see something like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1512
# 1637da64bbd04fe48de524a6b41b9f26
msgid "Lines 1-2 show paths with synthetic ``a/`` and ``b/`` prefixes.  These are placeholders for the two ``mvapich2`` source directories that ``diff`` compared when it created the patch file.  This is git's default behavior when creating patch files, but other programs may behave differently."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1518
# d4f562d9ea6e47a89016360c7f8ab528
msgid "``-p1`` strips off the first level of the prefix in both paths, allowing the patch to be applied from the root of an expanded mvapich2 archive.  If you set level to ``2``, it would strip off ``src``, and so on."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1523
# ba341e92e0034c63854e2d12a87d21c7
msgid "It's generally easier to just structure your patch file so that it applies cleanly with ``-p1``, but if you're using a patch you didn't create yourself, ``level`` can be handy."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1529
# 99db3f38345e4f9f9c07c5c8e4383362
msgid "``working_dir``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1531
# 52517fcf49dd461a921cd41d7ff72fd3
msgid "This tells spack where to run the ``patch`` command.  By default, the working directory is the source path of the stage (``.``). However, sometimes patches are made with respect to a subdirectory and this is where the working directory comes in handy. Internally, the working directory is given to ``patch`` via the ``-d`` option. Let's take the example patch from above and assume for some reason, it can only be downloaded in the following form:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1554
# c26490f3e7d444108fb3f4c95bbd6b56
msgid "Hence, the patch needs to applied in the ``src/mpi`` subdirectory, and the ``working_dir='src/mpi'`` option would exactly do that."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1559
# a361b209260d434ea8490f661ebc5640
msgid "Patch functions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1561
# ebca1cb4c2244cda8dc578bd9e66deda
msgid "In addition to supplying patch files, you can write a custom function to patch a package's source.  For example, the ``py-pyside`` package contains some custom code for tweaking the way the PySide build handles ``RPATH``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1572
# 3e9c22f2d5834defae19d0831922d57e
msgid "A ``patch`` function, if present, will be run after patch files are applied and before ``install()`` is run."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1575
# dd9c0ab28c1a46509e265b4c8dc97362
msgid "You could put this logic in ``install()``, but putting it in a patch function gives you some benefits.  First, spack ensures that the ``patch()`` function is run once per code checkout.  That means that if you run install, hit ctrl-C, and run install again, the code in the patch function is only run once.  Also, you can tell Spack to run only the patching part of the build using the :ref:`cmd-spack-patch` command."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1586
#: ../spack/lib/spack/docs/packaging_guide.rst:1933
# 26993835d56f4c629cb6d1c70539c07a
# 24ddcf78b0084b888877438f075f480f
msgid "Dependency patching"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1588
# acf03a5ad558488f86dd06e607a6d4a4
msgid "So far we've covered how the ``patch`` directive can be used by a package to patch *its own* source code. Packages can *also* specify patches to be applied to their dependencies, if they require special modifications.  As with all packages in Spack, a patched dependency library can coexist with other versions of that library.  See the `section on depends_on <dependency_dependency_patching_>`_ for more details."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1599
# 86882abb0f784cf2937d21787392e41f
msgid "Inspecting patches"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1601
# 1dea6050828b47509df591c9519f2d30
msgid "If you want to better understand the patches that Spack applies to your packages, you can do that using ``spack spec``, ``spack find``, and other query commands.  Let's look at ``m4``.  If you run ``spack spec m4``, you can see the patches that would be applied to ``m4``::"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1616
# 4ef1440ba194431e8849250a4a0aeb39
msgid "You can also see patches that have been applied to installed packages with ``spack find -v``::"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1626
# 5cf6168379164a5c95cb0ca38406a9c8
msgid "In both cases above, you can see that the patches' sha256 hashes are stored on the spec as a variant.  As mentioned above, this means that you can have multiple, differently-patched versions of a package installed at once."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1631
# 392a5472bbfb4efa88eed4382803c6a5
msgid "You can look up a patch by its sha256 hash (or a short version of it) using the ``spack resource show`` command::"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1639
# 17ad74c7155e4c23ad6ab9e2bb884722
msgid "``spack resource show`` looks up downloadable resources from package files by hash and prints out information about them.  Above, we see that the ``3877ab54`` patch applies to the ``m4`` package.  The output also tells us where to find the patch."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1644
# 4036120303c149a6b2fc1f35b29a3c88
msgid "Things get more interesting if you want to know about dependency patches. For example, when ``dealii`` is built with ``boost@1.68.0``, it has to patch boost to work correctly.  If you didn't know this, you might wonder where the extra boost patches are coming from::"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1658
# ae216ef10b5a41d0b860eb92b583c327
msgid "Here you can see that the patch is applied to ``boost`` by ``dealii``, and that it lives in ``dealii``'s directory in Spack's ``builtin`` package repository."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1666
# 854fdcaa900348ce8e28c3294ff9238c
msgid "Handling RPATHs"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1668
# 3dc98d1539604a729df5720156592cf3
msgid "Spack installs each package in a way that ensures that all of its dependencies are found when it runs.  It does this using `RPATHs <http://en.wikipedia.org/wiki/Rpath>`_.  An RPATH is a search path, stored in a binary (an executable or library), that tells the dynamic loader where to find its dependencies at runtime. You may be familiar with `LD_LIBRARY_PATH <http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html>`_ on Linux or `DYLD_LIBRARY_PATH <https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html>`_ on Mac OS X.  RPATH is similar to these paths, in that it tells the loader where to find libraries.  Unlike them, it is embedded in the binary and not set in each user's environment."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1681
# 30e625195d124146a292742a4c3b5ecc
msgid "RPATHs in Spack are handled in one of three ways:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1683
# 4331d60dbb864918a2e478e666c60872
msgid "For most packages, RPATHs are handled automatically using Spack's :ref:`compiler wrappers <compiler-wrappers>`.  These wrappers are set in standard variables like ``CC``, ``CXX``, ``F77``, and ``FC``, so most build systems (autotools and many gmake systems) pick them up and use them."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1688
# a59f17ad6161421bad951b8a4ce950f2
msgid "CMake also respects Spack's compiler wrappers, but many CMake builds have logic to overwrite RPATHs when binaries are installed. Spack provides the ``std_cmake_args`` variable, which includes parameters necessary for CMake build use the right installation RPATH.  It can be used like this when ``cmake`` is invoked:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1704
# da600fb33dfd49a5bbc3f95a76ae428a
msgid "If you need to modify the build to add your own RPATHs, you can use the ``self.rpath`` property of your package, which will return a list of all the RPATHs that Spack will use when it links.  You can see this how this is used in the :ref:`PySide example <pyside-patch>` above."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1714
# bcf16b756e59415bb910e79d768aca14
msgid "Parallel builds"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1716
# 8af48288803a4650951261f6ce662f62
msgid "By default, Spack will invoke ``make()`` with a ``-j <njobs>`` argument, so that builds run in parallel.  It figures out how many jobs to run by determining how many cores are on the host machine. Specifically, it uses the number of CPUs reported by Python's `multiprocessing.cpu_count() <http://docs.python.org/library/multiprocessing.html#multiprocessing.cpu_count>`_."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1723
# 55615e2860c84c3b8311e0079683b88b
msgid "If a package does not build properly in parallel, you can override this setting by adding ``parallel = False`` to your package.  For example, OpenSSL's build does not work in parallel, so its package looks like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1741
# 738210774432467c9f606c17aa78fc72
msgid "Similarly, you can disable parallel builds only for specific make commands, as ``libdwarf`` does:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1761
# 08012b1ba9ee4b19a34c9acb9bea83dc
msgid "The first make will run in parallel here, but the second will not.  If you set ``parallel`` to ``False`` at the package level, then each call to ``make()`` will be sequential by default, but packagers can call ``make(parallel=True)`` to override it."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1770
# 61fce9a2d2b74ab1a201557387faa048
msgid "Dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1772
# a60a3ac1686741c986e43381a124558a
msgid "We've covered how to build a simple package, but what if one package relies on another package to build?  How do you express that in a package file?  And how do you refer to the other package in the build script for your own package?"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1777
# df4084915d45480fb55f648a8c126858
msgid "Spack makes this relatively easy.  Let's take a look at the ``libdwarf`` package to see how it's done:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1799
# d63a6a68f1a44956af2320f1be4aef97
msgid "``depends_on()``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1801
# 65e81231a8bd4e2b81dafc3ead722ea3
msgid "The highlighted ``depends_on('libelf')`` call tells Spack that it needs to build and install the ``libelf`` package before it builds ``libdwarf``.  This means that in your ``install()`` method, you are guaranteed that ``libelf`` has been built and installed successfully, so you can rely on it for your libdwarf build."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1809
# 68136c15bb7f449d8f991619ce4221e2
msgid "Dependency specs"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1811
# 651b1a8de1e24e02b1468269d05398e5
msgid "``depends_on`` doesn't just take the name of another package. It can take a full spec as well. This means that you can restrict the versions or other configuration options of ``libelf`` that ``libdwarf`` will build with. For example, suppose that in the ``libdwarf`` package you write:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1820
# 4a08b730009a498b94fac664b4bca94c
msgid "Now ``libdwarf`` will require ``libelf`` at *exactly* version ``0.8``. You can also specify a requirement for a particular variant or for specific compiler flags:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1830
# 7397f35037874c2fb219ac0ca8840ff5
msgid "Both users *and* package authors can use the same spec syntax to refer to different package configurations. Users use the spec syntax on the command line to find installed packages or to install packages with particular constraints, and package authors can use specs to describe relationships between packages."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1838
# 28a173dafc1441fb8dfcee065c1e07f2
msgid "Version ranges"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1840
# 0bf5f873fdc44beb80c0c29adcc45609
msgid "Although some packages require a specific version for their dependencies, most can be built with a range of version. For example, if you are writing a package for a legacy Python module that only works with Python 2.4 through 2.6, this would look like:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1849
# 71a53e0815174dc4bf8bf30b6b4d940d
msgid "Version ranges in Spack are *inclusive*, so ``2.4:2.6`` means any version greater than or equal to ``2.4`` and up to and including ``2.6``. If you want to specify that a package works with any version of Python 3, this would look like:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1858
# 95e2a4eaa22b4f55bfe466f84c700618
msgid "Here we leave out the upper bound. If you want to say that a package requires Python 2, you can similarly leave out the lower bound:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1865
# dfc80b34d2f44ea9b19144537c364425
msgid "Notice that we didn't use ``@:3``. Version ranges are *inclusive*, so ``@:3`` means \"up to and including 3\"."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1868
# c8eb762536d34b9f9d31527be18fcbda
msgid "What if a package can only be built with Python 2.6? You might be inclined to use:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1875
# 4c409b48c7fe4821ac1719e0e191d95f
msgid "However, this would be wrong. Spack assumes that all version constraints are absolute, so it would try to install Python at exactly ``2.6``. The correct way to specify this would be:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1883
# c499c2a3b7254b7ba26158f19f2f8e6f
msgid "A spec can contain multiple version ranges separated by commas. For example, if you need Boost 1.59.0 or newer, but there are known issues with 1.64.0, 1.65.0, and 1.66.0, you can say:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1894
# b4169f4e62f84a4b88f5bcede01c4bf5
msgid "Dependency types"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1896
# 2b4223f673a94fb69e745fb796228799
msgid "Not all dependencies are created equal, and Spack allows you to specify exactly what kind of a dependency you need. For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1905
# fb0a4a0b4f66437092a9a322a9d43328
msgid "The following dependency types are available:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1907
# 965602edd3fa4486a6eea8df57a9820b
msgid "**\"build\"**: made available during the project's build. The package will be added to ``PATH``, the compiler include paths, and ``PYTHONPATH``. Other projects which depend on this one will not have these modified (building project X doesn't need project Y's build dependencies)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1911
# 9d8395e1ac7e468385292722a1c02c8e
msgid "**\"link\"**: the project is linked to by the project. The package will be added to the current package's ``rpath``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1913
# 63691f52acb844acaea5f0e43340cd40
msgid "**\"run\"**: the project is used by the project at runtime. The package will be added to ``PATH`` and ``PYTHONPATH``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1916
# 358323d0bda84d269913b04af0c9190c
msgid "One of the advantages of the ``build`` dependency type is that although the dependency needs to be installed in order for the package to be built, it can be uninstalled without concern afterwards. ``link`` and ``run`` disallow this because uninstalling the dependency would break the package."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1921
# 752ed70ac4a54ef0a1c5fef99a0a4cbb
msgid "If the dependency type is not specified, Spack uses a default of ``('build', 'link')``. This is the common case for compiler languages. Non-compiled packages like Python modules commonly use ``('build', 'run')``. This means that the compiler wrappers don't need to inject the dependency's ``prefix/lib`` directory, but the package needs to be in ``PATH`` and ``PYTHONPATH`` during the build process and later when a user wants to run the package."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1935
# 075aa96f04224d918f4dd35f6dff5d7c
msgid "Some packages maintain special patches on their dependencies, either to add new features or to fix bugs.  This typically makes a package harder to maintain, and we encourage developers to upstream (contribute back) their changes rather than maintaining patches.  However, in some cases it's not possible to upstream. Maybe the dependency's developers don't accept changes, or maybe they just haven't had time to integrate them."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1942
# 5de72a1f87c94ac4869e82d6bc74ce7c
msgid "For times like these, Spack's ``depends_on`` directive can optionally take a patch or list of patches:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1952
# e6ce8ecf648945dcaec9937189f4f972
msgid "Here, the ``special-tool`` package requires a special feature in ``binutils``, so it provides an extra ``patches=<filename>`` keyword argument.  This is similar to the `patch directive <patching_>`_, with one small difference.  Here, ``special-tool`` is responsible for the patch, so it should live in ``special-tool``'s directory in the package repository, not the ``binutils`` directory."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1959
# 67cdf9951c3647f1920d7b24ced81e82
msgid "If you need something more sophisticated than this, you can simply nest a ``patch()`` directive inside of ``depends_on``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1974
# 96006b86534846ae8c71f15393658b56
msgid "Note that there are two optional ``when`` conditions here -- one on the ``patch`` directive and the other on ``depends_on``.  The condition in the ``patch`` directive applies to ``binutils`` (the package being patched), while the condition in ``depends_on`` applies to ``special-tool``.  See `patch directive <patching_>`_ for details on all the arguments the ``patch`` directive can take."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1981
# 52a8ba0cf62b4cfeb83dfa9b21b57d2f
msgid "Finally, if you need *multiple* patches on a dependency, you can provide a list for ``patches``, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:1999
# f5861ba62ed6424d9b18d8e84c0bf42f
msgid "As with ``patch`` directives, patches are applied in the order they appear in the package file (or in this case, in the list)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2004
# 8e693734a35d43a2a90c2e3b2dd2c144
msgid "You may wonder whether dependency patching will interfere with other packages that depend on ``binutils``.  It won't."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2007
# 59066352f7b6401c9289241663997e6b
msgid "As described in patching_, Patching a package adds the ``sha256`` of the patch to the package's spec, which means it will have a *different* unique hash than other versions without the patch.  The patched version coexists with unpatched versions, and Spack's support for handling_rpaths_ guarantees that each installation finds the right version. If two packages depend on ``binutils`` patched *the same* way, they can both use a single installation of ``binutils``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2019
# 1abcba28e5bc4cb6b38b607857bc7d76
msgid "``setup_dependent_environment()``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2021
# 0e056e4ab027473c998d2730fb43a137
msgid "Spack provides a mechanism for dependencies to provide variables that can be used in their dependents' build.  Any package can declare a ``setup_dependent_environment()`` function, and this function will be called before the ``install()`` method of any dependent packages. This allows dependencies to set up environment variables and other properties to be used by dependents."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2028
# a933dac94987496192ca931c02cbdc81
msgid "The function declaration should look like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2034
# b4e91eac0a064ec7a3869fe2e758d2fb
msgid "Here, the Qt package sets the ``QTDIR`` environment variable so that packages that depend on a particular Qt installation will find it."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2037
# e51c0c0e19654bb6a76470c4e8953366
msgid "The arguments to this function are:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2039
# 52bc9739eadd4e25b4893723a544f128
msgid "**spack_env**: List of environment modifications to be applied when the dependent package is built within Spack."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2041
# af470a5aeaf74bdea6eb8beafed7fdf4
msgid "**run_env**: List of environment modifications to be applied when the dependent package is run outside of Spack. These are added to the resulting module file."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2044
# 62d8fb990d8a4a06aaed3ed21ecd95e2
msgid "**dependent_spec**: The spec of the dependent package about to be built. This allows the extendee (self) to query the dependent's state. Note that *this* package's spec is available as ``self.spec``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2048
# ca15312909a84a73ac78619da45cf747
msgid "A good example of using these is in the Python package:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2054
# 74c4cd3f008f4f5caeffc3e8a9281a04
msgid "The first thing that happens here is that the ``python`` command is inserted into module scope of the dependent.  This allows most python packages to have a very simple install method, like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2063
# 7e6d1663d9774142883983b9d130590f
msgid "Python's ``setup_dependent_environment`` method also sets up some other variables, creates a directory, and sets up the ``PYTHONPATH`` so that dependent packages can find their dependencies at build time."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2071
# e78952906e5b41c699db1561625e8fbb
msgid "Conflicts"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2073
# 30450b30769f4ee8a32bf50af2e08063
msgid "Sometimes packages have known bugs, or limitations, that would prevent them to build e.g. against other dependencies or with certain compilers. Spack makes it possible to express such constraints with the ``conflicts`` directive."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2077
# 3f21be0ac301415f9cf013343d07e098
msgid "Adding the following to a package:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2083
# 371a765ec3844f64aae02e0fadbfaa25
msgid "we express the fact that the current package *cannot be built* with the Intel compiler when we are trying to install version \"1.2\". The ``when`` argument can be omitted, in which case the conflict will always be active. Conflicts are always evaluated after the concretization step has been performed, and if any match is found a detailed error message is shown to the user."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2093
# 0accf5751ab34901abf84b55be53916b
msgid "Extensions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2095
# ae1f4ff464714c5a8735320155e6f07d
msgid "Spack's support for package extensions is documented extensively in :ref:`extensions`.  This section documents how to make your own extendable packages and extensions."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2099
# 0ed45c2cbd5f45b8aa5274e9a6f56aac
msgid "To support extensions, a package needs to set its ``extendable`` property to ``True``, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2109
# b18819e478c14d989e682200275130f7
msgid "To make a package into an extension, simply add simply add an ``extends`` call in the package definition, and pass it the name of an extendable package:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2120
# 92365ca0ff96496f8d2c9b5e8b16df8a
msgid "Now, the ``py-numpy`` package can be used as an argument to ``spack activate``.  When it is activated, all the files in its prefix will be symbolically linked into the prefix of the python package."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2124
# a8ca284a2b3842008d7d5b055fdff197
msgid "Some packages produce a Python extension, but are only compatible with Python 3, or with Python 2.  In those cases, a ``depends_on()`` declaration should be made in addition to the ``extends()`` declaration:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2135
# c8e558896f104758a6e146dc7ed3711d
msgid "Many packages produce Python extensions for *some* variants, but not others: they should extend ``python`` only if the appropriate variant(s) are selected.  This may be accomplished with conditional ``extends()`` declarations:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2148
# ea42376a0867484c93b5667b18458814
msgid "Sometimes, certain files in one package will conflict with those in another, which means they cannot both be activated (symlinked) at the same time.  In this case, you can tell Spack to ignore those files when it does the activation:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2162
# 2984cdd45a444f8abefe53e29bcc7d10
msgid "The code above will prevent everything in the ``$prefix/bin/`` directory from being linked in at activation time."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2167
# 5eab3d8943454c96923a50f9dfdf3138
msgid "You can call *either* ``depends_on`` or ``extends`` on any one package, but not both.  For example you cannot both ``depends_on('python')`` and ``extends(python)`` in the same package.  ``extends`` implies ``depends_on``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2174
# c12b6c0eede742fb86d5e238f39fbb6d
msgid "Views"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2176
# 2f82b42c73e0481cb013982edef0d32c
msgid "As covered in :ref:`filesystem-views`, the ``spack view`` command can be used to symlink a number of packages into a merged prefix. The methods of ``PackageViewMixin`` can be overridden to customize how packages are added to views. Generally this can be used to create copies of specific files rather than symlinking them when symlinking does not work. For example, ``Python`` overrides ``add_files_to_view`` in order to create a copy of the ``python`` binary since the real path of the Python executable is used to detect extensions; as a consequence python extension packages (those inheriting from ``PythonPackage``) likewise override ``add_files_to_view`` in order to rewrite shebang lines which point to the Python interpreter."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2189
# e30cb3de9f96497a9096d4e9ea0e1965
msgid "Activation & deactivation"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2191
# ffcfd5fc69bf428590ce2f61d054b66a
msgid "Adding an extension to a view is referred to as an activation. If the view is maintained in the Spack installation prefix of the extendee this is called a global activation. Activations may involve updating some centralized state that is maintained by the extendee package, so there can be additional work for adding extensions compared with non-extension packages."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2197
# 0083017100b04bb096d9a2b23a4587e3
msgid "Spack's ``Package`` class has default ``activate`` and ``deactivate`` implementations that handle symbolically linking extensions' prefixes into a specified view. Extendable packages can override these methods to add custom activate/deactivate logic of their own.  For example, the ``activate`` and ``deactivate`` methods in the Python class handle symbolic linking of extensions, but they also handle details surrounding Python's ``.pth`` files, and other aspects of Python packaging."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2205
# 6187552eb784470794b6a43a2c1267c0
msgid "Spack's extensions mechanism is designed to be extensible, so that other packages (like Ruby, R, Perl, etc.)  can provide their own custom extension management logic, as they may not handle modules the same way that Python does."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2210
# 5a7d353a6d4e4273a509c9b0d664187c
msgid "Let's look at Python's activate function:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2216
# d1f50c9761f84f5189ec8318c111b919
msgid "This function is called on the *extendee* (Python).  It first calls ``activate`` in the superclass, which handles symlinking the extension package's prefix into the specified view.  It then does some special handling of the ``easy-install.pth`` file, part of Python's setuptools."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2222
# f060a2b017f44179b2844efa525a059b
msgid "Deactivate behaves similarly to activate, but it unlinks files:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2228
# b1f887139c12466a8122981f93d769db
msgid "Both of these methods call some custom functions in the Python package.  See the source for Spack's Python package for details."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2233
# 54babb48489d4231b23aa07ec0328b22
msgid "Activation arguments"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2235
# 36737ab96f3045529807aab64113865d
msgid "You may have noticed that the ``activate`` function defined above takes keyword arguments.  These are the keyword arguments from ``extends()``, and they are passed to both activate and deactivate."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2239
# 87a0098d4398448ebe6f215e7356ec27
msgid "This capability allows an extension to customize its own activation by passing arguments to the extendee.  Extendees can likewise implement custom ``activate()`` and ``deactivate()`` functions to suit their needs."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2244
# bdea3e9b3a684d57be713fe70faa6483
msgid "The only keyword argument supported by default is the ``ignore`` argument, which can take a regex, list of regexes, or a predicate to determine which files *not* to symlink during activation."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2252
# 2cf8ca6cd40c460cbdb461141770d727
msgid "Virtual dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2254
# f7b4ac46b742464299cad7534f1a545d
msgid "In some cases, more than one package can satisfy another package's dependency.  One way this can happen is if a package depends on a particular *interface*, but there are multiple *implementations* of the interface, and the package could be built with any of them.  A *very* common interface in HPC is the `Message Passing Interface (MPI) <http://www.mcs.anl.gov/research/projects/mpi/>`_, which is used in many large-scale parallel applications."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2262
# b94a9dd85b1f40af88aa50ab4c35011d
msgid "MPI has several different implementations (e.g., `MPICH <http://www.mpich.org>`_, `OpenMPI <http://www.open-mpi.org>`_, and `MVAPICH <http://mvapich.cse.ohio-state.edu>`_) and scientific applications can be built with any one of them.  Complicating matters, MPI does not have a standardized ABI, so a package built with one implementation cannot simply be relinked with another implementation. Many package managers handle interfaces like this by requiring many similar package files, e.g., ``foo``, ``foo-mvapich``, ``foo-mpich``, but Spack avoids this explosion of package files by providing support for *virtual dependencies*."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2275
# b4821ed427ae496b88d9bc41ff630d81
msgid "``provides``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2277
# 28f075ac399f4d38a22ca1639e54833c
msgid "In Spack, ``mpi`` is handled as a *virtual package*.  A package like ``mpileaks`` can depend on it just like any other package, by supplying a ``depends_on`` call in the package definition.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2295
# 8adf2f832ee1482090339062fb36592b
msgid "Here, ``callpath`` and ``adept-utils`` are concrete packages, but there is no actual package file for ``mpi``, so we say it is a *virtual* package.  The syntax of ``depends_on``, is the same for both.  If we look inside the package file of an MPI implementation, say MPICH, we'll see something like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2307
# 7c379203ce234a1190f2c2b6ebcefa6f
msgid "The ``provides(\"mpi\")`` call tells Spack that the ``mpich`` package can be used to satisfy the dependency of any package that ``depends_on('mpi')``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2313
# ae9b2fb9a6f8440a8d650e5fe3c1ce0e
msgid "Versioned Interfaces"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2315
# 81c5c695f14642aa92f1661b1d34573d
msgid "Just as you can pass a spec to ``depends_on``, so can you pass a spec to ``provides`` to add constraints.  This allows Spack to support the notion of *versioned interfaces*.  The MPI standard has gone through many revisions, each with new functions added, and each revision of the standard has a version number.  Some packages may require a recent implementation that supports MPI-3 functions, but some MPI versions may only provide up to MPI-2.  Others may need MPI 2.1 or higher.  You can indicate this by adding a version constraint to the spec passed to ``provides``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2329
# 93f3d7fb5eb74510839b950c581cbf15
msgid "Suppose that the above ``provides`` call is in the ``mpich2`` package. This says that ``mpich2`` provides MPI support *up to* version 2, but if a package ``depends_on(\"mpi@3\")``, then Spack will *not* build that package with ``mpich2``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2336
# a19fb65e62584a18a79b97d1f3c7d7a9
msgid "``provides when``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2338
# 6379909fe6554ad2bedb45ac303899ef
msgid "The same package may provide different versions of an interface depending on *its* version.  Above, we simplified the ``provides`` call in ``mpich`` to make the explanation easier.  In reality, this is how ``mpich`` calls ``provides``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2348
# d626e37572064195afe052b1dac7fca3
msgid "The ``when`` argument to ``provides`` allows you to specify optional constraints on the *providing* package, or the *provider*.  The provider only provides the declared virtual spec when *it* matches the constraints in the when clause.  Here, when ``mpich`` is at version 3 or higher, it provides MPI up to version 3.  When ``mpich`` is at version 1 or higher, it provides the MPI virtual package at version 1."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2356
# 351eda9fa2c842dda0d5f70667b274de
msgid "The ``when`` qualifier ensures that Spack selects a suitably high version of ``mpich`` to satisfy some other package that ``depends_on`` a particular version of MPI.  It will also prevent a user from building with too low a version of ``mpich``.  For example, suppose the package ``foo`` declares this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2368
# eb033dbb9d76402a855fc7b18ec54896
msgid "Suppose a user invokes ``spack install`` like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2374
# 59c11e0896114f88b577ea255180065e
msgid "Spack will fail with a constraint violation, because the version of MPICH requested is too low for the ``mpi`` requirement in ``foo``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2381
# c3cecec30f5a4da5aa7fe30f4b115c42
msgid "Abstract & concrete specs"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2383
# 4bbd9e63fbbc4f3a97b89e5995bfb7c0
msgid "Now that we've seen how spec constraints can be specified :ref:`on the command line <sec-specs>` and within package definitions, we can talk about how Spack puts all of this information together.  When you run this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2392
# dad6e035814d4e0c94c88adb6c26f526
msgid "Spack parses the command line and builds a spec from the description. The spec says that ``mpileaks`` should be built with the ``callpath`` library at 1.0 and with the debug option enabled, and with ``libelf`` version 0.8.11.  Spack will also look at the ``depends_on`` calls in all of these packages, and it will build a spec from that.  The specs from the command line and the specs built from package descriptions are then combined, and the constraints are checked against each other to make sure they're satisfiable."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2401
# d4e0dbd4c6c844c084f4defc7df8e660
msgid "What we have after this is done is called an *abstract spec*.  An abstract spec is partially specified.  In other words, it could describe more than one build of a package.  Spack does this to make things easier on the user: they should only have to specify as much of the package spec as they care about.  Here's an example partial spec DAG, based on the constraints above:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2427
# c00c0d1351264b6481e3931a7e76239b
msgid "This diagram shows a spec DAG output as a tree, where successive levels of indentation represent a depends-on relationship.  In the above DAG, we can see some packages annotated with their constraints, and some packages with no annotations at all.  When there are no annotations, it means the user doesn't care what configuration of that package is built, just so long as it works."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2436
# e5ea9e0725084a18b1b18910ce1ef4a3
msgid "Concretization"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2438
# 1009cd6488f04c0d8dd04d3475db15cc
msgid "An abstract spec is useful for the user, but you can't install an abstract spec.  Spack has to take the abstract spec and \"fill in\" the remaining unspecified parts in order to install.  This process is called **concretization**.  Concretization happens in between the time the user runs ``spack install`` and the time the ``install()`` method is called.  The concretized version of the spec above might look like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2465
# 003acbb7cbe444d78558d26542b089d0
msgid "Here, all versions, compilers, and platforms are filled in, and there is a single version (no version ranges) for each package.  All decisions about configuration have been made, and only after this point will Spack call the ``install()`` method for your package."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2470
# f756a77bdcd448e880d466c3f3292538
msgid "Concretization in Spack is based on certain selection policies that tell Spack how to select, e.g., a version, when one is not specified explicitly.  Concretization policies are discussed in more detail in :ref:`configuration`.  Sites using Spack can customize them to match the preferences of their own users."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2480
# b903080738444b49bc6e4ef172e06704
msgid "``spack spec``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2482
# 10632a733c404425923bd656ae677f13
msgid "For an arbitrary spec, you can see the result of concretization by running ``spack spec``.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2496
# c4005444dce24b31b39f89bf3229099e
msgid "This is useful when you want to know exactly what Spack will do when you ask for a particular spec."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2503
# a8d695da3f124acd91cfaae50a647b15
msgid "``Concretization Policies``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2505
# a40bf1e2e55e44bcae3f370a08e38bf4
msgid "A user may have certain preferences for how packages should be concretized on their system.  For example, one user may prefer packages built with OpenMPI and the Intel compiler.  Another user may prefer packages be built with MVAPICH and GCC."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2510
# 977efffff47e4c9497a20924660470ff
msgid "See the :ref:`concretization-preferences` section for more details."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2516
# 7bcb20e875ec4d66894704e4ee17441a
msgid "Conflicting Specs"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2518
# 54be4fa3310a4262aedf7e1d21c1370f
msgid "Suppose a user needs to install package C, which depends on packages A and B.  Package A builds a library with a Python2 extension, and package B builds a library with a Python3 extension.  Packages A and B cannot be loaded together in the same Python runtime:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2539
# 5f55a6bbfa36496e9e230285a6a648a7
msgid "Package C needs to use the libraries from packages A and B, but does not need either of the Python extensions.  In this case, package C should simply depend on the ``~python`` variant of A and B:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2549
# 82ec4b5f92314c218e47ee9c47007d87
msgid "This may require that A or B be built twice, if the user wishes to use the Python extensions provided by them: once for ``+python`` and once for ``~python``.  Other than using a little extra disk space, that solution has no serious problems."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2558
# 024fbcee555c4ad9bc63b39946077a05
msgid "Implementing the installation procedure"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2560
# 5e1b0fc2cd3a438da2da324b1d2b3b70
msgid "The last element of a package is its **installation procedure**.  This is where the real work of installation happens, and it's the main part of the package you'll need to customize for each piece of software."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2564
# ac0c09918dbc46a68f929879a49e6553
msgid "Defining an installation procedure means overriding a set of methods or attributes that will be called at some point during the installation of the package. The package base class, usually specialized for a given build system, determines the actual set of entities available for overriding. The classes that are currently provided by Spack are:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2571
# 9dee6c18abb843d4aaa868ad3b3904d6
msgid "**Base Class**"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2571
# 7058d6896b2941d4a3d22678c7abe8c8
msgid "**Purpose**"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2573
# 6e776ff555e54d8dbed586e12d8e3ca8
msgid ":py:class:`.Package`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2573
# 9ee5f34fe5394ffc9fbbd00416854475
msgid "General base class not specialized for any build system"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2576
# 5a9606f4f67c40d4b3701b7c4b0b57ec
msgid ":py:class:`.MakefilePackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2576
# c49a189a96f146e68e9362dd9d7ae75d
msgid "Specialized class for packages built invoking hand-written Makefiles"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2580
# 73df0626eee3411db67c7d093c31db53
msgid ":py:class:`.AutotoolsPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2580
# 7c41d7856991414e8b5473f65e859cb8
msgid "Specialized class for packages built using GNU Autotools"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2583
# 82989d680e7e4f8d8c4c8f69d281cece
msgid ":py:class:`.CMakePackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2583
# e5cbc1d5f95e4412a127e554dc090a74
msgid "Specialized class for packages built using CMake"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2586
# ee79ba8d23924966a9484c5678a83566
msgid ":py:class:`.CudaPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2586
# 313b7f008a77488191ae49167d1fc951
msgid "A helper class for packages that use CUDA. It is intended to be used in combination with others"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2590
# d9874518361347a89361c4227aa7dddc
msgid ":py:class:`.QMakePackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2590
# 709cdd5e22094c779079e3ab49998288
msgid "Specialized class for packages build using QMake"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2593
# 2927ff9237d2492d888b3894cd5985cd
msgid ":py:class:`.SConsPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2593
# c590233ca12c4b3f985a268a14a533a4
msgid "Specialized class for packages built using SCons"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2596
# caf2c42435964d59bd8b9984c45a3f38
msgid ":py:class:`.WafPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2596
# 40df64b7048843d2937f750d4e820ae7
msgid "Specialized class for packages built using Waf"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2599
# 3405a5c7adaa4538a94a9966d6406399
msgid ":py:class:`.RPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2599
# 57139dc1fabd4256879201adedee090b
msgid "Specialized class for :py:class:`.R` extensions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2602
# 6f07bc2353ac4e7f9e6e13dd2614ca76
msgid ":py:class:`.OctavePackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2602
# d51ebc4da38645b8a198db7d3ba30296
msgid "Specialized class for :py:class:`.Octave` packages"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2605
# 4658d7b5d1f04b9c9ca975df678f598e
msgid ":py:class:`.PythonPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2605
# 95c6b50ea7b94a94a2c3993e23304666
msgid "Specialized class for :py:class:`.Python` extensions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2608
# 15b4a9973c034c9ab6bdf529c04539f3
msgid ":py:class:`.PerlPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2608
# d5a9efc35d4f4cee83250e6e482d1ec6
msgid "Specialized class for :py:class:`.Perl` extensions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2611
# 29892921442c43d8bfd5abeefbd9942d
msgid ":py:class:`.IntelPackage`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2611
# e109115522c84993bf247b8ec2fdd592
msgid "Specialized class for licensed Intel software"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2622
# 90266f8737fd48558e5086d3bcb90d27
msgid "Choice of the appropriate base class for a package"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2618
# a38a10df74e84244b99339210d18d9ee
msgid "In most cases packagers don't have to worry about the selection of the right base class for a package, as ``spack create`` will make the appropriate choice on their behalf. In those rare cases where manual intervention is needed we need to stress that a package base class depends on the *build system* being used, not the language of the package. For example, a Python extension installed with CMake would ``extends('python')`` and subclass from :py:class:`.CMakePackage`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2627
# 38dc6f96db9b4b4cb95e1218dfff0f25
msgid "Installation pipeline"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2629
# 32c163b951334e3cb681aadeafd0f11a
msgid "When a user runs ``spack install``, Spack:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2631
# 6c27de03cdb64f7ca16079506567e572
msgid "Fetches an archive for the correct version of the software."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2632
# ad7cdf7d8854440f8ee555bcb89b88c3
msgid "Expands the archive."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2633
# 552f25ab41434bb38aa572dd00863398
msgid "Sets the current working directory to the root directory of the expanded archive."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2635
# b87de44fbc894afc8f0eb099014ff21d
msgid "Then, depending on the base class of the package under consideration, it will execute a certain number of **phases** that reflect the way a package of that type is usually built. The name and order in which the phases will be executed can be obtained either reading the API docs at :py:mod:`~.spack.build_systems`, or using the ``spack info`` command:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2664
# d33fbdba6e2a4665b646618be1fcc7d9
msgid "Typically, phases have default implementations that fit most of the common cases:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2670
# eb7e6456a2d04b3f9198990846b4180a
msgid "It is thus just sufficient for a packager to override a few build system specific helper methods or attributes to provide, for instance, configure arguments:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2679
# 76cf2501d83041e0ad9734fd8352d166
msgid "Each specific build system has a list of attributes that can be overridden to fine-tune the installation of a package without overriding an entire phase. To have more information on them the place to go is the API docs of the :py:mod:`~.spack.build_systems` module."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2686
# 8dd851d808cf48af94776919293e05fb
msgid "Overriding an entire phase"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2688
# 9cd67849498742fe9b835347fb109411
msgid "In extreme cases it may be necessary to override an entire phase. Regardless of the build system, the signature is the same. For example, the signature for the install phase is:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2702
# be00e75d9d1d4d46ba720a453e5894e8
msgid "``self``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2699
# 5a42ed787a9d413bb5e426c2b15b23c3
msgid "For those not used to Python instance methods, this is the package itself.  In this case it's an instance of ``Foo``, which extends ``Package``.  For API docs on Package objects, see :py:class:`Package <spack.package.Package>`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2707
# 8dcfcf46b8cb4f6d8ffbe042e37e0d15
msgid "``spec``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2705
# 8f857cd0f19b4569aeacac9805ff0ab5
msgid "This is the concrete spec object created by Spack from an abstract spec supplied by the user.  It describes what should be installed.  It will be of type :py:class:`Spec <spack.spec.Spec>`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2712
# f5582f4cd05b43388e7a980fa5d80073
msgid "``prefix``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2710
# 37aa9d087bd34f06ae57c7d10401ea99
msgid "This is the path that your install method should copy build targets into.  It acts like a string, but it's actually its own special type, :py:class:`Prefix <spack.util.prefix.Prefix>`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2714
# df811bd8c19d4b8696e976c64fc68084
msgid "The arguments ``spec`` and ``prefix`` are passed only for convenience, as they always correspond to ``self.spec`` and ``self.spec.prefix`` respectively."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2717
# 574e7ce61e9f4c56a716be833f9413b1
msgid "As mentioned in :ref:`install-environment`, you will usually not need to refer to dependencies explicitly in your package file, as the compiler wrappers take care of most of the heavy lifting here.  There will be times, though, when you need to refer to the install locations of dependencies, or when you need to do something different depending on the version, compiler, dependencies, etc. that your package is built with.  These parameters give you access to this type of information."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2728
# ec8914ea21814ad2a229e486e38badb0
msgid "The build environment"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2730
# a2c5c489395643338fea40f1c46cb0da
msgid "In general, you should not have to do much differently in your install method than you would when installing a package on the command line. In fact, you may need to do *less* than you would on the command line."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2734
# ce233349ad4c422aabb73b791910bb1f
msgid "Spack tries to set environment variables and modify compiler calls so that it *appears* to the build system that you're building with a standard system install of everything.  Obviously that's not going to cover *all* build systems, but it should make it easy to port packages to Spack if they use a standard build system.  Usually with autotools or cmake, building and installing is easy.  With builds that use custom Makefiles, you may need to add logic to modify the makefiles."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2742
# aed9be8ca9444177ac1d7bbb996c8880
msgid "The remainder of the section covers the way Spack's build environment works."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2747
# 5018da7b5c704e9598e7c923c9c62c19
msgid "Forking ``install()``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2749
# 766336e187cf4b6ca7c938b1a7ab2748
msgid "To give packagers free reign over their install environment, Spack forks a new process each time it invokes a package's ``install()`` method. This allows packages to have a sandboxed build environment, without impacting the environments ofother jobs that the main Spack process runs. Packages are free to change the environment or to modify Spack internals, because each ``install()`` call has its own dedicated process."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2758
# b9fc865ffacd4d51aea5212e798f4024
msgid "Environment variables"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2760
# 4b2a4307862f4bf4aa04c071ec3fe709
msgid "Spack sets a number of standard environment variables that serve two purposes:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2763
# 2aff7b75ca664726aae0ce08c8263dfb
msgid "Make build systems use Spack's compiler wrappers for their builds."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2764
# 61a4a579b5f445f5b39c4920067e8c08
msgid "Allow build systems to find dependencies more easily"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2766
# 36f2e956485c426e8a2f5584e38ffe77
msgid "The Compiler environment variables that Spack sets are:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2769
# 0335aead380e475e8d50230a07a4e7c3
msgid "Variable"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2769
# 1267eeb04c264cac88e988fe2de7f43a
msgid "Purpose"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2771
# ac6ef87bb470450ca5b8dd7149304fb7
msgid "``CC``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2771
# b0c15cef24b64e689c3a75cea08a6b56
msgid "C compiler"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2772
# 8cb2400f20394e3ca9ee0f454ac09413
msgid "``CXX``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2772
# 32fb917e069242828d6582e7f708d211
msgid "C++ compiler"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2773
# 0ae1eb95a32d4fc6a011e70113a5634e
msgid "``F77``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2773
# d7597c37b8804492bb0688a5fddc999e
msgid "Fortran 77 compiler"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2774
# 0359fc5edb2f4963a8d1e2544161149e
msgid "``FC``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2774
# 9aeed559bc234ada83881130e6dbadb5
msgid "Fortran 90 and above compiler"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2777
# a4c2eb0c3c8143218da0d16293a30d93
msgid "Spack sets these variables so that they point to *compiler wrappers*. These are covered in :ref:`their own section <compiler-wrappers>` below."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2781
# 5646dc6b58ef4e5984da44865a668d34
msgid "All of these are standard variables respected by most build systems. If your project uses ``Autotools`` or ``CMake``, then it should pick them up automatically when you run ``configure`` or ``cmake`` in the ``install()`` function.  Many traditional builds using GNU Make and BSD make also respect these variables, so they may work with these systems."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2788
# af56098b27a44f3bbbef42d62751eb53
msgid "If your build system does *not* automatically pick these variables up from the environment, then you can simply pass them on the command line or use a patch as part of your build process to get the correct compilers into the project's build system.  There are also some file editing commands you can use -- these are described later in the `section on file manipulation <file-manipulation_>`_."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2795
# 374c339b798846bcb1f9db3ff2859e0c
msgid "In addition to the compiler variables, these variables are set before entering ``install()`` so that packages can locate dependencies easily:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2800
# fb2b93a543e94ab596875a0cbef583ef
msgid "``PATH``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2800
# e6f628dcfd414403b5f7c896cb55bc8b
msgid "Set to point to ``/bin`` directories of dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2801
# 1c017888104a4b159bdf6af967a142b9
msgid "``CMAKE_PREFIX_PATH``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2801
# 8c9f29d46afe4f409c2e5a1656326176
msgid "Path to dependency prefixes for CMake"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2802
# 747ec776e74c483087856cd5087bd0b2
msgid "``PKG_CONFIG_PATH``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2802
# 8cf051021bc94519b2367d4abe7e9483
msgid "Path to any pkgconfig directories for dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2803
# 935040390792441a8663733e55491c3b
msgid "``PYTHONPATH``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2803
# 69f8c53292524fec9126bb5bb3b3b695
msgid "Path to site-packages dir of any python dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2806
# e70a7a6aa1c841278fa23010fc391a53
msgid "``PATH`` is set up to point to dependencies ``/bin`` directories so that you can use tools installed by dependency packages at build time. For example, ``$MPICH_ROOT/bin/mpicc`` is frequently used by dependencies of ``mpich``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2811
# 39e10138c93247349c6dd333a30911d7
msgid "``CMAKE_PREFIX_PATH`` contains a colon-separated list of prefixes where ``cmake`` will search for dependency libraries and headers. This causes all standard CMake find commands to look in the paths of your dependencies, so you *do not* have to manually specify arguments like ``-DDEPENDENCY_DIR=/path/to/dependency`` to ``cmake``.  More on this is `in the CMake documentation <http://www.cmake.org/cmake/help/v3.0/variable/CMAKE_PREFIX_PATH.html>`_."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2818
# 88b82549e5c8403083a21e7611378a3b
msgid "``PKG_CONFIG_PATH`` is for packages that attempt to discover dependencies using the GNU ``pkg-config`` tool.  It is similar to ``CMAKE_PREFIX_PATH`` in that it allows a build to automatically discover its dependencies."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2823
# 2508a4248cd548f8b0cbc6bde796ef51
msgid "If you want to see the environment that a package will build with, or if you want to run commands in that environment to test them out, you can use the :ref:`cmd-spack-env` command, documented below."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2830
# 83386b93c7994fe8854539818159abb1
msgid "Failing the build"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2832
# ac211ccefa3b4bada844b460ac7f5fb8
msgid "Sometimes you don't want a package to successfully install unless some condition is true.  You can explicitly cause the build to fail from ``install()`` by raising an ``InstallError``, for example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2845
# c64c4f7b85994decb0eac484a15516da
msgid "Shell command functions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2847
# 7dd848d6be3a4314ada2effdff2ae820
msgid "Recall the install method from ``libelf``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2853
# 8aba1ee65c1f4d08903a6cbfe9182fe0
msgid "Normally in Python, you'd have to write something like this in order to execute shell commands:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2861
# ab59b5179f8c4f6382b24444d80fc89c
msgid "We've tried to make this a bit easier by providing callable wrapper objects for some shell commands.  By default, ``configure``, ``cmake``, and ``make`` wrappers are are provided, so you can call them more naturally in your package files."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2866
# 59c953f602a44c39b3f0d6f53d32873c
msgid "If you need other commands, you can use ``which`` to get them:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2873
# bfe3fd0781a74bd09a619d7581a7b575
msgid "The ``which`` function will search the ``PATH`` for the application."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2875
# 71e45a9689a944ea989e76572649601b
msgid "Callable wrappers also allow spack to provide some special features. For example, in Spack, ``make`` is parallel by default, and Spack figures out the number of cores on your machine and passes an appropriate value for ``-j<numjobs>`` when it calls ``make`` (see the ``parallel`` `package attribute <attribute_parallel>`).  In a package file, you can supply a keyword argument, ``parallel=False``, to the ``make`` wrapper to disable parallel make.  In the ``libelf`` package, this allows us to avoid race conditions in the library's build system."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2887
# ea0c83017ae243849874f40ab3aa2262
msgid "Compiler flags"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2889
# befe4f444ec7493d945c4dbf7f607974
msgid "Compiler flags set by the user through the Spec object can be passed to the build in one of three ways. By default, the build environment injects these flags directly into the compiler commands using Spack's compiler wrappers. In cases where the build system requires knowledge of the compiler flags, they can be registered with the build system by alternatively passing them through environment variables or as build system arguments. The flag_handler method can be used to change this behavior."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2898
# 3d93cd5a18ee42939edb134c6ed8423e
msgid "Packages can override the flag_handler method with one of three built-in flag_handlers. The built-in flag_handlers are named ``inject_flags``, ``env_flags``, and ``build_system_flags``. The ``inject_flags`` method is the default. The ``env_flags`` method puts all of the flags into the environment variables that ``make`` uses as implicit variables ('CFLAGS', 'CXXFLAGS', etc.). The ``build_system_flags`` method adds the flags as arguments to the invocation of ``configure`` or ``cmake``, respectively."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2910
# da675ad04286448eae6671d7889a1a27
msgid "Passing compiler flags using build system arguments is only supported for CMake and Autotools packages. Individual packages may also differ in whether they properly respect these arguments."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2914
# eadd7c3887c7450ab9942ef883fa459a
msgid "Individual packages may also define their own ``flag_handler`` methods. The ``flag_handler`` method takes the package instance (``self``), the name of the flag, and a list of the values of the flag. It will be called on each of the six compiler flags supported in Spack. It should return a triple of ``(injf, envf, bsf)`` where ``injf`` is a list of flags to inject via the Spack compiler wrappers, ``envf`` is a list of flags to set in the appropriate environment variables, and ``bsf`` is a list of flags to pass to the build system as arguments."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2926
# e10e28b02f414925863a7905f29eb4dd
msgid "Passing a non-empty list of flags to ``bsf`` for a build system that does not support build system arguments will result in an error."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2930
# 1a115c6adf1146498197bc5860ceccc8
msgid "Here are the definitions of the three built-in flag handlers:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2945
# 8719504e24904c9aac3fac62514b2bfd
msgid "Returning ``[]`` and ``None`` are equivalent in a ``flag_handler`` method."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2948
# 231bdc9dfe38438a827a2551f3de2eba
msgid "Packages can override the default behavior either by specifying one of the built-in flag handlers,"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2955
# 284389c6555e444db9fcb515aec48687
msgid "or by implementing the flag_handler method. Suppose for a package ``Foo`` we need to pass ``cflags``, ``cxxflags``, and ``cppflags`` through the environment, the rest of the flags through compiler wrapper injection, and we need to add ``-lbar`` to ``ldlibs``. The following flag handler method accomplishes that."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2970
# a0f4b69a38ca453bbac8da2545ef5276
msgid "Because these methods can pass values through environment variables, it is important not to override these variables unnecessarily (E.g. setting ``env['CFLAGS']``) in other package methods when using non-default flag handlers. In the ``setup_environment`` and ``setup_dependent_environment`` methods, use the ``append_flags`` method of the ``EnvironmentModifications`` class to append values to a list of flags whenever the flag handler is ``env_flags``. If the package passes flags through the environment or the build system manually (in the install method, for example), we recommend using the default flag handler, or removing manual references and implementing a custom flag handler method that adds the desired flags to export as environment variables or pass to the build system. Manual flag passing is likely to interfere with the ``env_flags`` and ``build_system_flags`` methods."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:2985
# f1cf9091d5da47268ab5ad4f02b6815a
msgid "In rare circumstances such as compiling and running small unit tests, a package developer may need to know what are the appropriate compiler flags to enable features like ``OpenMP``, ``c++11``, ``c++14`` and alike. To that end the compiler classes in ``spack`` implement the following **properties**: ``openmp_flag``, ``cxx98_flag``, ``cxx11_flag``, ``cxx14_flag``, and ``cxx17_flag``, which can be accessed in a package by ``self.compiler.cxx11_flag`` and alike. Note that the implementation is such that if a given compiler version does not support this feature, an error will be produced. Therefore package developers can also use these properties to assert that a compiler supports the requested feature. This is handy when a package supports additional variants like"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3005
# 6edcc4e1f0bd4ef9ae5d223b3097d1f8
msgid "Blas, Lapack and ScaLapack libraries"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3007
# 00d2f63b1199418c835d0be7d44c308a
msgid "Multiple packages provide implementations of ``Blas``, ``Lapack`` and ``ScaLapack`` routines.  The names of the resulting static and/or shared libraries differ from package to package. In order to make the ``install()`` method independent of the choice of ``Blas`` implementation, each package which provides it implements ``@property def blas_libs(self):`` to return an object of `LibraryList <http://spack.readthedocs.io/en/latest/llnl.util.html#llnl.util.filesystem.LibraryList>`_ type which simplifies usage of a set of libraries. The same applies to packages which provide ``Lapack`` and ``ScaLapack``. Package developers are requested to use this interface. Common usage cases are:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3018
# 9a4e3526c609450f934cf81d451f1a5f
msgid "Space separated list of full paths"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3027
# cf17209daf8c450cb6b9076348e9cd3f
msgid "Names of libraries and directories which contain them"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3037
# d5085bacf00846d1b153b0d126c488b0
msgid "Search and link flags"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3047
# 3f294afc301d47cd8340b8117741f8e6
msgid "For more information, see documentation of `LibraryList <http://spack.readthedocs.io/en/latest/llnl.util.html#llnl.util.filesystem.LibraryList>`_ class."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3056
# bbf898f2c56147a89bc8674244c6d0c6
msgid "Prefix objects"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3058
# 2c15d22058284110a3ee68d1e160b43e
msgid "Spack passes the ``prefix`` parameter to the install method so that you can pass it to ``configure``, ``cmake``, or some other installer, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3066
# 4ae063aea48c45eb826e2d70a76e53e4
msgid "For the most part, prefix objects behave exactly like strings.  For packages that do not have their own install target, or for those that implement it poorly (like ``libdwarf``), you may need to manually copy things into particular directories under the prefix.  For this, you can refer to standard subdirectories without having to construct paths yourself, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3086
# 1c878c18a0fe490db7b44ab700819198
msgid "Attributes of this object are created on the fly when you request them, so any of the following will work:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3090
# 8735698a545349fb9668e24ec7785417
msgid "Prefix Attribute"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3090
# bba332fdcbb34301b4810a4342510626
msgid "Location"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3092
# 4030e989eb9d4f67a8abed8a964ff6a4
msgid "``prefix.bin``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3092
# e5320d661547415fa294e6f911e97938
msgid "``$prefix/bin``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3093
# 60c9a84a47994ba19eea704ced885e60
msgid "``prefix.lib64``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3093
# 75bd98192b3049a2b775e27ed2e548df
msgid "``$prefix/lib64``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3094
# 9770d2f2c4484525af86461a22c69ec3
msgid "``prefix.share.man``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3094
# f41d1006b144496497eadc45bbfe43de
msgid "``$prefix/share/man``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3095
# f8dcefbf9d20450ba730c0fac61ff948
msgid "``prefix.foo.bar.baz``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3095
# 4e18ab10bd2b489fb151c9048fe55db3
msgid "``$prefix/foo/bar/baz``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3098
# f1bf90e85f47407fb2bbfbaed2145920
msgid "Of course, this only works if your file or directory is a valid Python variable name. If your file or directory contains dashes or dots, use ``join`` instead:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3111
# f593d18d0a4e47a8a37cf82ec260ad78
msgid "Spec objects"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3113
# d3ba46d2bb8040a9a447cd1275962ada
msgid "When ``install`` is called, most parts of the build process are set up for you.  The correct version's tarball has been downloaded and expanded.  Environment variables like ``CC`` and ``CXX`` are set to point to the correct compiler and version.  An install prefix has already been selected and passed in as ``prefix``.  In most cases this is all you need to get ``configure``, ``cmake``, or another install working correctly."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3121
# 0c79730fa073423f92f5e53353ceaa53
msgid "There will be times when you need to know more about the build configuration.  For example, some software requires that you pass special parameters to ``configure``, like ``--with-libelf=/path/to/libelf`` or ``--with-mpich``.  You might also need to supply special compiler flags depending on the compiler.  All of this information is available in the spec."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3130
# a8a605a3921540658f4e11d62e477924
msgid "Testing spec constraints"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3132
# ef852ee5521e4affae652a52498fa30c
msgid "You can test whether your spec is configured a certain way by using the ``satisfies`` method.  For example, if you want to check whether the package's version is in a particular range, you can use specs to do that, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3148
# 6529030075c946f8a5d3903b9fef9f9a
msgid "This works for compilers, too:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3157
# 9a7afeb0e60a4541bc24c51e47553a36
msgid "Or for combinations of spec constraints:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3164
# 337672a9558343dbb55d6c8eaeff2957
msgid "You can also do similar satisfaction tests for dependencies:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3171
# 1373342608ac446593192e4ce596d044
msgid "This could allow you to easily work around a bug in a particular dependency version."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3174
# 9af18266e425411c85b80945c622e79e
msgid "You can use ``satisfies()`` to test for particular dependencies, e.g. ``foo.satisfies('^openmpi@1.2')`` or ``foo.satisfies('^mpich')``, or you can use Python's built-in ``in`` operator:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3183
# bd0f065ef6f248c1a112c9a450e70163
msgid "This is useful for virtual dependencies, as you can easily see what implementation was selected for this build:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3195
# 873e4454bd25423c987ebb9156372097
msgid "It's also a bit more concise than satisfies.  The difference between the two functions is that ``satisfies()`` tests whether spec constraints overlap at all, while ``in`` tests whether a spec or any of its dependencies satisfy the provided spec."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3202
# 9e2eeae6b56b4137aa1d87940a5a2955
msgid "Accessing Dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3204
# 822f886cf1a54462bb544434eb573a0e
msgid "You may need to get at some file or binary that's in the installation prefix of one of your dependencies. You can do that by sub-scripting the spec:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3212
# f0618a14fe404d0d962e19a00a071cce
msgid "The value in the brackets needs to be some package name, and spec needs to depend on that package, or the operation will fail.  For example, the above code will fail if the ``spec`` doesn't depend on ``mpi``.  The value returned is itself just another ``Spec`` object, so you can do all the same things you would do with the package's own spec:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3228
# 44dce07210d14393bf27c21795317da0
msgid "Multimethods and ``@when``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3230
# 66ddd29dc18f457ba5af3d52ac2b482c
msgid "Spack allows you to make multiple versions of instance functions in packages, based on whether the package's spec satisfies particular criteria."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3234
# 4f461b2f877440eb87ff9a99a8b5dcd6
msgid "The ``@when`` annotation lets packages declare multiple versions of methods like ``install()`` that depend on the package's spec.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3256
# 73ff6b342d6a49b69e83f72c0c5d8798
msgid "In the above code there are three versions of ``install()``, two of which are specialized for particular platforms.  The version that is called depends on the architecture of the package spec."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3260
# f5b803e133f54abf860eec7f2f40eef3
msgid "Note that this works for methods other than install, as well.  So, if you only have part of the install that is platform specific, you could do something more like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3286
# 34eb2314b1214fdbbc1a5a659dc58393
msgid "You can write multiple ``@when`` specs that satisfy the package's spec, for example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3314
# 1d48ede974564b2684bd90a864cac96a
msgid "In situations like this, the first matching spec, in declaration order will be called.  As before, if no ``@when`` spec matches, the default method (the one without the ``@when`` decorator) will be called."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3320
# f68d8e6f44924bee85d00e73a8803ddd
msgid "The default version of decorated methods must **always** come first.  Otherwise it will override all of the platform-specific versions.  There's not much we can do to get around this because of the way decorators work."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3329
# b32c2d8e55584d5ba0f8955d2f00ec7e
msgid "Compiler wrappers"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3331
# 5adc60bf370f416eb0c1e0ea52febffd
msgid "As mentioned, ``CC``, ``CXX``, ``F77``, and ``FC`` are set to point to Spack's compiler wrappers.  These are simply called ``cc``, ``c++``, ``f77``, and ``f90``, and they live in ``$SPACK_ROOT/lib/spack/env``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3335
# 183bb9ad189f4715b976399feeb8d0d2
msgid "``$SPACK_ROOT/lib/spack/env`` is added first in the ``PATH`` environment variable when ``install()`` runs so that system compilers are not picked up instead."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3339
# e505f66449f746acbbfc480354dad42d
msgid "All of these compiler wrappers point to a single compiler wrapper script that figures out which *real* compiler it should be building with.  This comes either from spec `concretization <abstract-and-concrete>`_ or from a user explicitly asking for a particular compiler using, e.g., ``%intel`` on the command line."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3345
# 5597bf0871d24ceaa5a5512c733bfc6e
msgid "In addition to invoking the right compiler, the compiler wrappers add flags to the compile line so that dependencies can be easily found. These flags are added for each dependency, if they exist:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3349
# 982fde9d39df46dc9f05e4ca6acb5375
msgid "Compile-time library search paths * ``-L$dep_prefix/lib`` * ``-L$dep_prefix/lib64``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3353
# 42ca9f0fa3ec47cca2d61d918cdc7431
msgid "Runtime library search paths (RPATHs) * ``$rpath_flag$dep_prefix/lib`` * ``$rpath_flag$dep_prefix/lib64``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3357
# f6acf309edad4f1a8668333bb3eeb4a5
msgid "Include search paths * ``-I$dep_prefix/include``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3360
# 1d0f0717512f467e9c4f92082d553ec4
msgid "An example of this would be the ``libdwarf`` build, which has one dependency: ``libelf``.  Every call to ``cc`` in the ``libdwarf`` build will have ``-I$LIBELF_PREFIX/include``, ``-L$LIBELF_PREFIX/lib``, and ``$rpath_flag$LIBELF_PREFIX/lib`` inserted on the command line.  This is done transparently to the project's build system, which will just think it's using a system where ``libelf`` is readily available.  Because of this, you **do not** have to insert extra ``-I``, ``-L``, etc. on the command line."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3369
# bc1bb1ebc7774a33a73191c5878a3cfd
msgid "Another useful consequence of this is that you often do *not* have to add extra parameters on the ``configure`` line to get autotools to find dependencies.  The ``libdwarf`` install method just calls configure like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3378
# 595824c8c68b4af2bd922bcdf12a2f53
msgid "Because of the ``-L`` and ``-I`` arguments, configure will successfully find ``libdwarf.h`` and ``libdwarf.so``, without the packager having to provide ``--with-libdwarf=/path/to/libdwarf`` on the command line."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3385
# c2e47591436a4bd28b59cc1d4b254bfb
msgid "For most compilers, ``$rpath_flag`` is ``-Wl,-rpath,``. However, NAG passes its flags to GCC instead of passing them directly to the linker. Therefore, its ``$rpath_flag`` is doubly wrapped: ``-Wl,-Wl,,-rpath,``. ``$rpath_flag`` can be overriden on a compiler specific basis in ``lib/spack/spack/compilers/$compiler.py``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3391
# 3babf3e9e0d1446fb261970ff69a1ca4
msgid "The compiler wrappers also pass the compiler flags specified by the user from the command line (``cflags``, ``cxxflags``, ``fflags``, ``cppflags``, ``ldflags``, and/or ``ldlibs``). They do not override the canonical autotools flags with the same names (but in ALL-CAPS) that may be passed into the build by particularly challenging package scripts."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3399
# e76fa96283ca41069e00156aabfacfe8
msgid "MPI support in Spack"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3401
# 954821111a8c477f888c19d1b233ad69
msgid "It is common for high performance computing software/packages to use the Message Passing Interface ( ``MPI``).  As a result of conretization, a given package can be built using different implementations of MPI such as ``Openmpi``, ``MPICH`` or ``IntelMPI``.  That is, when your package declares that it ``depends_on('mpi')``, it can be built with any of these ``mpi`` implementations. In some scenarios, to configure a package, one has to provide it with appropriate MPI compiler wrappers such as ``mpicc``, ``mpic++``.  However different implementations of ``MPI`` may have different names for those wrappers."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3411
# 547da7d0bd434350b05379f884ecb2f6
msgid "Spack provides an idiomatic way to use MPI compilers in your package.  To use MPI wrappers to compile your whole build, do this in your ``install()`` method:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3422
# 48542d8461db4c549993c7571a9f9ec1
msgid "That's all.  A longer explanation of why this works is below."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3424
# e0390a8a947d4a53aa0d2e292b9b2c76
msgid "We don't try to force any particular build method on packagers.  The decision to use MPI wrappers depends on the way the package is written, on common practice, and on \"what works\".  Loosely, There are three types of MPI builds:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3429
# c6bd2c5f9f0b4ecab65e268887be3cd9
msgid "Some build systems work well without the wrappers and can treat MPI as an external library, where the person doing the build has to supply includes/libs/etc.  This is fairly uncommon."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3433
# 022a562a36a04de69f3882728a9a805a
msgid "Others really want the wrappers and assume you're using an MPI \"compiler\" – i.e., they have no mechanism to add MPI includes/libraries/etc."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3437
# a5dfd556cb254e608f892cd5eed1797a
msgid "CMake's ``FindMPI`` needs the compiler wrappers, but it uses them to extract ``–I`` / ``-L`` / ``-D`` arguments, then treats MPI like a regular library."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3441
# 31e1904da49b4789a3b9dd06df5e813f
msgid "Note that some CMake builds fall into case 2 because they either don't know about or don't like CMake's ``FindMPI`` support – they just assume an MPI compiler. Also, some autotools builds fall into case 3 (e.g. `here is an autotools version of CMake's FindMPI <https://github.com/tgamblin/libra/blob/master/m4/lx_find_mpi.m4>`_)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3447
# 6ce0dc42891649a7b36180e3bcf42108
msgid "Given all of this, we leave the use of the wrappers up to the packager. Spack will support all three ways of building MPI packages."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3452
# f5ef13f15b1341c5a928cb3e0ce1557e
msgid "Packaging Conventions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3454
# 8969b25214e54822a42157eb3d35603c
msgid "As mentioned above, in the ``install()`` method, ``CC``, ``CXX``, ``F77``, and ``FC`` point to Spack's wrappers around the chosen compiler. Spack's wrappers are not the MPI compiler wrappers, though they do automatically add ``–I``, ``–L``, and ``–Wl,-rpath`` args for dependencies in a similar way.  The MPI wrappers are a bit different in that they also add ``-l`` arguments for the MPI libraries, and some add special ``-D`` arguments to trigger build options in MPI programs."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3462
# 0543cb6f87f949a8b7349bdb3eb74247
msgid "For case 1 above, you generally don't need to do more than patch your Makefile or add configure args as you normally would."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3465
# 931b7971cae24cbbba35433e0f0e10f3
msgid "For case 3, you don't need to do much of anything, as Spack puts the MPI compiler wrappers in the PATH, and the build will find them and interrogate them."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3469
# 8884281d85b74c39a5387218db7d199e
msgid "For case 2, things are a bit more complicated, as you'll need to tell the build to use the MPI compiler wrappers instead of Spack's compiler wrappers.  All it takes some lines like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3480
# 58ec219bf18545d9afa465d03dd78a4f
msgid "Or, if you pass CC, CXX, etc. directly to your build with, e.g., `--with-cc=<path>`, you'll want to substitute `spec['mpi'].mpicc` in there instead, e.g.:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3489
# 17ec551ad6cd4bd68133539a8328ff16
msgid "Now, you may think that doing this will lose the includes, library paths, and RPATHs that Spack's compiler wrapper get you, but we've actually set things up so that the MPI compiler wrappers use Spack's compiler wrappers when run from within Spack. So using the MPI wrappers should really be as simple as the code above."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3497
# 8e9108a1794144b7a3ef5af759851f4a
msgid "``spec['mpi']``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3499
# d5163243668b4669a4328739dd221227
msgid "Ok, so how does all this work?"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3501
# 070bb4244951488eb38c53e939de2d34
msgid "If your package has a virtual dependency like ``mpi``, then referring to ``spec['mpi']`` within ``install()`` will get you the concrete ``mpi`` implementation in your dependency DAG.  That is a spec object just like the one passed to install, only the MPI implementations all set some additional properties on it to help you out.  E.g., in mvapich2, you'll find this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3511
# e232edb7555842efbf0f304ff0e013a6
msgid "That code allows the mvapich2 package to associate an ``mpicc`` property with the ``mvapich2`` node in the DAG, so that dependents can access it. ``openmpi`` and ``mpich`` do similar things.  So, no matter what MPI you're using, spec['mpi'].mpicc gets you the location of the MPI compilers. This allows us to have a fairly simple polymorphic interface for information about virtual dependencies like MPI."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3520
# 95798a1f842d469a900c4b87d4f24db8
msgid "Wrapping wrappers"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3522
# c41621e86496400db0e755aecdbc7726
msgid "Spack likes to use its own compiler wrappers to make it easy to add ``RPATHs`` to builds, and to try hard to ensure that your builds use the right dependencies.  This doesn't play nicely by default with MPI, so we have to do a couple tricks."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3527
# f53b1b59e3e54577ad27c4917a6480ad
msgid "If we build MPI with Spack's wrappers, mpicc and friends will be installed with hard-coded paths to Spack's wrappers, and using them from outside of Spack will fail because they only work within Spack. To fix this, we patch mpicc and friends to use the regular compilers.  Look at the filter_compilers method in mpich, openmpi, or mvapich2 for details."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3534
# 828bbf23d3ed41c38ac5a12906d62942
msgid "We still want to use the Spack compiler wrappers when Spack is calling mpicc. Luckily, wrappers in all mainstream MPI implementations provide environment variables that allow us to dynamically set the compiler to be used by mpicc, mpicxx, etc. Denis pasted some code from this below – Spack's build environment sets ``MPICC``, ``MPICXX``, etc. for mpich derivatives and ``OMPI_CC``, ``OMPI_CXX``, etc. for OpenMPI. This makes the MPI compiler wrappers use the Spack compiler wrappers so that your dependencies still get proper RPATHs even if you use the MPI wrappers."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3547
# f325157390ee452ab818d3b6c84e3b02
msgid "MPI on Cray machines"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3549
# 6049fa573b204b6abdf122047a7b8f08
msgid "The Cray programming environment notably uses ITS OWN compiler wrappers, which function like MPI wrappers.  On Cray systems, the ``CC``, ``cc``, and ``ftn`` wrappers ARE the MPI compiler wrappers, and it's assumed that you'll use them for all of your builds.  So on Cray we don't bother with ``mpicc``, ``mpicxx``, etc, Spack MPI implementations set ``spec['mpi'].mpicc`` to point to Spack's wrappers, which wrap the Cray wrappers, which wrap the regular compilers and include MPI flags.  That may seem complicated, but for packagers, that means the same code for using MPI wrappers will work, even on even on a Cray:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3563
# 068488c5633341488e1030f040e14571
msgid "This is because on Cray, ``spec['mpi'].mpicc`` is just ``spack_cc``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3569
# 98b33911cbef47ada038c275b069c90f
msgid "Checking an installation"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3571
# 6702b9a0dcfd4b25a62ae6feef1f7d6b
msgid "By default, Spack assumes that a build has failed if nothing is written to the install prefix, and that it has succeeded if anything (a file, a directory, etc.)  is written to the install prefix after ``install()`` completes."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3576
# d7dc9746edb644daa9f46dcfc01a296e
msgid "Consider a simple autotools build like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3585
# e45a8cb97b98435183efc026f2959536
msgid "If you are using using standard autotools or CMake, ``configure`` and ``make`` will not write anything to the install prefix.  Only ``make install`` writes the files, and only once the build is already complete."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3592
# 20d1b37d322f434293a4f05d75cdd94c
msgid "``sanity_check_is_file`` and ``sanity_check_is_dir``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3594
# f60fc1025b1c469b863f6dd52dc1e5d8
msgid "Unfortunately, many builds of scientific software modify the install prefix *before* ``make install``. Builds like this can falsely report that they were successfully installed if an error occurs before the install is complete but after files have been written to the ``prefix``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3600
# e43797f92e1141ffba657f7104278ace
msgid "You can optionally specify *sanity checks* to deal with this problem. Add properties like this to your package:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3616
# 35ee7b37f4204149a6726697e64af066
msgid "Now, after ``install()`` runs, Spack will check whether ``$prefix/include/libelf.h`` exists and is a file, and whether ``$prefix/lib`` exists and is a directory.  If the checks fail, then the build will fail and the install prefix will be removed.  If they succeed, Spack considers the build successful and keeps the prefix in place."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3625
# 03861fddd4274599a6d6cf25a82b705d
msgid "Build-time tests"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3627
# 12a50e4bf7cb4664990bb00e926c0071
msgid "Sometimes packages finish to build \"correctly\" and issues with their run-time behavior are discovered only at a later stage, maybe after a full software stack relying on them has already been built. To avoid situations of that kind it's possible to write build-time tests that will be executed only if the option ``--run-tests`` of ``spack install`` has been activated."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3633
# 6ce17b3ba29b4339b83a3c2a514864aa
msgid "The proper way to write these tests is relying on two decorators that come with any base class listed in :ref:`installation_procedure`."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3644
# 3dde4e7afdf9465dbd6d78b6898f858a
msgid "The first decorator ``run_after('build')`` schedules this function to be invoked after the ``build`` phase has been executed, while the second one makes the invocation  conditional on the fact that ``self.run_tests == True``. It is also possible to schedule a function to be invoked *before* a given phase using the ``run_before`` decorator."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3652
# 010d2b30680647fbac8d58af7ca2ce3a
msgid "Default implementations for build-time tests"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3654
# 8606a094c6974d719ec4d6468a370061
msgid "Packages that are built using specific build systems may already have a default implementation for build-time tests. For instance :py:class:`~.AutotoolsPackage` based packages will try to invoke ``make test`` and ``make check`` if Spack is asked to run tests. More information on each class is available in the the :py:mod:`~.spack.build_systems` documentation."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3663
# 340753a0c1b14885b86ff183dd4c6026
msgid "The API for adding tests is not yet considered stable and may change drastically in future releases."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3669
# 3618c19d422941ecaef155d0cc1fdd75
msgid "File manipulation functions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3671
# d031e648314848f6bea7f31078e7c690
msgid "Many builds are not perfect. If a build lacks an install target, or if it does not use systems like CMake or autotools, which have standard ways of setting compilers and options, you may need to edit files or install some files yourself to get them working with Spack."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3676
# 770c3805f8814f2e996c6e3a44da8825
msgid "You can do this with standard Python code, and Python has rich libraries with functions for file manipulation and filtering.  Spack also provides a number of convenience functions of its own to make your life even easier.  These functions are described in this section."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3681
# dd57e09f3b63498fa5535cbe71b3dc70
msgid "All of the functions in this section can be included by simply running:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3688
# de20013f20ab49d3b05e7b78d282603a
msgid "This is already part of the boilerplate for packages created with ``spack create``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3693
# f01060ad62fc4c878233c7ffc2b5948e
msgid "Filtering functions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3731
# 5c9d4ca281c540bc9f2fed102ffff8dc
msgid ":py:func:`filter_file(regex, repl, *filenames, **kwargs) <spack.filter_file>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3696
# 1eb88ccbaf274042b23ce25763c0c68d
msgid "Works like ``sed`` but with Python regular expression syntax.  Takes a regular expression, a replacement, and a set of files.  ``repl`` can be a raw string or a callable function.  If it is a raw string, it can contain ``\\1``, ``\\2``, etc. to refer to capture groups in the regular expression.  If it is a callable, it is passed the Python ``MatchObject`` and should return a suitable replacement string for the particular match."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3704
# 8c0f4519313d4b03a1ccd7f27bf42e00
msgid "Examples:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3706
# ad5affc1ba2740e8b62b1c5b7818c54e
msgid "Filtering a Makefile to force it to use Spack's compiler wrappers:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3715
# 0f106c32c2b242d8a3ede875ae6ec0cf
msgid "Replacing ``#!/usr/bin/perl`` with ``#!/usr/bin/env perl`` in ``bib2xhtml``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3722
# 583133fa3f024232ace2cbdc999558b0
msgid "Switching the compilers used by ``mpich``'s MPI wrapper scripts from ``cc``, etc. to the compilers used by the Spack build:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3749
# 9d66cae130eb4ec9807a8efca582d755
msgid ":py:func:`change_sed_delimiter(old_delim, new_delim, *filenames) <spack.change_sed_delim>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3734
# 8d2dba1cfa4047f0ae9c78d63d70a049
msgid "Some packages, like TAU, have a build system that can't install into directories with, e.g. '@' in the name, because they use hard-coded ``sed`` commands in their build."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3738
# a07ddc06e7c4462caec9bad18bb169c2
msgid "``change_sed_delimiter`` finds all ``sed`` search/replace commands and change the delimiter.  e.g., if the file contains commands that look like ``s///``, you can use this to change them to ``s@@@``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3743
# e3d4f09a4b5446519b5fd735362dd377
msgid "Example of changing ``s///`` to ``s@@@`` in TAU:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3753
# 19bb281c605b43be979aa5fdebea79c6
msgid "File functions"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3756
# 2dc818f175b44955b611496ad13bec0a
msgid ":py:func:`ancestor(dir, n=1) <spack.ancestor>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3756
# 74cf1ea2e5074b9abcb6cc4bdec9ca36
msgid "Get the n\\ :sup:`th` ancestor of the directory ``dir``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3760
# 1442a6c87482483ca7cf8be873d1a2b3
msgid ":py:func:`can_access(path) <spack.can_access>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3759
# 898628a733104a2188f946680b072a46
msgid "True if we can read and write to the file at ``path``.  Same as native python ``os.access(file_name, os.R_OK|os.W_OK)``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3768
# 7b5bec9d422c4310a1130cf3b138acfd
msgid ":py:func:`install(src, dest) <spack.install>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3763
# 083f4075dfa349338d066c84ade00e77
msgid "Install a file to a particular location.  For example, install a header into the ``include`` directory under the install ``prefix``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3771
# 6ac2c31bdf6a431c8a8abcc28b53581e
msgid ":py:func:`join_path(*paths) <spack.join_path>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3771
# ace40e203c474cd880a46b97be083123
msgid "An alias for ``os.path.join``. This joins paths using the OS path separator."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3775
# 32125794d0e549c2b2325a072b9b9de6
msgid ":py:func:`mkdirp(*paths) <spack.mkdirp>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3774
# b1cbc09e95a644cab4d13289394b0902
msgid "Create each of the directories in ``paths``, creating any parent directories if they do not exist."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3817
# fb0424fc63aa42c9a4411519cad979c2
msgid ":py:func:`working_dir(dirname, kwargs) <spack.working_dir>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3778
# 21ff4a67814a45ff9e8ed8bf95a293f0
msgid "This is a Python `Context Manager <https://docs.python.org/2/library/contextlib.html>`_ that makes it easier to work with subdirectories in builds.  You use this with the Python ``with`` statement to change into a working directory, and when the with block is done, you change back to the original directory.  Think of it as a safe ``pushd`` / ``popd`` combination, where ``popd`` is guaranteed to be called at the end, even if exceptions are thrown."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3787
# 0083fa7b656141fda1378c06b4ebf355
msgid "Example usage:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3789
# aa69529d4089477087f7f8940bbd4c15
msgid "The ``libdwarf`` build first runs ``configure`` and ``make`` in a subdirectory called ``libdwarf``.  It then implements the installation code itself.  This is natural with ``working_dir``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3800
# 2d41b3ae596c45d292b167b124524bff
msgid "Many CMake builds require that you build \"out of source\", that is, in a subdirectory.  You can handle creating and ``cd``'ing to the subdirectory like the LLVM package does:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3816
# bbc06e7bf0b3490dabde01d3a82e2a77
msgid "The ``create=True`` keyword argument causes the command to create the directory if it does not exist."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3820
# 7cbdd252e0594dbdbad77a9372328ee2
msgid ":py:func:`touch(path) <spack.touch>`"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3820
# cae3e91ff5cd4f4685016340bf72754e
msgid "Create an empty file at ``path``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3826
# 8624299380fb47cfaa7a4feae25e66b3
msgid "Style guidelines for packages"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3828
# 9c2285b15111491391fd8cd227deedfd
msgid "The following guidelines are provided, in the interests of making Spack packages work in a consistent manner:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3833
# b291da6d27334af48a46ce5b51aedf71
msgid "Variant Names"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3835
# d8434afbe0ce4a65b4ef366e22a004a3
msgid "Spack packages with variants similar to already-existing Spack packages should use the same name for their variants.  Standard variant names are:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3840
# 045f138ffcb94ff0b1a6b88e94370cf2
msgid "Name"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3840
# ab4ecc4da3f04a6aa52e3bf6be89079f
msgid "Default"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3840
# 8f5f35aaa2054603a2781df3bf5da3bf
msgid "Description"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3842
# a14b881c8ec84fb683c62dac407f8514
msgid "shared"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3842
#: ../spack/lib/spack/docs/packaging_guide.rst:3843
#: ../spack/lib/spack/docs/packaging_guide.rst:3844
# 5383091cdb8a447195ed8a214a862472
# 4750036acda143398284c2fe0ff6c39c
# cfcff0be41394cd3b3af41a2b21a92bd
msgid "True"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3842
# 6b6ee350a40148b2b28b2d80067d825f
msgid "Build shared libraries"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3843
# b7dd355fc576410198cf0062d80a9c66
msgid "static"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3843
# 20a69cf23ffb42548d3e0a9f01cb6a19
msgid "Build static libraries"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3844
# bb43b7c47ee04cfc8cef468e481b67b5
msgid "mpi"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3844
# 6dbfaf75b14d4e28a488a8f772a63190
msgid "Use MPI"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3845
# b8a269dbd80a4bfebf80f304623d1981
msgid "python"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3845
# f54f5487d48b4f5a8d462e71f5210087
msgid "False"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3845
# dc9c5308af6f467681c30ebd03481a62
msgid "Build Python extension"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3848
# 6e8ca13325da4637b518cebbb87bdc9b
msgid "If specified in this table, the corresponding default should be used when declaring a variant."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3853
# db65db5264654bf0b8597ccc2afaa924
msgid "Version Lists"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3855
# 6d8afd68c062433d984381eaca355952
msgid "Spack packages should list supported versions with the newest first."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3859
# 55e639313e1943389fee1f1bdbdce4df
msgid "Packaging workflow commands"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3861
# ab3ce8b64b8c497fb9b52efc0251dc08
msgid "When you are building packages, you will likely not get things completely right the first time."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3864
# 885b23320b134c9e83f4ebd2dca93d43
msgid "The ``spack install`` command performs a number of tasks before it finally installs each package.  It downloads an archive, expands it in a temporary directory, and only then gives control to the package's ``install()`` method.  If the build doesn't go as planned, you may want to clean up the temporary directory, or if the package isn't downloading properly, you might want to run *only* the ``fetch`` stage of the build."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3872
# d3e4907dafba40c4aae48b9041681377
msgid "A typical package workflow might look like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3884
# 23c293b0d67e427d995668741fd1f945
msgid "Below are some commands that will allow you some finer-grained control over the install process."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3891
# 7f41b849e2f14e1f8edf1348ca7cfb60
msgid "``spack fetch``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3893
# cb32be4755e24493afbad1f07f0f344d
msgid "The first step of ``spack install``.  Takes a spec and determines the correct download URL to use for the requested package version, then downloads the archive, checks it against an MD5 checksum, and stores it in a staging directory if the check was successful.  The staging directory will be located under ``$SPACK_HOME/var/spack``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3899
# f2f8d78f71bf4d78aa510d79f36f793c
msgid "When run after the archive has already been downloaded, ``spack fetch`` is idempotent and will not download the archive again."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3906
# 65ae3264b1b848d9a59452df279407f7
msgid "``spack stage``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3908
# 70473dcb2baf46428106dd78a235f4b4
msgid "The second step in ``spack install`` after ``spack fetch``.  Expands the downloaded archive in its temporary directory, where it will be built by ``spack install``.  Similar to ``fetch``, if the archive has already been expanded,  ``stage`` is idempotent."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3917
# fbed5937f6b74bb29b2b0d14318f873f
msgid "``spack patch``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3919
# d77da3d9bcce46698a3de2abb452a82c
msgid "After staging, Spack applies patches to downloaded packages, if any have been specified in the package file.  This command will run the install process through the fetch, stage, and patch phases.  Spack keeps track of whether patches have already been applied and skips this step if they have been.  If Spack discovers that patches didn't apply cleanly on some previous run, then it will restage the entire package before patching."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3931
# b668e50c711c4f4f99779bf3779e362d
msgid "``spack restage``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3933
# 3c96f26cb3d44acba246b91897b7b715
msgid "Restores the source code to pristine state, as it was before building."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3935
# 22f32a5aa87e4b7a87e2180237ebac1c
msgid "Does this in one of two ways:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3937
# 2ad6c20c82e04716bfa6541a5b89fb17
msgid "If the source was fetched as a tarball, deletes the entire build directory and re-expands the tarball."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3940
# ffd188f985814c02a674024552f8825a
msgid "If the source was checked out from a repository, this deletes the build directory and checks it out again."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3947
# c6fb46b9a2004dd7b096e1981e49ceb6
msgid "``spack clean``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3949
# 671d6a12912046908ab1a09b3dfe6fb6
msgid "Cleans up all of Spack's temporary and cached files.  This can be used to recover disk space if temporary files from interrupted or failed installs accumulate in the staging area."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3953
# 8e1e59c40f6d46baa3abc1e22493c1cc
msgid "When called with ``--stage`` or without arguments this removes all staged files."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3956
# 491fc98deef44c9cbd124c81ddde9db0
msgid "When called with ``--downloads`` this will clear all resources :ref:`cached <caching>` during installs."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3959
# 7ed9adc21faf42a484bead4edbae8211
msgid "When called with ``--user-cache`` this will remove caches in the user home directory, including cached virtual indices."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3962
# 25f0285437d24defbe8020f3fd3e956d
msgid "To remove all of the above, the command can be called with ``--all``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3964
# bd0aa4f6873040a7944d3aeab37c75c6
msgid "When called with positional arguments, cleans up temporary files only for a particular package. If ``fetch``, ``stage``, or ``install`` are run again after this, Spack's build process will start from scratch."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3971
# 4145278b90024f76b010f74ef118b94f
msgid "Keeping the stage directory on success"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3973
# 5834b2432c09429e945b12627e4a6ca6
msgid "By default, ``spack install`` will delete the staging area once a package has been successfully built and installed.  Use ``--keep-stage`` to leave the build directory intact:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3981
# d4726850be2b47beb3145999d6fcaf5a
msgid "This allows you to inspect the build directory and potentially debug the build.  You can use ``clean`` later to get rid of the unwanted temporary files."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3987
# 27641cecf8b34fdd8ef0ab8e7d4f20e6
msgid "Keeping the install prefix on failure"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3989
# 5d986634aa7b4e6a95a4cb07a89daea1
msgid "By default, ``spack install`` will delete any partially constructed install prefix if anything fails during ``install()``.  If you want to keep the prefix anyway (e.g. to diagnose a bug), you can use ``--keep-prefix``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:3998
# 11b5b4ae595e474a8f26aa68f9f0e2b9
msgid "Note that this may confuse Spack into thinking that the package has been installed properly, so you may need to use ``spack uninstall --force`` to get rid of the install prefix before you build again:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4008
# 6676c383a2154df0abbe1c1710176498
msgid "Graphing dependencies"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4014
# 8905f0556a6541d1b34cbf79b8bab981
msgid "``spack graph``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4016
# e4164085406c4569a079b316e8500595
msgid "Spack provides the ``spack graph`` command for graphing dependencies. The command by default generates an ASCII rendering of a spec's dependency graph.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4022
# 78ef09ebfc0a4f8cb4b6eb7bee471cf4
msgid "At the top is the root package in the DAG, with dependency edges emerging from it.  On a color terminal, the edges are colored by which dependency they lead to."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4028
# 7ce878f2fc8842ae8e61339ae0c33bb5
msgid "The ``deptype`` argument tells Spack what types of dependencies to graph. By default it includes link and run dependencies but not build dependencies.  Supplying ``--deptype=link`` will show only link dependencies.  The default is ``--deptype=all``, which is equivalent to ``--deptype=build,link,run,test``.  Options for ``deptype`` include:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4034
# e1955e7bd204440eb09c95ce48d357e1
msgid "Any combination of ``build``, ``link``, ``run``, and ``test`` separated by commas."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4036
# ff0ada7774e94febbeb9ee94f7374811
msgid "``all`` for all types of dependencies."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4038
# 48be7c3ca0a84764a5295a836ebd884c
msgid "You can also use ``spack graph`` to generate graphs in the widely used `Dot <http://www.graphviz.org/doc/info/lang.html>`_ format.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4043
# f5c1386b59ec427093f5984866f230e7
msgid "This graph can be provided as input to other graphing tools, such as those in `Graphviz <http://www.graphviz.org>`_.  If you have graphviz installed, you can write straight to PDF like this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4055
# 94f01981399c48299ed7372890b3b96b
msgid "Interactive shell support"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4057
# a34deda0c4e8451697921ad82861b58d
msgid "Spack provides some limited shell support to make life easier for packagers.  You can enable these commands by sourcing a setup file in the ``share/spack`` directory.  For ``bash`` or ``ksh``, run:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4066
# 6e74a24a312247299f62faf01bb5a6a1
msgid "For ``csh`` and ``tcsh`` run:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4073
# 7b794490aefa45d0adba4a62875d2480
msgid "``spack cd`` will then be available."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4079
# b9b2346f1d2e4588a9f2ce709acc2ff3
msgid "``spack cd``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4081
# 3487a88e0d5b45faa1481a917b74f9e3
msgid "``spack cd`` allows you to quickly cd to pertinent directories in Spack. Suppose you've staged a package but you want to modify it before you build it:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4096
# 7c0ec2a4928349e2b49e18a6487c0d0d
msgid "``spack cd`` here changed the current working directory to the directory containing the expanded ``libelf`` source code.  There are a number of other places you can cd to in the spack directory hierarchy:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4102
# 8bbbb202afe04538bffd2b617861ead4
msgid "Some of these change directory into package-specific locations (stage directory, install directory, package directory) and others change to core spack locations.  For example, ``spack cd --module-dir`` will take you to the main python source directory of your spack install."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4111
# e908b0a6685947fdb3f0c05ee15ce932
msgid "``spack env``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4113
# 20d2a98e43b442789300e480e9ff9b56
msgid "``spack env`` functions much like the standard unix ``env`` command, but it takes a spec as an argument.  You can use it to see the environment variables that will be set when a particular build runs, for example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4122
# a02094939e4b42458e40ec09dec5629c
msgid "This will display the entire environment that will be set when the ``mpileaks@1.1%intel`` build runs."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4125
# 9ddb651ee0fb4dd4827b136c10f4c9cc
msgid "To run commands in a package's build environment, you can simply provide them after the spec argument to ``spack env``:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4133
# 9bfee99e561a4f2bafdee828e7567e96
msgid "This will cd to the build directory and then run ``configure`` in the package's build environment."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4140
# 3f7ba051c98a4049a49e1649cca18e61
msgid "``spack location``"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4142
# 58486104a33741eba7d4364f46d57422
msgid "``spack location`` is the same as ``spack cd`` but it does not require shell support.  It simply prints out the path you ask for, rather than cd'ing to it.  In bash, this:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4150
# d2726646eaa14691af343ef597897f47
msgid "is the same as:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4156
# 04670d0614fb4bf3bd7496d1c356b2ae
msgid "``spack location`` is intended for use in scripts or makefiles that need to know where packages are installed.  e.g., in a makefile you might write:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4168
# af08db1a8cbc4289a72529f578ea057a
msgid "Build System Configuration Support"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4170
# c1d97afa074844959c1c867db4b6b093
msgid "Imagine a developer creating a CMake or Autotools-based project in a local directory, which depends on libraries A-Z.  Once Spack has installed those dependencies, one would like to run ``cmake`` with appropriate command line and environment so CMake can find them.  The ``spack setup`` command does this conveniently, producing a CMake configuration that is essentially the same as how Spack *would have* configured the project.  This can be demonstrated with a usage example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4188
# f99d0610c5a74f7a89407bebdac62be7
msgid "Notes:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4190
# e913a39d62a2450b997ee204c7909d5f
msgid "Spack must have ``myproject/package.py`` in its repository for this to work."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4192
# 604ed83118c3413789e46de444fe3712
msgid "``spack setup`` produces the executable script ``spconfig.py`` in the local directory, and also creates the module file for the package.  ``spconfig.py`` is normally run from the user's out-of-source build directory."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4196
# fc21e18b130b4259afc009fe9c5c1bda
msgid "The version number given to ``spack setup`` is arbitrary, just like ``spack diy``.  ``myproject/package.py`` does not need to have any valid downloadable versions listed (typical when a project is new)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4200
# 924bc231df854b4f9adab7ad1e526d66
msgid "spconfig.py produces a CMake configuration that *does not* use the Spack wrappers.  Any resulting binaries *will not* use RPATH, unless the user has enabled it.  This is recommended for development purposes, not production."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4204
# fe86702c8950415199ec4b5ff77a0a88
msgid "``spconfig.py`` is human readable, and can serve as a developer reference of what dependencies are being used."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4206
# 5b4225cc324f424fbe41797115082982
msgid "``make install`` installs the package into the Spack repository, where it may be used by other Spack packages."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4208
# ad6b749d2b114cc2ad002d7265b4ec21
msgid "CMake-generated makefiles re-run CMake in some circumstances.  Use of ``spconfig.py`` breaks this behavior, requiring the developer to manually re-run ``spconfig.py`` when a ``CMakeLists.txt`` file has changed."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4215
# 7aafc92719674a878cafcfa74129f463
msgid "CMakePackage"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4217
# 2b83c0beb3ca453cb1e7116f7dae69ef
msgid "In order to enable ``spack setup`` functionality, the author of ``myproject/package.py`` must subclass from ``CMakePackage`` instead of the standard ``Package`` superclass.  Because CMake is standardized, the packager does not need to tell Spack how to run ``cmake; make; make install``.  Instead the packager only needs to create (optional) methods ``configure_args()`` and ``configure_env()``, which provide the arguments (as a list) and extra environment variables (as a dict) to provide to the ``cmake`` command.  Usually, these will translate variant flags into CMake definitions.  For example:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4239
# b4fe34559e2b4e60b3dfb87c599f3dba
msgid "If needed, a packager may also override methods defined in ``StagedPackage`` (see below)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4244
# bddd263bb24444c3b0a21b1669f4ebfc
msgid "StagedPackage"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4246
# 6ead5c2e5dda41ff8813a6e61209881d
msgid "``CMakePackage`` is implemented by subclassing the ``StagedPackage`` superclass, which breaks down the standard ``Package.install()`` method into several sub-stages: ``setup``, ``configure``, ``build`` and ``install``.  Details:"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4251
# acc0d633b7e544b3a5de7f0fd5831604
msgid "Instead of implementing the standard ``install()`` method, package authors implement the methods for the sub-stages ``install_setup()``, ``install_configure()``, ``install_build()``, and ``install_install()``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4256
# 6c3d42f4c0194e77a8b591c66bbe1481
msgid "The ``spack install`` command runs the sub-stages ``configure``, ``build`` and ``install`` in order.  (The ``setup`` stage is not run by default; see below)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4259
# 13568ed996e7410685329ca3a9bc149c
msgid "The ``spack setup`` command runs the sub-stages ``setup`` and a dummy install (to create the module file)."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4261
# 55fb36282c524e9aa0a5fe464be45b12
msgid "The sub-stage install methods take no arguments (other than ``self``).  The arguments ``spec`` and ``prefix`` to the standard ``install()`` method may be accessed via ``self.spec`` and ``self.prefix``."
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4268
# b55582e48a9040dfb0c02a2269ad2e63
msgid "GNU Autotools"
msgstr ""

#: ../spack/lib/spack/docs/packaging_guide.rst:4270
# 094ea6b72ea540699631b16618262b15
msgid "The ``setup`` functionality is currently only available for CMake-based packages.  Extending this functionality to GNU Autotools-based packages would be easy (and should be done by a developer who actively uses Autotools).  Packages that use non-standard build systems can gain ``setup`` functionality by subclassing ``StagedPackage`` directly."
msgstr ""

